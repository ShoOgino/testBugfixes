{"path":"modules/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","commits":[{"id":"3ec363f8022f02e8aca0cc8dfc2cdd6bc5d87e29","date":1332432942,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0]);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["85d41890f2bad879e6a04c6dd7d2cf276f973994","d4d69c535930b5cce125cff868d40f6373dc27d4","c4d7ac4188c98a500b3ecca495071d74ccd9cbc7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/GroupingSearch#groupByFieldOrFunction(IndexSearcher,Filter,Query,int,int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0]);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  protected TopGroups groupByFieldOrFunction(IndexSearcher searcher, Filter filter, Query query, int groupOffset, int groupLimit) throws IOException {\n    int topN = groupOffset + groupLimit;\n    final AbstractFirstPassGroupingCollector firstPassCollector;\n    final AbstractAllGroupsCollector allGroupsCollector;\n    final AbstractAllGroupHeadsCollector allGroupHeadsCollector;\n    if (groupFunction != null) {\n      firstPassCollector = new FunctionFirstPassGroupingCollector(groupFunction, valueSourceContext, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new FunctionAllGroupsCollector(groupFunction, valueSourceContext);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = new FunctionAllGroupHeadsCollector(groupFunction, valueSourceContext, sortWithinGroup);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else if (docValuesType != null) {\n      firstPassCollector = DVFirstPassGroupingCollector.create(groupSort, topN, groupField, docValuesType, diskResidentDocValues);\n      if (allGroups) {\n        allGroupsCollector = DVAllGroupsCollector.create(groupField, docValuesType, diskResidentDocValues, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = DVAllGroupHeadsCollector.create(groupField, sortWithinGroup, docValuesType, diskResidentDocValues);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    } else {\n      firstPassCollector = new TermFirstPassGroupingCollector(groupField, groupSort, topN);\n      if (allGroups) {\n        allGroupsCollector = new TermAllGroupsCollector(groupField, initialSize);\n      } else {\n        allGroupsCollector = null;\n      }\n      if (allGroupHeads) {\n        allGroupHeadsCollector = TermAllGroupHeadsCollector.create(groupField, sortWithinGroup, initialSize);\n      } else {\n        allGroupHeadsCollector = null;\n      }\n    }\n\n    final Collector firstRound;\n    if (allGroupHeads || allGroups) {\n      List<Collector> collectors = new ArrayList<Collector>();\n      collectors.add(firstPassCollector);\n      if (allGroupHeads) {\n        collectors.add(allGroupsCollector);\n      }\n      if (allGroupHeads) {\n        collectors.add(allGroupHeadsCollector);\n      }\n      firstRound = MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));\n    } else {\n      firstRound = firstPassCollector;\n    }\n\n    CachingCollector cachedCollector = null;\n    if (maxCacheRAMMB != null || maxDocsToCache != null) {\n      if (maxCacheRAMMB != null) {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxCacheRAMMB);\n      } else {\n        cachedCollector = CachingCollector.create(firstRound, cacheScores, maxDocsToCache);\n      }\n      searcher.search(query, filter, cachedCollector);\n    } else {\n      searcher.search(query, filter, firstRound);\n    }\n\n    if (allGroups) {\n      matchingGroups = allGroupsCollector.getGroups();\n    } else {\n      matchingGroups = Collections.emptyList();\n    }\n    if (allGroupHeads) {\n      matchingGroupHeads = allGroupHeadsCollector.retrieveGroupHeads(searcher.getIndexReader().maxDoc());\n    } else {\n      matchingGroupHeads = new Bits.MatchNoBits(searcher.getIndexReader().maxDoc());\n    }\n\n    Collection<SearchGroup> topSearchGroups = firstPassCollector.getTopGroups(groupOffset, fillSortFields);\n    if (topSearchGroups == null) {\n      return new TopGroups(new SortField[0], new SortField[0], 0, 0, new GroupDocs[0]);\n    }\n\n    int topNInsideGroup = groupDocsOffset + groupDocsLimit;\n    AbstractSecondPassGroupingCollector secondPassCollector;\n    if (groupFunction != null) {\n      secondPassCollector = new FunctionSecondPassGroupingCollector((Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields, groupFunction, valueSourceContext);\n    } else if (docValuesType != null) {\n      secondPassCollector = DVSecondPassGroupingCollector.create(groupField, diskResidentDocValues, docValuesType, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    } else {\n      secondPassCollector = new TermSecondPassGroupingCollector(groupField, (Collection) topSearchGroups, groupSort, sortWithinGroup, topNInsideGroup, includeScores, includeMaxScore, fillSortFields);\n    }\n\n    if (cachedCollector != null && cachedCollector.isCached()) {\n      cachedCollector.replay(secondPassCollector);\n    } else {\n      searcher.search(query, filter, secondPassCollector);\n    }\n\n    if (allGroups) {\n      return new TopGroups(secondPassCollector.getTopGroups(groupDocsOffset), matchingGroups.size());\n    } else {\n      return secondPassCollector.getTopGroups(groupDocsOffset);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3ec363f8022f02e8aca0cc8dfc2cdd6bc5d87e29":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["3ec363f8022f02e8aca0cc8dfc2cdd6bc5d87e29"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"3ec363f8022f02e8aca0cc8dfc2cdd6bc5d87e29":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3ec363f8022f02e8aca0cc8dfc2cdd6bc5d87e29"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}