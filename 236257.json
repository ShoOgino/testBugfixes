{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"/dev/null","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    leafNodeOffset = numLeaves;\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Tree is fully balanced binary tree, so number of nodes = numLeaves-1, except our nodeIDs are 1-based (splitPackedValues[0] is unused):\n    leafBlockFPs = new long[numLeaves];\n    for(int i=0;i<numLeaves;i++) {\n      leafBlockFPs[i] = in.readVLong();\n    }\n\n    this.in = in;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    leafNodeOffset = numLeaves;\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Tree is fully balanced binary tree, so number of nodes = numLeaves-1, except our nodeIDs are 1-based (splitPackedValues[0] is unused):\n    leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    leafNodeOffset = numLeaves;\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Tree is fully balanced binary tree, so number of nodes = numLeaves-1, except our nodeIDs are 1-based (splitPackedValues[0] is unused):\n    leafBlockFPs = new long[numLeaves];\n    for(int i=0;i<numLeaves;i++) {\n      leafBlockFPs[i] = in.readVLong();\n    }\n\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1786be6a11f9cf5e48ce84869d1bb71e9c02f966","date":1448381196,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    leafNodeOffset = numLeaves;\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    leafNodeOffset = numLeaves;\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Tree is fully balanced binary tree, so number of nodes = numLeaves-1, except our nodeIDs are 1-based (splitPackedValues[0] is unused):\n    leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d53f98721d7cda12df9fd4b2e8e2c235be9ac494","date":1450448699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    leafNodeOffset = numLeaves;\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecf331f9d7bdd234863d2df2bb5c1f019979422f","date":1452250335,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7","date":1456959208,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"251c5b33f0a2c8988550b63c78ed22b0e84524e5","date":1456961997,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"adc24e961ba2d17d4cc061a9fde65e9059b7f1ee","date":1467616421,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd630fded84c5695bd4e07bda0a20634517a4224","date":1476795950,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef","date":1476800106,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_START);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[(1+bytesPerDim)*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"313b9c84057c3a31294cbcd794ea84c4e81646d9","date":1478080099,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9720b151fde2073f4e401450f4574e5f31c2d0ff","date":1478184029,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    if (version >= BKDWriter.VERSION_PACKED_INDEX) {\n      int numBytes = in.readVInt();\n      packedIndex = new byte[numBytes];\n      in.readBytes(packedIndex, 0, numBytes);\n      leafBlockFPs = null;\n      splitPackedValues = null;\n    } else {\n      // legacy un-packed index\n\n      splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n      in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n      // Read the file pointers to the start of each leaf block:\n      long[] leafBlockFPs = new long[numLeaves];\n      long lastFP = 0;\n      for(int i=0;i<numLeaves;i++) {\n        long delta = in.readVLong();\n        leafBlockFPs[i] = lastFP + delta;\n        lastFP += delta;\n      }\n\n      // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n      // if it was created by BKDWriter.merge or OneDimWriter).  In this case the leaf nodes may straddle the two bottom\n      // levels of the binary tree:\n      if (numDims == 1 && numLeaves > 1) {\n        int levelCount = 2;\n        while (true) {\n          if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n            int lastLevel = 2*(numLeaves - levelCount);\n            assert lastLevel >= 0;\n            if (lastLevel != 0) {\n              // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n              // at read-time, so that we can still delta code them on disk at write:\n              long[] newLeafBlockFPs = new long[numLeaves];\n              System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n              System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n              leafBlockFPs = newLeafBlockFPs;\n            }\n            break;\n          }\n\n          levelCount *= 2;\n        }\n      }\n      \n      this.leafBlockFPs = leafBlockFPs;\n      packedIndex = null;\n    }\n\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    if (version >= BKDWriter.VERSION_PACKED_INDEX) {\n      int numBytes = in.readVInt();\n      packedIndex = new byte[numBytes];\n      in.readBytes(packedIndex, 0, numBytes);\n      leafBlockFPs = null;\n      splitPackedValues = null;\n    } else {\n      // legacy un-packed index\n\n      splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n      in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n      // Read the file pointers to the start of each leaf block:\n      long[] leafBlockFPs = new long[numLeaves];\n      long lastFP = 0;\n      for(int i=0;i<numLeaves;i++) {\n        long delta = in.readVLong();\n        leafBlockFPs[i] = lastFP + delta;\n        lastFP += delta;\n      }\n\n      // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n      // if it was created by BKDWriter.merge or OneDimWriter).  In this case the leaf nodes may straddle the two bottom\n      // levels of the binary tree:\n      if (numDims == 1 && numLeaves > 1) {\n        int levelCount = 2;\n        while (true) {\n          if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n            int lastLevel = 2*(numLeaves - levelCount);\n            assert lastLevel >= 0;\n            if (lastLevel != 0) {\n              // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n              // at read-time, so that we can still delta code them on disk at write:\n              long[] newLeafBlockFPs = new long[numLeaves];\n              System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n              System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n              leafBlockFPs = newLeafBlockFPs;\n            }\n            break;\n          }\n\n          levelCount *= 2;\n        }\n      }\n      \n      this.leafBlockFPs = leafBlockFPs;\n      packedIndex = null;\n    }\n\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    int numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n    // TODO: don't write split packed values[0]!\n    in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n    // Read the file pointers to the start of each leaf block:\n    long[] leafBlockFPs = new long[numLeaves];\n    long lastFP = 0;\n    for(int i=0;i<numLeaves;i++) {\n      long delta = in.readVLong();\n      leafBlockFPs[i] = lastFP + delta;\n      lastFP += delta;\n    }\n\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n    // if it was created by BKDWriter.merge).  In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    if (numDims == 1 && numLeaves > 1) {\n      //System.out.println(\"BKDR: numLeaves=\" + numLeaves);\n      int levelCount = 2;\n      while (true) {\n        //System.out.println(\"  cycle levelCount=\" + levelCount);\n        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n          int lastLevel = 2*(numLeaves - levelCount);\n          assert lastLevel >= 0;\n          /*\n          System.out.println(\"BKDR: lastLevel=\" + lastLevel + \" vs \" + levelCount);\n          System.out.println(\"FPs before:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          if (lastLevel != 0) {\n            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n            // at read-time, so that we can still delta code them on disk at write:\n            //System.out.println(\"BKDR: now rotate index\");\n            long[] newLeafBlockFPs = new long[numLeaves];\n            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n            leafBlockFPs = newLeafBlockFPs;\n          }\n          /*\n          System.out.println(\"FPs:\");\n          for(int i=0;i<leafBlockFPs.length;i++) {\n            System.out.println(\"  \" + i + \" \" + leafBlockFPs[i]);\n          }\n          */\n          break;\n        }\n\n        levelCount *= 2;\n      }\n    }\n\n    this.leafBlockFPs = leafBlockFPs;\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0e7448656541edc407546460641f47950451b16","date":1519150500,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    packedIndex = new byte[numBytes];\n    in.readBytes(packedIndex, 0, numBytes);\n\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    bytesPerIndexEntry = numDims == 1 && version >= BKDWriter.VERSION_IMPLICIT_SPLIT_DIM_1D ? bytesPerDim : bytesPerDim + 1;\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    if (version >= BKDWriter.VERSION_PACKED_INDEX) {\n      int numBytes = in.readVInt();\n      packedIndex = new byte[numBytes];\n      in.readBytes(packedIndex, 0, numBytes);\n      leafBlockFPs = null;\n      splitPackedValues = null;\n    } else {\n      // legacy un-packed index\n\n      splitPackedValues = new byte[bytesPerIndexEntry*numLeaves];\n\n      in.readBytes(splitPackedValues, 0, splitPackedValues.length);\n\n      // Read the file pointers to the start of each leaf block:\n      long[] leafBlockFPs = new long[numLeaves];\n      long lastFP = 0;\n      for(int i=0;i<numLeaves;i++) {\n        long delta = in.readVLong();\n        leafBlockFPs[i] = lastFP + delta;\n        lastFP += delta;\n      }\n\n      // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n      // if it was created by BKDWriter.merge or OneDimWriter).  In this case the leaf nodes may straddle the two bottom\n      // levels of the binary tree:\n      if (numDims == 1 && numLeaves > 1) {\n        int levelCount = 2;\n        while (true) {\n          if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n            int lastLevel = 2*(numLeaves - levelCount);\n            assert lastLevel >= 0;\n            if (lastLevel != 0) {\n              // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n              // at read-time, so that we can still delta code them on disk at write:\n              long[] newLeafBlockFPs = new long[numLeaves];\n              System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n              System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n              leafBlockFPs = newLeafBlockFPs;\n            }\n            break;\n          }\n\n          levelCount *= 2;\n        }\n      }\n      \n      this.leafBlockFPs = leafBlockFPs;\n      packedIndex = null;\n    }\n\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (FutureArrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    packedIndex = new byte[numBytes];\n    in.readBytes(packedIndex, 0, numBytes);\n\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (StringHelper.compare(bytesPerDim, minPackedValue, dim*bytesPerDim, maxPackedValue, dim*bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    packedIndex = new byte[numBytes];\n    in.readBytes(packedIndex, 0, numBytes);\n\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = in.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = in.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    in.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (FutureArrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    packedIndex = new byte[numBytes];\n    in.readBytes(packedIndex, 0, numBytes);\n\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDims = in.readVInt();\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedBytesLength];\n    maxPackedValue = new byte[packedBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedBytesLength);\n    in.readBytes(maxPackedValue, 0, packedBytesLength);\n\n    for(int dim=0;dim<numDims;dim++) {\n      if (FutureArrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    packedIndex = new byte[numBytes];\n    in.readBytes(packedIndex, 0, numBytes);\n\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = in.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = in.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    in.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (Arrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    packedIndex = new byte[numBytes];\n    in.readBytes(packedIndex, 0, numBytes);\n\n    this.in = in;\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = in.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = in.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    in.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (FutureArrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    packedIndex = new byte[numBytes];\n    in.readBytes(packedIndex, 0, numBytes);\n\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbc55bb1f9b4422860b0f903e6af8082280e7b72","date":1571986943,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    this(in, in instanceof ByteBufferIndexInput);\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = in.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = in.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    in.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (Arrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    packedIndex = new byte[numBytes];\n    in.readBytes(packedIndex, 0, numBytes);\n\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,IndexInput,IndexInput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput).mjava","sourceNew":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput metaIn, IndexInput indexIn, IndexInput dataIn) throws IOException {\n    this(metaIn, indexIn, dataIn, indexIn instanceof ByteBufferIndexInput);\n  }\n\n","sourceOld":"  /** Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned */\n  public BKDReader(IndexInput in) throws IOException {\n    this(in, in instanceof ByteBufferIndexInput);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0e7448656541edc407546460641f47950451b16":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["d53f98721d7cda12df9fd4b2e8e2c235be9ac494"],"f6652c943595e92c187ee904c382863013eae28f":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","313b9c84057c3a31294cbcd794ea84c4e81646d9"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["313b9c84057c3a31294cbcd794ea84c4e81646d9"],"adc24e961ba2d17d4cc061a9fde65e9059b7f1ee":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["f6652c943595e92c187ee904c382863013eae28f"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["c0e7448656541edc407546460641f47950451b16"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd630fded84c5695bd4e07bda0a20634517a4224":["adc24e961ba2d17d4cc061a9fde65e9059b7f1ee"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"d53f98721d7cda12df9fd4b2e8e2c235be9ac494":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"9856095f7afb5a607bf5e65077615ed91273508c":["9720b151fde2073f4e401450f4574e5f31c2d0ff","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"313b9c84057c3a31294cbcd794ea84c4e81646d9":["f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["ecf331f9d7bdd234863d2df2bb5c1f019979422f","251c5b33f0a2c8988550b63c78ed22b0e84524e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef":["adc24e961ba2d17d4cc061a9fde65e9059b7f1ee","dd630fded84c5695bd4e07bda0a20634517a4224"]},"commit2Childs":{"c0e7448656541edc407546460641f47950451b16":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["d53f98721d7cda12df9fd4b2e8e2c235be9ac494"],"ecf331f9d7bdd234863d2df2bb5c1f019979422f":["879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"f6652c943595e92c187ee904c382863013eae28f":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"9720b151fde2073f4e401450f4574e5f31c2d0ff":["9856095f7afb5a607bf5e65077615ed91273508c"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9720b151fde2073f4e401450f4574e5f31c2d0ff"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["c0e7448656541edc407546460641f47950451b16","9856095f7afb5a607bf5e65077615ed91273508c"],"adc24e961ba2d17d4cc061a9fde65e9059b7f1ee":["dd630fded84c5695bd4e07bda0a20634517a4224","f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["f6652c943595e92c187ee904c382863013eae28f"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"dd630fded84c5695bd4e07bda0a20634517a4224":["f177ec0246f5d1788b56d8f5d5c66cb38d66bcef"],"d53f98721d7cda12df9fd4b2e8e2c235be9ac494":["ecf331f9d7bdd234863d2df2bb5c1f019979422f"],"879e8cf5ab626b9bf29f1ef603e3a28601fcb1a7":["251c5b33f0a2c8988550b63c78ed22b0e84524e5"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"313b9c84057c3a31294cbcd794ea84c4e81646d9":["9720b151fde2073f4e401450f4574e5f31c2d0ff","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","adc24e961ba2d17d4cc061a9fde65e9059b7f1ee"],"f177ec0246f5d1788b56d8f5d5c66cb38d66bcef":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","313b9c84057c3a31294cbcd794ea84c4e81646d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}