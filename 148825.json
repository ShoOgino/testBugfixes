{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    int i = 0;\n    while(i < 100) {\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    int i = 0;\n    while(i < 100) {\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96941450b74efbfe3c382a401ef1ff8472ce8df8","date":1356711516,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    int i = 0;\n    while(i < 100) {\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"479fba77febd29e498fc4a430359e4cf88341da7","date":1357213856,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d55763df1c6badbe23b44b735ca86273d27caed","date":1357229491,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(3000);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45cfc86fd6687c6516f90a40900b9fd2ba81017b","date":1357229603,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(3000);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    int i = 0;\n    while(i < 100) {\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f83659f3ad9c8b35c13c733190c805185b287f4","date":1357839018,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  //nocommit: make this tests DV2.0\n  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e6fb2e60a91ffb7a435aa2b085ecb942dd11446","date":1358780574,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","sourceOld":"  //nocommit: make this tests DV2.0\n  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1f3bfdf2fbf9eb7c32953111625b8149f767900","date":1398169177,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(new String(t.bytesLog.toString(\"UTF-8\")));\n    }\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518","date":1398331323,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(new String(t.bytesLog.toString(\"UTF-8\")));\n    }\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    assertFalse(t.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt(1);\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(new String(t.bytesLog.toString(\"UTF-8\")));\n    }\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt();\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(new String(t.bytesLog.toString(\"UTF-8\")));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ae6725e6ae382af525653dca26303eb0661c71f","date":1417051373,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt(1);\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    final int numInterrupts = atLeast(100);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(new String(t.bytesLog.toString(\"UTF-8\")));\n    }\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt(1);\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(new String(t.bytesLog.toString(\"UTF-8\")));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7","date":1490708104,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt(1);\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    final int numInterrupts = atLeast(100);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(t.bytesLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt(1);\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    final int numInterrupts = atLeast(100);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(new String(t.bytesLog.toString(\"UTF-8\")));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57df4f31144a04dc0e8382aed10ebfa82ef71a4d","date":1490873945,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testThreadInterruptDeadlock().mjava","sourceNew":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt(1);\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    final int numInterrupts = atLeast(100);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(t.bytesLog.toString(\"UTF-8\"));\n    }\n  }\n\n","sourceOld":"  public void testThreadInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t = new IndexerThreadInterrupt(1);\n    t.setDaemon(true);\n    t.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 100 interrupts to child thread\n    final int numInterrupts = atLeast(100);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t.isAlive()) {\n        break;\n      }\n    }\n    t.finish = true;\n    t.join();\n    if (t.failed) {\n      fail(new String(t.bytesLog.toString(\"UTF-8\")));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","45cfc86fd6687c6516f90a40900b9fd2ba81017b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"96941450b74efbfe3c382a401ef1ff8472ce8df8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"57df4f31144a04dc0e8382aed10ebfa82ef71a4d":["9ae6725e6ae382af525653dca26303eb0661c71f"],"9ae6725e6ae382af525653dca26303eb0661c71f":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["f1f3bfdf2fbf9eb7c32953111625b8149f767900"],"f1f3bfdf2fbf9eb7c32953111625b8149f767900":["45cfc86fd6687c6516f90a40900b9fd2ba81017b"],"479fba77febd29e498fc4a430359e4cf88341da7":["96941450b74efbfe3c382a401ef1ff8472ce8df8"],"2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7":["9ae6725e6ae382af525653dca26303eb0661c71f"],"9f83659f3ad9c8b35c13c733190c805185b287f4":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"0d55763df1c6badbe23b44b735ca86273d27caed":["479fba77febd29e498fc4a430359e4cf88341da7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"45cfc86fd6687c6516f90a40900b9fd2ba81017b":["0d55763df1c6badbe23b44b735ca86273d27caed"],"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518":["45cfc86fd6687c6516f90a40900b9fd2ba81017b"],"5e6fb2e60a91ffb7a435aa2b085ecb942dd11446":["9f83659f3ad9c8b35c13c733190c805185b287f4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["9f83659f3ad9c8b35c13c733190c805185b287f4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","96941450b74efbfe3c382a401ef1ff8472ce8df8"],"96941450b74efbfe3c382a401ef1ff8472ce8df8":["479fba77febd29e498fc4a430359e4cf88341da7"],"57df4f31144a04dc0e8382aed10ebfa82ef71a4d":[],"9ae6725e6ae382af525653dca26303eb0661c71f":["57df4f31144a04dc0e8382aed10ebfa82ef71a4d","2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["9ae6725e6ae382af525653dca26303eb0661c71f"],"f1f3bfdf2fbf9eb7c32953111625b8149f767900":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"479fba77febd29e498fc4a430359e4cf88341da7":["0d55763df1c6badbe23b44b735ca86273d27caed"],"2d72c1db036e3e6c3a62f3b82bbba46870c7e3c7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9f83659f3ad9c8b35c13c733190c805185b287f4":["5e6fb2e60a91ffb7a435aa2b085ecb942dd11446"],"0d55763df1c6badbe23b44b735ca86273d27caed":["45cfc86fd6687c6516f90a40900b9fd2ba81017b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"45cfc86fd6687c6516f90a40900b9fd2ba81017b":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f1f3bfdf2fbf9eb7c32953111625b8149f767900","e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518"],"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518":[],"5e6fb2e60a91ffb7a435aa2b085ecb942dd11446":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["57df4f31144a04dc0e8382aed10ebfa82ef71a4d","e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518","5e6fb2e60a91ffb7a435aa2b085ecb942dd11446","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}