{"path":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","commits":[{"id":"a35a7d0e36dd6f5b4f8053ac085490326734d5e4","date":1460739189,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","pathOld":"/dev/null","sourceNew":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      \n      double polyLats[] = polygon.getPolyLats();\n      double polyLons[] = polygon.getPolyLons();\n      \n      // random lat/lons in bounding box\n      for (int j = 0; j < 1000; j++) {\n        double latitude = nextLatitudeAround(polygon.minLat, polygon.maxLat);\n        double longitude = nextLongitudeAround(polygon.minLon, polygon.maxLon);\n        // bounding box check required due to rounding errors (we don't solve that problem)\n        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n          assertEquals(expected, polygon.contains(latitude, longitude));\n        }\n      }\n      \n      // lat lons targeted near vertices\n      for (int vertex = 0; vertex < polyLats.length; vertex++) {\n        for (int j = 0; j < 100; j++) {\n          double latitude = GeoTestUtil.nextLatitudeNear(polyLats[vertex]);\n          double longitude = GeoTestUtil.nextLongitudeNear(polyLons[vertex]);\n          // bounding box check required due to rounding errors (we don't solve that problem)\n          if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n            boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n            assertEquals(expected, polygon.contains(latitude, longitude));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73457c9372b4f2f962ca916788a5fe9e1f644a9f","date":1460794059,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","pathOld":"/dev/null","sourceNew":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      \n      double polyLats[] = polygon.getPolyLats();\n      double polyLons[] = polygon.getPolyLons();\n      \n      // random lat/lons in bounding box\n      for (int j = 0; j < 1000; j++) {\n        double latitude = nextLatitudeAround(polygon.minLat, polygon.maxLat);\n        double longitude = nextLongitudeAround(polygon.minLon, polygon.maxLon);\n        // bounding box check required due to rounding errors (we don't solve that problem)\n        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n          assertEquals(expected, polygon.contains(latitude, longitude));\n        }\n      }\n      \n      // lat lons targeted near vertices\n      for (int vertex = 0; vertex < polyLats.length; vertex++) {\n        for (int j = 0; j < 100; j++) {\n          double latitude = GeoTestUtil.nextLatitudeNear(polyLats[vertex]);\n          double longitude = GeoTestUtil.nextLongitudeNear(polyLons[vertex]);\n          // bounding box check required due to rounding errors (we don't solve that problem)\n          if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n            boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n            assertEquals(expected, polygon.contains(latitude, longitude));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2","date":1460953142,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","sourceNew":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      \n      double polyLats[] = polygon.getPolyLats();\n      double polyLons[] = polygon.getPolyLons();\n      \n      // random lat/lons against polygon\n      for (int j = 0; j < 1000; j++) {\n        double point[] = GeoTestUtil.nextPointNear(polygon);\n        double latitude = point[0];\n        double longitude = point[1];\n        // bounding box check required due to rounding errors (we don't solve that problem)\n        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n          assertEquals(expected, polygon.contains(latitude, longitude));\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      \n      double polyLats[] = polygon.getPolyLats();\n      double polyLons[] = polygon.getPolyLons();\n      \n      // random lat/lons in bounding box\n      for (int j = 0; j < 1000; j++) {\n        double latitude = nextLatitudeAround(polygon.minLat, polygon.maxLat);\n        double longitude = nextLongitudeAround(polygon.minLon, polygon.maxLon);\n        // bounding box check required due to rounding errors (we don't solve that problem)\n        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n          assertEquals(expected, polygon.contains(latitude, longitude));\n        }\n      }\n      \n      // lat lons targeted near vertices\n      for (int vertex = 0; vertex < polyLats.length; vertex++) {\n        for (int j = 0; j < 100; j++) {\n          double latitude = GeoTestUtil.nextLatitudeNear(polyLats[vertex]);\n          double longitude = GeoTestUtil.nextLongitudeNear(polyLons[vertex]);\n          // bounding box check required due to rounding errors (we don't solve that problem)\n          if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n            boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n            assertEquals(expected, polygon.contains(latitude, longitude));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"713122036535651642e6d4fe57ce12b449e18473","date":1461000510,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","sourceNew":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      \n      double polyLats[] = polygon.getPolyLats();\n      double polyLons[] = polygon.getPolyLons();\n      \n      // random lat/lons against polygon\n      for (int j = 0; j < 1000; j++) {\n        double point[] = GeoTestUtil.nextPointNear(polygon);\n        double latitude = point[0];\n        double longitude = point[1];\n        // bounding box check required due to rounding errors (we don't solve that problem)\n        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n          assertEquals(expected, polygon.contains(latitude, longitude));\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      \n      double polyLats[] = polygon.getPolyLats();\n      double polyLons[] = polygon.getPolyLons();\n      \n      // random lat/lons in bounding box\n      for (int j = 0; j < 1000; j++) {\n        double latitude = nextLatitudeAround(polygon.minLat, polygon.maxLat);\n        double longitude = nextLongitudeAround(polygon.minLon, polygon.maxLon);\n        // bounding box check required due to rounding errors (we don't solve that problem)\n        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n          assertEquals(expected, polygon.contains(latitude, longitude));\n        }\n      }\n      \n      // lat lons targeted near vertices\n      for (int vertex = 0; vertex < polyLats.length; vertex++) {\n        for (int j = 0; j < 100; j++) {\n          double latitude = GeoTestUtil.nextLatitudeNear(polyLats[vertex]);\n          double longitude = GeoTestUtil.nextLongitudeNear(polyLons[vertex]);\n          // bounding box check required due to rounding errors (we don't solve that problem)\n          if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n            boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n            assertEquals(expected, polygon.contains(latitude, longitude));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"925fce43f3bac029d912b9b7de03c789e258a333","date":1461612714,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D#testContainsAgainstOriginal().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","sourceNew":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      Polygon2D impl = Polygon2D.create(polygon);\n      \n      // random lat/lons against polygon\n      for (int j = 0; j < 1000; j++) {\n        double point[] = GeoTestUtil.nextPointNear(polygon);\n        double latitude = point[0];\n        double longitude = point[1];\n        boolean expected = GeoTestUtil.containsSlowly(polygon, latitude, longitude);\n        assertEquals(expected, impl.contains(latitude, longitude));\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      \n      double polyLats[] = polygon.getPolyLats();\n      double polyLons[] = polygon.getPolyLons();\n      \n      // random lat/lons against polygon\n      for (int j = 0; j < 1000; j++) {\n        double point[] = GeoTestUtil.nextPointNear(polygon);\n        double latitude = point[0];\n        double longitude = point[1];\n        // bounding box check required due to rounding errors (we don't solve that problem)\n        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n          assertEquals(expected, polygon.contains(latitude, longitude));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D#testContainsAgainstOriginal().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestPolygon#testContainsAgainstOriginal().mjava","sourceNew":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      Polygon2D impl = Polygon2D.create(polygon);\n      \n      // random lat/lons against polygon\n      for (int j = 0; j < 1000; j++) {\n        double point[] = GeoTestUtil.nextPointNear(polygon);\n        double latitude = point[0];\n        double longitude = point[1];\n        boolean expected = GeoTestUtil.containsSlowly(polygon, latitude, longitude);\n        assertEquals(expected, impl.contains(latitude, longitude));\n      }\n    }\n  }\n\n","sourceOld":"  /** Tests current impl against original algorithm */\n  public void testContainsAgainstOriginal() {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = nextPolygon();\n      // currently we don't generate these, but this test does not want holes.\n      while (polygon.getHoles().length > 0) {\n        polygon = nextPolygon();\n      }\n      \n      double polyLats[] = polygon.getPolyLats();\n      double polyLons[] = polygon.getPolyLons();\n      \n      // random lat/lons against polygon\n      for (int j = 0; j < 1000; j++) {\n        double point[] = GeoTestUtil.nextPointNear(polygon);\n        double latitude = point[0];\n        double longitude = point[1];\n        // bounding box check required due to rounding errors (we don't solve that problem)\n        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {\n          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);\n          assertEquals(expected, polygon.contains(latitude, longitude));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"713122036535651642e6d4fe57ce12b449e18473":["73457c9372b4f2f962ca916788a5fe9e1f644a9f","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["713122036535651642e6d4fe57ce12b449e18473","925fce43f3bac029d912b9b7de03c789e258a333"],"a35a7d0e36dd6f5b4f8053ac085490326734d5e4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"73457c9372b4f2f962ca916788a5fe9e1f644a9f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a35a7d0e36dd6f5b4f8053ac085490326734d5e4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"925fce43f3bac029d912b9b7de03c789e258a333":["713122036535651642e6d4fe57ce12b449e18473"]},"commit2Childs":{"713122036535651642e6d4fe57ce12b449e18473":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","925fce43f3bac029d912b9b7de03c789e258a333"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a35a7d0e36dd6f5b4f8053ac085490326734d5e4","73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a35a7d0e36dd6f5b4f8053ac085490326734d5e4":["73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["713122036535651642e6d4fe57ce12b449e18473"],"73457c9372b4f2f962ca916788a5fe9e1f644a9f":["713122036535651642e6d4fe57ce12b449e18473","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"925fce43f3bac029d912b9b7de03c789e258a333":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}