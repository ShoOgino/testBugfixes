{"path":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(InvertedFields,FieldInfos).mjava","commits":[{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(InvertedFields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both InvertedFields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(InvertedFields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(InvertedFields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both InvertedFields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(InvertedFields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      boolean startedField = false;\n\n      // NOTE: this is tricky, because TermVectors allow\n      // indexing offsets but NOT positions.  So we must\n      // lazily init the field by checking whether first\n      // position we see is -1 or not.\n\n      int termCount = 0;\n      while(termsEnum.next() != null) {\n        termCount++;\n\n        final int freq = (int) termsEnum.totalTermFreq();\n\n        if (startedField) {\n          startTerm(termsEnum.term(), freq);\n        }\n\n        // TODO: we need a \"query\" API where we can ask (via\n        // flex API) what this term was indexed with...\n        // Both positions & offsets:\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, true);\n        final boolean hasOffsets;\n        boolean hasPositions = false;\n        if (docsAndPositionsEnum == null) {\n          // Fallback: no offsets\n          docsAndPositionsEnum = termsEnum.docsAndPositions(null, null, false);\n          hasOffsets = false;\n        } else {\n          hasOffsets = true;\n        }\n\n        if (docsAndPositionsEnum != null) {\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocIdSetIterator.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            if (!startedField) {\n              assert numTerms > 0;\n              hasPositions = pos != -1;\n              startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n              startTerm(termsEnum.term(), freq);\n              startedField = true;\n            }\n            final int startOffset;\n            final int endOffset;\n            if (hasOffsets) {\n              startOffset = docsAndPositionsEnum.startOffset();\n              endOffset = docsAndPositionsEnum.endOffset();\n              assert startOffset != -1;\n              assert endOffset != -1;\n            } else {\n              startOffset = -1;\n              endOffset = -1;\n            }\n            assert !hasPositions || pos >= 0;\n            addPosition(pos, startOffset, endOffset);\n          }\n        } else {\n          if (!startedField) {\n            assert numTerms > 0;\n            startField(fieldInfo, numTerms, hasPositions, hasOffsets);\n            startTerm(termsEnum.term(), freq);\n            startedField = true;\n          }\n        }\n      }\n      assert termCount == numTerms;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}