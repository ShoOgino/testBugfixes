{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's\n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's\n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0061262413ecc163d6eebba1b5c43ab91a0c2dc5","date":1311195279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader, false);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a688e33119c8fbce2e40e40ef1215dc501e43d2e","date":1312748137,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        // the pulled reader could be from an in-flight merge \n        // while the info we see has already new applied deletes after a commit\n        // we max out the delets since deletes never shrink\n        return Math.max(info.getDelCount(), reader.numDeletedDocs());\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader, false);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        return reader.numDeletedDocs();\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader, false);\n      }\n    }\n  }\n\n","bugFix":["f33fc116e28d7704378c9dd333711753bd0c9706"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ddeeafb97cacc0f0e449e34a246cb6dda2c712b","date":1316619234,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    ensureOpen(false);\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        // the pulled reader could be from an in-flight merge \n        // while the info we see has already new applied deletes after a commit\n        // we max out the delets since deletes never shrink\n        return Math.max(info.getDelCount(), reader.numDeletedDocs());\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader, false);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        // the pulled reader could be from an in-flight merge \n        // while the info we see has already new applied deletes after a commit\n        // we max out the delets since deletes never shrink\n        return Math.max(info.getDelCount(), reader.numDeletedDocs());\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader, false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6adfdb3f33dbaf27203539f573faac3966cc55f","date":1318443641,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    ensureOpen(false);\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        // the pulled reader could be from an in-flight merge \n        // while the info we see has already new applied deletes after a commit\n        // we max out the deletes since deletes never shrink\n        return Math.max(info.getDelCount(), reader.numDeletedDocs());\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader, false);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    ensureOpen(false);\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        // the pulled reader could be from an in-flight merge \n        // while the info we see has already new applied deletes after a commit\n        // we max out the delets since deletes never shrink\n        return Math.max(info.getDelCount(), reader.numDeletedDocs());\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader, false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    ensureOpen(false);\n    int delCount = info.getDelCount();\n\n    final ReadersAndLiveDocs rld = readerPool.get(info, false);\n    if (rld != null) {\n      delCount += rld.pendingDeleteCount;\n    }\n    return delCount;\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    ensureOpen(false);\n    SegmentReader reader = readerPool.getIfExists(info);\n    try {\n      if (reader != null) {\n        // the pulled reader could be from an in-flight merge \n        // while the info we see has already new applied deletes after a commit\n        // we max out the deletes since deletes never shrink\n        return Math.max(info.getDelCount(), reader.numDeletedDocs());\n      } else {\n        return info.getDelCount();\n      }\n    } finally {\n      if (reader != null) {\n        readerPool.release(reader, false);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#numDeletedDocs(SegmentInfo).mjava","sourceNew":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    ensureOpen(false);\n    int delCount = info.getDelCount();\n\n    final ReadersAndLiveDocs rld = readerPool.get(info, false);\n    if (rld != null) {\n      delCount += rld.pendingDeleteCount;\n    }\n    return delCount;\n  }\n\n","sourceOld":"  /**\n   * Obtain the number of deleted docs for a pooled reader.\n   * If the reader isn't being pooled, the segmentInfo's \n   * delCount is returned.\n   */\n  public int numDeletedDocs(SegmentInfo info) throws IOException {\n    ensureOpen(false);\n    int delCount = info.getDelCount();\n\n    final ReadersAndLiveDocs rld = readerPool.get(info, false);\n    if (rld != null) {\n      delCount += rld.pendingDeleteCount;\n    }\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0ddeeafb97cacc0f0e449e34a246cb6dda2c712b":["a688e33119c8fbce2e40e40ef1215dc501e43d2e"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","9454a6510e2db155fb01faa5c049b06ece95fab9"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a688e33119c8fbce2e40e40ef1215dc501e43d2e":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5"],"a6adfdb3f33dbaf27203539f573faac3966cc55f":["0ddeeafb97cacc0f0e449e34a246cb6dda2c712b"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["a6adfdb3f33dbaf27203539f573faac3966cc55f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0ddeeafb97cacc0f0e449e34a246cb6dda2c712b":["a6adfdb3f33dbaf27203539f573faac3966cc55f"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["a688e33119c8fbce2e40e40ef1215dc501e43d2e"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a688e33119c8fbce2e40e40ef1215dc501e43d2e":["0ddeeafb97cacc0f0e449e34a246cb6dda2c712b"],"a6adfdb3f33dbaf27203539f573faac3966cc55f":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}