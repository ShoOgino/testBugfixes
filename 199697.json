{"path":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","sourceNew":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    int author = 1;\n\n    // getParent() and getSize() test:\n    try {\n      tr.getParent(author);\n      fail(\"Initially, getParent for \"+author+\" should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tr.refresh(); // this is not enough, because tw.commit() hasn't been done yet\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    try {\n      tr.getParent(author);\n      fail(\"Before refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tr.refresh();\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    tr.refresh();\n    assertEquals(author, tr.getParent(dawkins));\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(TaxonomyReader.ROOT_ORDINAL));\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    int author = 1;\n\n    // getParent() and getSize() test:\n    try {\n      tr.getParent(author);\n      fail(\"Initially, getParent for \"+author+\" should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tr.refresh(); // this is not enough, because tw.commit() hasn't been done yet\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    try {\n      tr.getParent(author);\n      fail(\"Before refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tr.refresh();\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    tr.refresh();\n    assertEquals(author, tr.getParent(dawkins));\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(TaxonomyReader.ROOT_ORDINAL));\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1","date":1353511594,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","sourceNew":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    int author = 1;\n\n    // getParent() and getSize() test:\n    try {\n      tr.getParent(author);\n      fail(\"Initially, getParent for \"+author+\" should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    try {\n      tr.getParent(author);\n      fail(\"Before refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    \n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    assertEquals(author, tr.getParent(dawkins));\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(TaxonomyReader.ROOT_ORDINAL));\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    int author = 1;\n\n    // getParent() and getSize() test:\n    try {\n      tr.getParent(author);\n      fail(\"Initially, getParent for \"+author+\" should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tr.refresh(); // this is not enough, because tw.commit() hasn't been done yet\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    try {\n      tr.getParent(author);\n      fail(\"Before refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tr.refresh();\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    tr.refresh();\n    assertEquals(author, tr.getParent(dawkins));\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(TaxonomyReader.ROOT_ORDINAL));\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","sourceNew":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    int author = 1;\n\n    // getParent() and getSize() test:\n    try {\n      tr.getParent(author);\n      fail(\"Initially, getParent for \"+author+\" should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    try {\n      tr.getParent(author);\n      fail(\"Before refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    \n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    assertEquals(author, tr.getParent(dawkins));\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(TaxonomyReader.ROOT_ORDINAL));\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    int author = 1;\n\n    // getParent() and getSize() test:\n    try {\n      tr.getParent(author);\n      fail(\"Initially, getParent for \"+author+\" should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tr.refresh(); // this is not enough, because tw.commit() hasn't been done yet\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    try {\n      tr.getParent(author);\n      fail(\"Before refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tr.refresh();\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    tr.refresh();\n    assertEquals(author, tr.getParent(dawkins));\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(TaxonomyReader.ROOT_ORDINAL));\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29e1a91414f603bce5a59a5cb61fa8603997de87","date":1363597288,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","sourceNew":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    assertEquals(1, tr.getSize()); // still root only...\n    assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    assertEquals(1, tr.getSize()); // still root only...\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    \n    int author = 1;\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParallelTaxonomyArrays().parents()[author]);\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(author, parents[dawkins]);\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, parents[author]);\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[TaxonomyReader.ROOT_ORDINAL]);\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    int author = 1;\n\n    // getParent() and getSize() test:\n    try {\n      tr.getParent(author);\n      fail(\"Initially, getParent for \"+author+\" should throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet\n    try {\n      tr.getParent(author);\n      fail(\"Before commit() and refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    try {\n      tr.getParent(author);\n      fail(\"Before refresh(), getParent for \"+author+\" should still throw exception\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      // ok\n    }\n    assertEquals(1, tr.getSize()); // still root only...\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    \n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    assertEquals(author, tr.getParent(dawkins));\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParent(author));\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParent(TaxonomyReader.ROOT_ORDINAL));\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","sourceNew":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new FacetLabel(\"Author\"));\n    assertEquals(1, tr.getSize()); // still root only...\n    assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    assertEquals(1, tr.getSize()); // still root only...\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    \n    int author = 1;\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParallelTaxonomyArrays().parents()[author]);\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new FacetLabel(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(author, parents[dawkins]);\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, parents[author]);\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[TaxonomyReader.ROOT_ORDINAL]);\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    assertEquals(1, tr.getSize()); // still root only...\n    assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    assertEquals(1, tr.getSize()); // still root only...\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    \n    int author = 1;\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParallelTaxonomyArrays().parents()[author]);\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(author, parents[dawkins]);\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, parents[author]);\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[TaxonomyReader.ROOT_ORDINAL]);\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined#testSeparateReaderAndWriter().mjava","sourceNew":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new FacetLabel(\"Author\"));\n    assertEquals(1, tr.getSize()); // still root only...\n    assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    assertEquals(1, tr.getSize()); // still root only...\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    \n    int author = 1;\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParallelTaxonomyArrays().parents()[author]);\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new FacetLabel(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(author, parents[dawkins]);\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, parents[author]);\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[TaxonomyReader.ROOT_ORDINAL]);\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","sourceOld":"  /**  Test that if separate reader and writer objects are opened, new\n    categories written into the writer are available to a reader only\n    after a commit().\n    Note that this test obviously doesn't cover all the different\n    concurrency scenarios, all different methods, and so on. We may\n    want to write more tests of this sort.\n\n    This test simulates what would happen when there are two separate\n    processes, one doing indexing, and the other searching, and each opens\n    its own object (with obviously no connection between the objects) using\n    the same disk files. Note, though, that this test does not test what\n    happens when the two processes do their actual work at exactly the same\n    time.\n    It also doesn't test multi-threading.\n   */\n  @Test\n  public void testSeparateReaderAndWriter() throws Exception {\n    Directory indexDir = newDirectory();\n    TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);\n    tw.commit();\n    TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);\n\n    assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)\n    tw.addCategory(new CategoryPath(\"Author\"));\n    assertEquals(1, tr.getSize()); // still root only...\n    assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet\n    assertEquals(1, tr.getSize()); // still root only...\n    tw.commit();\n    assertEquals(1, tr.getSize()); // still root only...\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    \n    int author = 1;\n    try {\n      assertEquals(TaxonomyReader.ROOT_ORDINAL, tr.getParallelTaxonomyArrays().parents()[author]);\n      // ok\n    } catch (ArrayIndexOutOfBoundsException e) {\n      fail(\"After category addition, commit() and refresh(), getParent for \"+author+\" should NOT throw exception\");\n    }\n    assertEquals(2, tr.getSize()); // finally, see there are two categories\n\n    // now, add another category, and verify that after commit and refresh\n    // the parent of this category is correct (this requires the reader\n    // to correctly update its prefetched parent vector), and that the\n    // old information also wasn't ruined:\n    tw.addCategory(new CategoryPath(\"Author\", \"Richard Dawkins\"));\n    int dawkins = 2;\n    tw.commit();\n    newTaxoReader = TaxonomyReader.openIfChanged(tr);\n    assertNotNull(newTaxoReader);\n    tr.close();\n    tr = newTaxoReader;\n    int[] parents = tr.getParallelTaxonomyArrays().parents();\n    assertEquals(author, parents[dawkins]);\n    assertEquals(TaxonomyReader.ROOT_ORDINAL, parents[author]);\n    assertEquals(TaxonomyReader.INVALID_ORDINAL, parents[TaxonomyReader.ROOT_ORDINAL]);\n    assertEquals(3, tr.getSize()); \n    tw.close();\n    tr.close();\n    indexDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["b89678825b68eccaf09e6ab71675fc0b0af1e099","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"29e1a91414f603bce5a59a5cb61fa8603997de87":["219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["29e1a91414f603bce5a59a5cb61fa8603997de87","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["29e1a91414f603bce5a59a5cb61fa8603997de87"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["407687e67faf6e1f02a211ca078d8e3eed631027","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"29e1a91414f603bce5a59a5cb61fa8603997de87":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["407687e67faf6e1f02a211ca078d8e3eed631027","29e1a91414f603bce5a59a5cb61fa8603997de87"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}