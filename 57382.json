{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean).mjava","commits":[{"id":"1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7","date":1393724838,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, its also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, its ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix) {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    \n    if (doPrefix) {\n      for (int i = length - 1; i >= 0; i--) {\n        IntsRef prefixes = dictionary.lookupPrefix(word, 0, i);\n        if (prefixes == null) {\n          continue;\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            compatible = true;\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            compatible = hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            dictionary.stripLookup.get(stripOrd, scratch);\n            String strippedWord = new StringBuilder().append(scratch.utf8ToString())\n                .append(word, deAffixedStart, deAffixedLength)\n                .toString();\n            \n            List<CharsRef> stemList = applyAffix(strippedWord.toCharArray(), strippedWord.length(), prefix, -1, recursionDepth, true);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix) {\n      for (int i = 0; i < length; i++) {\n        IntsRef suffixes = dictionary.lookupSuffix(word, i, length - i);\n        if (suffixes == null) {\n          continue;\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            compatible = true;\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            compatible = hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            // TODO: can we do this in-place?\n            dictionary.stripLookup.get(stripOrd, scratch);\n            String strippedWord = new StringBuilder().append(word, 0, deAffixedLength).append(scratch.utf8ToString()).toString();\n            \n            List<CharsRef> stemList = applyAffix(strippedWord.toCharArray(), strippedWord.length(), suffix, prefixFlag, recursionDepth, false);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e7d0aeceab994177a0a6b52f475611b52f09bf","date":1393856424,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int,int,int,int,int,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, its also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, its ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @param circumfix true if the previous prefix removal was signed as a circumfix\n   *        this means inner most suffix must also contain circumfix flag.\n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix, boolean circumfix) {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    \n    if (doPrefix) {\n      for (int i = length - 1; i >= 0; i--) {\n        IntsRef prefixes = dictionary.lookupPrefix(word, 0, i);\n        if (prefixes == null) {\n          continue;\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            compatible = true;\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            compatible = hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            dictionary.stripLookup.get(stripOrd, scratch);\n            String strippedWord = new StringBuilder().append(scratch.utf8ToString())\n                .append(word, deAffixedStart, deAffixedLength)\n                .toString();\n            \n            List<CharsRef> stemList = applyAffix(strippedWord.toCharArray(), strippedWord.length(), prefix, -1, recursionDepth, true, circumfix);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix) {\n      for (int i = 0; i < length; i++) {\n        IntsRef suffixes = dictionary.lookupSuffix(word, i, length - i);\n        if (suffixes == null) {\n          continue;\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            compatible = true;\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            compatible = hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            // TODO: can we do this in-place?\n            dictionary.stripLookup.get(stripOrd, scratch);\n            String strippedWord = new StringBuilder().append(word, 0, deAffixedLength).append(scratch.utf8ToString()).toString();\n            \n            List<CharsRef> stemList = applyAffix(strippedWord.toCharArray(), strippedWord.length(), suffix, prefixFlag, recursionDepth, false, circumfix);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Generates a list of stems for the provided word\n   *\n   * @param word Word to generate the stems for\n   * @param previous previous affix that was removed (so we dont remove same one twice)\n   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any affixes in this recursive step\n   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, its also checked against the word\n   * @param recursionDepth current recursiondepth\n   * @param doPrefix true if we should remove prefixes\n   * @param doSuffix true if we should remove suffixes\n   * @param previousWasPrefix true if the previous removal was a prefix:\n   *        if we are removing a suffix, and it has no continuation requirements, its ok.\n   *        but two prefixes (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse. \n   * @return List of stems, or empty list if no stems are found\n   */\n  private List<CharsRef> stem(char word[], int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, boolean doPrefix, boolean doSuffix, boolean previousWasPrefix) {\n    \n    // TODO: allow this stuff to be reused by tokenfilter\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    \n    if (doPrefix) {\n      for (int i = length - 1; i >= 0; i--) {\n        IntsRef prefixes = dictionary.lookupPrefix(word, 0, i);\n        if (prefixes == null) {\n          continue;\n        }\n        \n        for (int j = 0; j < prefixes.length; j++) {\n          int prefix = prefixes.ints[prefixes.offset + j];\n          if (prefix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * prefix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            compatible = true;\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            compatible = hasCrossCheckedFlag((char)prevFlag, appendFlags, false);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int deAffixedStart = i;\n            int deAffixedLength = length - deAffixedStart;\n            \n            dictionary.stripLookup.get(stripOrd, scratch);\n            String strippedWord = new StringBuilder().append(scratch.utf8ToString())\n                .append(word, deAffixedStart, deAffixedLength)\n                .toString();\n            \n            List<CharsRef> stemList = applyAffix(strippedWord.toCharArray(), strippedWord.length(), prefix, -1, recursionDepth, true);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    } \n    \n    if (doSuffix) {\n      for (int i = 0; i < length; i++) {\n        IntsRef suffixes = dictionary.lookupSuffix(word, i, length - i);\n        if (suffixes == null) {\n          continue;\n        }\n        \n        for (int j = 0; j < suffixes.length; j++) {\n          int suffix = suffixes.ints[suffixes.offset + j];\n          if (suffix == previous) {\n            continue;\n          }\n          affixReader.setPosition(8 * suffix);\n          char flag = (char) (affixReader.readShort() & 0xffff);\n          char stripOrd = (char) (affixReader.readShort() & 0xffff);\n          int condition = (char) (affixReader.readShort() & 0xffff);\n          boolean crossProduct = (condition & 1) == 1;\n          condition >>>= 1;\n          char append = (char) (affixReader.readShort() & 0xffff);\n          \n          final boolean compatible;\n          if (recursionDepth == 0) {\n            compatible = true;\n          } else if (crossProduct) {\n            // cross check incoming continuation class (flag of previous affix) against list.\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            assert prevFlag >= 0;\n            compatible = hasCrossCheckedFlag((char)prevFlag, appendFlags, previousWasPrefix);\n          } else {\n            compatible = false;\n          }\n          \n          if (compatible) {\n            int appendLength = length - i;\n            int deAffixedLength = length - appendLength;\n            // TODO: can we do this in-place?\n            dictionary.stripLookup.get(stripOrd, scratch);\n            String strippedWord = new StringBuilder().append(word, 0, deAffixedLength).append(scratch.utf8ToString()).toString();\n            \n            List<CharsRef> stemList = applyAffix(strippedWord.toCharArray(), strippedWord.length(), suffix, prefixFlag, recursionDepth, false);\n            \n            stems.addAll(stemList);\n          }\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":["23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"38e7d0aeceab994177a0a6b52f475611b52f09bf":["1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7"],"1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["38e7d0aeceab994177a0a6b52f475611b52f09bf"]},"commit2Childs":{"38e7d0aeceab994177a0a6b52f475611b52f09bf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7":["38e7d0aeceab994177a0a6b52f475611b52f09bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}