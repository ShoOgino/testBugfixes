{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","sourceNew":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  public synchronized void waitForMerges() {\n    ensureOpen(false);\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"waitForMerges\");\n    }\n    while(pendingMerges.size() > 0 || runningMerges.size() > 0) {\n      doWait();\n    }\n\n    // sanity check\n    assert 0 == mergingSegments.size();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"waitForMerges done\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  public synchronized void waitForMerges() {\n    ensureOpen(false);\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"waitForMerges\");\n    }\n    while(pendingMerges.size() > 0 || runningMerges.size() > 0) {\n      doWait();\n    }\n\n    // sanity check\n    assert 0 == mergingSegments.size();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"waitForMerges done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a64ffebe62143a8d4c37d99b6ece6d430d948ebc","date":1408382164,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","sourceNew":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  public void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  public synchronized void waitForMerges() {\n    ensureOpen(false);\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"waitForMerges\");\n    }\n    while(pendingMerges.size() > 0 || runningMerges.size() > 0) {\n      doWait();\n    }\n\n    // sanity check\n    assert 0 == mergingSegments.size();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"waitForMerges done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15fbe8579d34349a8c79cbc5c933530dd5b6742a","date":1418066328,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","sourceNew":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  public void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","bugFix":["a64ffebe62143a8d4c37d99b6ece6d430d948ebc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9e22bdf0692bfa61e342b04a6ac7078670c1e16","date":1436866730,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","sourceNew":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2178aefcd4690bd53785e9673e2c918cdb64165","date":1587583605,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","sourceNew":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(this, MergeTrigger.CLOSING);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(this, MergeTrigger.CLOSING, false);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89697e7abc9807639c384eecf5a2a6eef1080426","date":1587733375,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#waitForMerges().mjava","sourceNew":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(mergeSource, MergeTrigger.CLOSING);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Wait for any currently outstanding merges to finish.\n   *\n   * <p>It is guaranteed that any merges started prior to calling this method\n   *    will have completed once this method completes.</p>\n   */\n  void waitForMerges() throws IOException {\n\n    // Give merge scheduler last chance to run, in case\n    // any pending merges are waiting. We can't hold IW's lock\n    // when going into merge because it can lead to deadlock.\n    mergeScheduler.merge(this, MergeTrigger.CLOSING);\n\n    synchronized (this) {\n      ensureOpen(false);\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges\");\n      }\n\n      while (pendingMerges.size() > 0 || runningMerges.size() > 0) {\n        doWait();\n      }\n\n      // sanity check\n      assert 0 == mergingSegments.size();\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"waitForMerges done\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"89697e7abc9807639c384eecf5a2a6eef1080426":["d2178aefcd4690bd53785e9673e2c918cdb64165"],"d2178aefcd4690bd53785e9673e2c918cdb64165":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a64ffebe62143a8d4c37d99b6ece6d430d948ebc":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"15fbe8579d34349a8c79cbc5c933530dd5b6742a":["a64ffebe62143a8d4c37d99b6ece6d430d948ebc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["89697e7abc9807639c384eecf5a2a6eef1080426"]},"commit2Childs":{"89697e7abc9807639c384eecf5a2a6eef1080426":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d2178aefcd4690bd53785e9673e2c918cdb64165":["89697e7abc9807639c384eecf5a2a6eef1080426"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["d2178aefcd4690bd53785e9673e2c918cdb64165"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a64ffebe62143a8d4c37d99b6ece6d430d948ebc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a64ffebe62143a8d4c37d99b6ece6d430d948ebc":["15fbe8579d34349a8c79cbc5c933530dd5b6742a"],"15fbe8579d34349a8c79cbc5c933530dd5b6742a":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}