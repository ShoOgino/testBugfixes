{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","commits":[{"id":"8ec805ca8fedc0166461148c7182f1bcbbd18ee1","date":1489767223,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"/dev/null","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = (List)fcontext.facetInfo.get(\"_l\");\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(leaves.size());\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    FieldType ft = sf.getType();\n    for (Object bucketVal : leaves) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucketList.add(bucket);\n      bucket.add(\"val\", bucketVal);\n\n      // String internal = ft.toInternal( tobj.toString() );  // TODO - we need a better way to get from object to query...\n\n      Query domainQ = ft.getFieldQuery(null, sf, bucketVal.toString());\n\n      fillBucket(bucket, domainQ, null, false);\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58b93c361b4f6fe193e84bfd27ea523366eada52","date":1490100167,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\"));\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = (List)fcontext.facetInfo.get(\"_l\");\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(leaves.size());\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    FieldType ft = sf.getType();\n    for (Object bucketVal : leaves) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucketList.add(bucket);\n      bucket.add(\"val\", bucketVal);\n\n      // String internal = ft.toInternal( tobj.toString() );  // TODO - we need a better way to get from object to query...\n\n      Query domainQ = ft.getFieldQuery(null, sf, bucketVal.toString());\n\n      fillBucket(bucket, domainQ, null, false);\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6988da66623294290c462497023bea04c868b48","date":1490226830,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\"));\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d521256ce8fafb493c52a0492eba155bb8accd6e","date":1490229097,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\"));\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11ab475c994c79138885cc8a30b2641d929cdc43","date":1490280010,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"/dev/null","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = (List)fcontext.facetInfo.get(\"_l\");\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(leaves.size());\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    FieldType ft = sf.getType();\n    for (Object bucketVal : leaves) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucketList.add(bucket);\n      bucket.add(\"val\", bucketVal);\n\n      // String internal = ft.toInternal( tobj.toString() );  // TODO - we need a better way to get from object to query...\n\n      Query domainQ = ft.getFieldQuery(null, sf, bucketVal.toString());\n\n      fillBucket(bucket, domainQ, null, false);\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8908009aaa8e9318b455c1c22b83e0e87738228a","date":1490280013,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\"));\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = (List)fcontext.facetInfo.get(\"_l\");\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(leaves.size());\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    FieldType ft = sf.getType();\n    for (Object bucketVal : leaves) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucketList.add(bucket);\n      bucket.add(\"val\", bucketVal);\n\n      // String internal = ft.toInternal( tobj.toString() );  // TODO - we need a better way to get from object to query...\n\n      Query domainQ = ft.getFieldQuery(null, sf, bucketVal.toString());\n\n      fillBucket(bucket, domainQ, null, false);\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a96802490db67d4c9ab246b020af9ab07efb2207","date":1490280013,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\"));\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cb287e8b4595ddf413c318d5631789c8c8e8719","date":1490402624,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : missing) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52dc05802ffecefaecf5879a40a61539b5c985f0","date":1490594650,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : missing) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85d473096f870b9bf3e231200a07e8eefa30eef8","date":1490745171,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : missing) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5","date":1490873946,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> missing = asList(fcontext.facetInfo.get(\"_m\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + missing.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : missing) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd","date":1490979270,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14abccfea62dff435ac0457e128ca6bc703087d6","date":1491045405,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84e83c6774414730d58276083becadc66f4e4aca","date":1493132430,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n\n    if (freq.numBuckets && !skipThisFacet) {\n      calculateNumBuckets(res);\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n\n    if (freq.numBuckets && !skipThisFacet) {\n      calculateNumBuckets(res);\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#refineFacets().mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n\n    if (freq.numBuckets && !skipThisFacet) {\n      calculateNumBuckets(res);\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","sourceOld":"  protected SimpleOrderedMap<Object> refineFacets() throws IOException {\n    boolean skipThisFacet = (fcontext.flags & SKIP_FACET) != 0;\n\n\n    List leaves = asList(fcontext.facetInfo.get(\"_l\"));        // We have not seen this bucket: do full faceting for this bucket, including all sub-facets\n    List<List> skip = asList(fcontext.facetInfo.get(\"_s\"));    // We have seen this bucket, so skip stats on it, and skip sub-facets except for the specified sub-facets that should calculate specified buckets.\n    List<List> partial = asList(fcontext.facetInfo.get(\"_p\")); // We have not seen this bucket, do full faceting for this bucket, and most sub-facets... but some sub-facets are partial and should only visit specified buckets.\n\n    // For leaf refinements, we do full faceting for each leaf bucket.  Any sub-facets of these buckets will be fully evaluated.  Because of this, we should never\n    // encounter leaf refinements that have sub-facets that return partial results.\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> bucketList = new ArrayList<>( leaves.size() + skip.size() + partial.size() );\n    res.add(\"buckets\", bucketList);\n\n    // TODO: an alternate implementations can fill all accs at once\n    createAccs(-1, 1);\n\n    for (Object bucketVal : leaves) {\n      bucketList.add( refineBucket(bucketVal, false, null) );\n    }\n\n    for (List bucketAndFacetInfo : skip) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, true, facetInfo ) );\n    }\n\n    // The only difference between skip and missing is the value of \"skip\" passed to refineBucket\n    for (List bucketAndFacetInfo : partial) {\n      assert bucketAndFacetInfo.size() == 2;\n      Object bucketVal = bucketAndFacetInfo.get(0);\n      Map<String,Object> facetInfo = (Map<String, Object>) bucketAndFacetInfo.get(1);\n\n      bucketList.add( refineBucket(bucketVal, false, facetInfo ) );\n    }\n\n    if (freq.missing) {\n      Map<String,Object> bucketFacetInfo = (Map<String,Object>)fcontext.facetInfo.get(\"missing\");\n\n      if (bucketFacetInfo != null || !skipThisFacet) {\n        SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n        fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, skipThisFacet, bucketFacetInfo);\n        res.add(\"missing\", missingBucket);\n      }\n    }\n\n    if (freq.numBuckets && !skipThisFacet) {\n      calculateNumBuckets(res);\n    }\n\n    // If there are just a couple of leaves, and if the domain is large, then\n    // going by term is likely the most efficient?\n    // If the domain is small, or if the number of leaves is large, then doing\n    // the normal collection method may be best.\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"58b93c361b4f6fe193e84bfd27ea523366eada52":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"d521256ce8fafb493c52a0492eba155bb8accd6e":["58b93c361b4f6fe193e84bfd27ea523366eada52","e6988da66623294290c462497023bea04c868b48"],"a96802490db67d4c9ab246b020af9ab07efb2207":["8908009aaa8e9318b455c1c22b83e0e87738228a"],"14abccfea62dff435ac0457e128ca6bc703087d6":["c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5"],"84e83c6774414730d58276083becadc66f4e4aca":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd":["85d473096f870b9bf3e231200a07e8eefa30eef8"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e6988da66623294290c462497023bea04c868b48":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["11ab475c994c79138885cc8a30b2641d929cdc43"],"85d473096f870b9bf3e231200a07e8eefa30eef8":["4cb287e8b4595ddf413c318d5631789c8c8e8719"],"4cb287e8b4595ddf413c318d5631789c8c8e8719":["d521256ce8fafb493c52a0492eba155bb8accd6e"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["14abccfea62dff435ac0457e128ca6bc703087d6","84e83c6774414730d58276083becadc66f4e4aca"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["84e83c6774414730d58276083becadc66f4e4aca"],"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5":["52dc05802ffecefaecf5879a40a61539b5c985f0"],"11ab475c994c79138885cc8a30b2641d929cdc43":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"52dc05802ffecefaecf5879a40a61539b5c985f0":["a96802490db67d4c9ab246b020af9ab07efb2207"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"]},"commit2Childs":{"58b93c361b4f6fe193e84bfd27ea523366eada52":["d521256ce8fafb493c52a0492eba155bb8accd6e","e6988da66623294290c462497023bea04c868b48"],"d521256ce8fafb493c52a0492eba155bb8accd6e":["4cb287e8b4595ddf413c318d5631789c8c8e8719"],"a96802490db67d4c9ab246b020af9ab07efb2207":["52dc05802ffecefaecf5879a40a61539b5c985f0"],"14abccfea62dff435ac0457e128ca6bc703087d6":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"84e83c6774414730d58276083becadc66f4e4aca":["e9017cf144952056066919f1ebc7897ff9bd71b1","a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd":["84e83c6774414730d58276083becadc66f4e4aca"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"e6988da66623294290c462497023bea04c868b48":["d521256ce8fafb493c52a0492eba155bb8accd6e"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["a96802490db67d4c9ab246b020af9ab07efb2207"],"85d473096f870b9bf3e231200a07e8eefa30eef8":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"4cb287e8b4595ddf413c318d5631789c8c8e8719":["85d473096f870b9bf3e231200a07e8eefa30eef8"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5":["14abccfea62dff435ac0457e128ca6bc703087d6"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"11ab475c994c79138885cc8a30b2641d929cdc43":["8908009aaa8e9318b455c1c22b83e0e87738228a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1","11ab475c994c79138885cc8a30b2641d929cdc43"],"52dc05802ffecefaecf5879a40a61539b5c985f0":["c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}