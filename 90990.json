{"path":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String codec = initArgs.get(\"codec\");\n    if (codec != null) {\n      this.codec = codec;\n      initArgs.remove(\"codec\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String codec = initArgs.get(\"codec\");\n    if (codec != null) {\n      this.codec = codec;\n      initArgs.remove(\"codec\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String codec = initArgs.get(\"codec\");\n    if (codec != null) {\n      this.codec = codec;\n      initArgs.remove(\"codec\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String codec = initArgs.get(\"codec\");\n    if (codec != null) {\n      this.codec = codec;\n      initArgs.remove(\"codec\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String codec = initArgs.get(\"codec\");\n    if (codec != null) {\n      this.codec = codec;\n      initArgs.remove(\"codec\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String codec = initArgs.get(\"codec\");\n    if (codec != null) {\n      this.codec = codec;\n      initArgs.remove(\"codec\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String postingsFormat = initArgs.get(\"postingsFormat\");\n    if (postingsFormat != null) {\n      this.postingsFormat = postingsFormat;\n      initArgs.remove(\"postingsFormat\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String codec = initArgs.get(\"codec\");\n    if (codec != null) {\n      this.codec = codec;\n      initArgs.remove(\"codec\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73bb5a57dc75b54a39494f99986599cae7dff417","date":1361040620,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    this.postingsFormat = initArgs.remove(\"postingsFormat\");\n    this.docValuesFormat = initArgs.remove(\"docValuesFormat\");\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String postingsFormat = initArgs.get(\"postingsFormat\");\n    if (postingsFormat != null) {\n      this.postingsFormat = postingsFormat;\n      initArgs.remove(\"postingsFormat\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    this.postingsFormat = initArgs.remove(\"postingsFormat\");\n    this.docValuesFormat = initArgs.remove(\"docValuesFormat\");\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    final String postingsFormat = initArgs.get(\"postingsFormat\");\n    if (postingsFormat != null) {\n      this.postingsFormat = postingsFormat;\n      initArgs.remove(\"postingsFormat\");\n    }\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c262af1d2eb95e4ff81c2d68fbae8404ed88eae","date":1362126760,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    this.postingsFormat = initArgs.remove(\"postingsFormat\");\n    this.docValuesFormat = initArgs.remove(\"docValuesFormat\");\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    this.postingsFormat = initArgs.remove(\"postingsFormat\");\n    this.docValuesFormat = initArgs.remove(\"docValuesFormat\");\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","date":1362545433,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args=args;\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(\"positionIncrementGap\");\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set positionIncrementGap on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(\"positionIncrementGap\");\n    }\n\n    this.postingsFormat = initArgs.remove(\"postingsFormat\");\n    this.docValuesFormat = initArgs.remove(\"docValuesFormat\");\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e61f8b6e1b607d67d9e0f477d711a92a0dfcde3","date":1364572018,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true);\n    falseProperties = FieldProperties.parseProperties(initArgs,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b4b4d68085809ae840a099e4620e5a128509279","date":1365633379,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<String,String>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"123698fbe83b595f9e084f0019cd35ab4a01d7f7","date":1399070065,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getIndexAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bdac0dff04219451c7511d62225080a93a0181ea","date":1451212020,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n    if (schemaVersion >= 1.6f) properties |= USE_DOCVALUES_AS_STORED;\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getIndexAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getIndexAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e","date":1541777404,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n    if (schemaVersion >= 1.6f) properties |= USE_DOCVALUES_AS_STORED;\n    \n    properties |= UNINVERTIBLE;\n    \n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getIndexAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n    if (schemaVersion >= 1.6f) properties |= USE_DOCVALUES_AS_STORED;\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getIndexAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da0c9170fd1c418b47b9a76a0447c60b1b99e5f","date":1548699906,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#setArgs(IndexSchema,Map[String,String]).mjava","sourceNew":"  /**\n   * Initializes the field type.  Subclasses should usually override {@link #init(IndexSchema, Map)}\n   * which is called by this method.\n   */\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n    if (schemaVersion >= 1.6f) properties |= USE_DOCVALUES_AS_STORED;\n    \n    properties |= UNINVERTIBLE;\n    \n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getIndexAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","sourceOld":"  // Handle additional arguments...\n  protected void setArgs(IndexSchema schema, Map<String,String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n    if (schemaVersion >= 1.6f) properties |= USE_DOCVALUES_AS_STORED;\n    \n    properties |= UNINVERTIBLE;\n    \n    this.args = Collections.unmodifiableMap(args);\n    Map<String,String> initArgs = new HashMap<>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg \n\n    trueProperties = FieldProperties.parseProperties(initArgs,true,false);\n    falseProperties = FieldProperties.parseProperties(initArgs,false,false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getIndexAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer)analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\"schema fieldtype \" + typeName\n              + \"(\"+ this.getClass().getName() + \")\"\n              + \" invalid arguments:\" + initArgs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8da0c9170fd1c418b47b9a76a0447c60b1b99e5f":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9b4b4d68085809ae840a099e4620e5a128509279"],"1c262af1d2eb95e4ff81c2d68fbae8404ed88eae":["73bb5a57dc75b54a39494f99986599cae7dff417"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"9b4b4d68085809ae840a099e4620e5a128509279":["6e61f8b6e1b607d67d9e0f477d711a92a0dfcde3"],"bdac0dff04219451c7511d62225080a93a0181ea":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["bdac0dff04219451c7511d62225080a93a0181ea"],"6e61f8b6e1b607d67d9e0f477d711a92a0dfcde3":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"7b91922b55d15444d554721b352861d028eb8278":["c26f00b574427b55127e869b935845554afde1fa"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["7b91922b55d15444d554721b352861d028eb8278","73bb5a57dc75b54a39494f99986599cae7dff417"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["1c262af1d2eb95e4ff81c2d68fbae8404ed88eae"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8da0c9170fd1c418b47b9a76a0447c60b1b99e5f"],"73bb5a57dc75b54a39494f99986599cae7dff417":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"8da0c9170fd1c418b47b9a76a0447c60b1b99e5f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"1c262af1d2eb95e4ff81c2d68fbae8404ed88eae":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"c26f00b574427b55127e869b935845554afde1fa":["7b91922b55d15444d554721b352861d028eb8278"],"9b4b4d68085809ae840a099e4620e5a128509279":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"bdac0dff04219451c7511d62225080a93a0181ea":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["8da0c9170fd1c418b47b9a76a0447c60b1b99e5f"],"6e61f8b6e1b607d67d9e0f477d711a92a0dfcde3":["9b4b4d68085809ae840a099e4620e5a128509279"],"7b91922b55d15444d554721b352861d028eb8278":["95303ff3749680c743b9425f9cf99e6e4065e8a8","73bb5a57dc75b54a39494f99986599cae7dff417"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["bdac0dff04219451c7511d62225080a93a0181ea"],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["6e61f8b6e1b607d67d9e0f477d711a92a0dfcde3"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"73bb5a57dc75b54a39494f99986599cae7dff417":["1c262af1d2eb95e4ff81c2d68fbae8404ed88eae","95303ff3749680c743b9425f9cf99e6e4065e8a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["95303ff3749680c743b9425f9cf99e6e4065e8a8","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}