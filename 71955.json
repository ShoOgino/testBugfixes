{"path":"lucene/src/test/org/apache/lucene/index/TestIndexReader#assertIndexEquals(DirectoryReader,DirectoryReader).mjava","commits":[{"id":"d40b62adb64d8f7b2f85ee849349cfb0bef03f45","date":1327855938,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReader#assertIndexEquals(DirectoryReader,DirectoryReader).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReader#assertIndexEquals(IndexReader,IndexReader).mjava","sourceNew":"    // TODO: maybe this can reuse the logic of test dueling codecs?\n    public static void assertIndexEquals(DirectoryReader index1, DirectoryReader index2) throws IOException {\n      assertEquals(\"IndexReaders have different values for numDocs.\", index1.numDocs(), index2.numDocs());\n      assertEquals(\"IndexReaders have different values for maxDoc.\", index1.maxDoc(), index2.maxDoc());\n      assertEquals(\"Only one IndexReader has deletions.\", index1.hasDeletions(), index2.hasDeletions());\n      assertEquals(\"Single segment test differs.\", index1.getSequentialSubReaders().length == 1, index2.getSequentialSubReaders().length == 1);\n      \n      // check field names\n      FieldInfos fieldInfos1 = MultiFields.getMergedFieldInfos(index1);\n      FieldInfos fieldInfos2 = MultiFields.getMergedFieldInfos(index2);\n      assertEquals(\"IndexReaders have different numbers of fields.\", fieldInfos1.size(), fieldInfos2.size());\n      final int numFields = fieldInfos1.size();\n      for(int fieldID=0;fieldID<numFields;fieldID++) {\n        final FieldInfo fieldInfo1 = fieldInfos1.fieldInfo(fieldID);\n        final FieldInfo fieldInfo2 = fieldInfos2.fieldInfo(fieldID);\n        assertEquals(\"Different field names.\", fieldInfo1.name, fieldInfo2.name);\n      }\n      \n      // check norms\n      for(FieldInfo fieldInfo : fieldInfos1) {\n        String curField = fieldInfo.name;\n        DocValues norms1 = MultiDocValues.getNormDocValues(index1, curField);\n        DocValues norms2 = MultiDocValues.getNormDocValues(index2, curField);\n        if (norms1 != null && norms2 != null)\n        {\n          // todo: generalize this (like TestDuelingCodecs assert)\n          byte[] b1 = (byte[]) norms1.getSource().getArray();\n          byte[] b2 = (byte[]) norms2.getSource().getArray();\n          assertEquals(b1.length, b2.length);\n\t        for (int i = 0; i < b1.length; i++) {\n\t          assertEquals(\"Norm different for doc \" + i + \" and field '\" + curField + \"'.\", b1[i], b2[i]);\n\t        }\n        }\n        else\n        {\n          assertSame(norms1, norms2);\n        }\n      }\n      \n      // check deletions\n      final Bits liveDocs1 = MultiFields.getLiveDocs(index1);\n      final Bits liveDocs2 = MultiFields.getLiveDocs(index2);\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        assertEquals(\"Doc \" + i + \" only deleted in one index.\",\n                     liveDocs1 == null || !liveDocs1.get(i),\n                     liveDocs2 == null || !liveDocs2.get(i));\n      }\n      \n      // check stored fields\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        if (liveDocs1 == null || liveDocs1.get(i)) {\n          Document doc1 = index1.document(i);\n          Document doc2 = index2.document(i);\n          List<IndexableField> field1 = doc1.getFields();\n          List<IndexableField> field2 = doc2.getFields();\n          assertEquals(\"Different numbers of fields for doc \" + i + \".\", field1.size(), field2.size());\n          Iterator<IndexableField> itField1 = field1.iterator();\n          Iterator<IndexableField> itField2 = field2.iterator();\n          while (itField1.hasNext()) {\n            Field curField1 = (Field) itField1.next();\n            Field curField2 = (Field) itField2.next();\n            assertEquals(\"Different fields names for doc \" + i + \".\", curField1.name(), curField2.name());\n            assertEquals(\"Different field values for doc \" + i + \".\", curField1.stringValue(), curField2.stringValue());\n          }          \n        }\n      }\n      \n      // check dictionary and posting lists\n      FieldsEnum fenum1 = MultiFields.getFields(index1).iterator();\n      FieldsEnum fenum2 = MultiFields.getFields(index1).iterator();\n      String field1 = null;\n      Bits liveDocs = MultiFields.getLiveDocs(index1);\n      while((field1=fenum1.next()) != null) {\n        assertEquals(\"Different fields\", field1, fenum2.next());\n        Terms terms1 = fenum1.terms();\n        if (terms1 == null) {\n          assertNull(fenum2.terms());\n          continue;\n        }\n        TermsEnum enum1 = terms1.iterator(null);\n\n        Terms terms2 = fenum2.terms();\n        assertNotNull(terms2);\n        TermsEnum enum2 = terms2.iterator(null);\n\n        while(enum1.next() != null) {\n          assertEquals(\"Different terms\", enum1.term(), enum2.next());\n          DocsAndPositionsEnum tp1 = enum1.docsAndPositions(liveDocs, null, false);\n          DocsAndPositionsEnum tp2 = enum2.docsAndPositions(liveDocs, null, false);\n\n          while(tp1.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n            assertTrue(tp2.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n            assertEquals(\"Different doc id in postinglist of term \" + enum1.term() + \".\", tp1.docID(), tp2.docID());\n            assertEquals(\"Different term frequence in postinglist of term \" + enum1.term() + \".\", tp1.freq(), tp2.freq());\n            for (int i = 0; i < tp1.freq(); i++) {\n              assertEquals(\"Different positions in postinglist of term \" + enum1.term() + \".\", tp1.nextPosition(), tp2.nextPosition());\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    // TODO: maybe this can reuse the logic of test dueling codecs?\n    public static void assertIndexEquals(IndexReader index1, IndexReader index2) throws IOException {\n      assertEquals(\"IndexReaders have different values for numDocs.\", index1.numDocs(), index2.numDocs());\n      assertEquals(\"IndexReaders have different values for maxDoc.\", index1.maxDoc(), index2.maxDoc());\n      assertEquals(\"Only one IndexReader has deletions.\", index1.hasDeletions(), index2.hasDeletions());\n      if (!(index1 instanceof ParallelReader)) {\n        assertEquals(\"Single segment test differs.\", index1.getSequentialSubReaders().length == 1, index2.getSequentialSubReaders().length == 1);\n      }\n      \n      // check field names\n      FieldInfos fieldInfos1 = ReaderUtil.getMergedFieldInfos(index1);\n      FieldInfos fieldInfos2 = ReaderUtil.getMergedFieldInfos(index2);\n      assertEquals(\"IndexReaders have different numbers of fields.\", fieldInfos1.size(), fieldInfos2.size());\n      final int numFields = fieldInfos1.size();\n      for(int fieldID=0;fieldID<numFields;fieldID++) {\n        final FieldInfo fieldInfo1 = fieldInfos1.fieldInfo(fieldID);\n        final FieldInfo fieldInfo2 = fieldInfos2.fieldInfo(fieldID);\n        assertEquals(\"Different field names.\", fieldInfo1.name, fieldInfo2.name);\n      }\n      \n      // check norms\n      for(FieldInfo fieldInfo : fieldInfos1) {\n        String curField = fieldInfo.name;\n        DocValues norms1 = MultiDocValues.getNormDocValues(index1, curField);\n        DocValues norms2 = MultiDocValues.getNormDocValues(index2, curField);\n        if (norms1 != null && norms2 != null)\n        {\n          // todo: generalize this (like TestDuelingCodecs assert)\n          byte[] b1 = (byte[]) norms1.getSource().getArray();\n          byte[] b2 = (byte[]) norms2.getSource().getArray();\n          assertEquals(b1.length, b2.length);\n\t        for (int i = 0; i < b1.length; i++) {\n\t          assertEquals(\"Norm different for doc \" + i + \" and field '\" + curField + \"'.\", b1[i], b2[i]);\n\t        }\n        }\n        else\n        {\n          assertSame(norms1, norms2);\n        }\n      }\n      \n      // check deletions\n      final Bits liveDocs1 = MultiFields.getLiveDocs(index1);\n      final Bits liveDocs2 = MultiFields.getLiveDocs(index2);\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        assertEquals(\"Doc \" + i + \" only deleted in one index.\",\n                     liveDocs1 == null || !liveDocs1.get(i),\n                     liveDocs2 == null || !liveDocs2.get(i));\n      }\n      \n      // check stored fields\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        if (liveDocs1 == null || liveDocs1.get(i)) {\n          Document doc1 = index1.document(i);\n          Document doc2 = index2.document(i);\n          List<IndexableField> field1 = doc1.getFields();\n          List<IndexableField> field2 = doc2.getFields();\n          assertEquals(\"Different numbers of fields for doc \" + i + \".\", field1.size(), field2.size());\n          Iterator<IndexableField> itField1 = field1.iterator();\n          Iterator<IndexableField> itField2 = field2.iterator();\n          while (itField1.hasNext()) {\n            Field curField1 = (Field) itField1.next();\n            Field curField2 = (Field) itField2.next();\n            assertEquals(\"Different fields names for doc \" + i + \".\", curField1.name(), curField2.name());\n            assertEquals(\"Different field values for doc \" + i + \".\", curField1.stringValue(), curField2.stringValue());\n          }          \n        }\n      }\n      \n      // check dictionary and posting lists\n      FieldsEnum fenum1 = MultiFields.getFields(index1).iterator();\n      FieldsEnum fenum2 = MultiFields.getFields(index1).iterator();\n      String field1 = null;\n      Bits liveDocs = MultiFields.getLiveDocs(index1);\n      while((field1=fenum1.next()) != null) {\n        assertEquals(\"Different fields\", field1, fenum2.next());\n        Terms terms1 = fenum1.terms();\n        if (terms1 == null) {\n          assertNull(fenum2.terms());\n          continue;\n        }\n        TermsEnum enum1 = terms1.iterator(null);\n\n        Terms terms2 = fenum2.terms();\n        assertNotNull(terms2);\n        TermsEnum enum2 = terms2.iterator(null);\n\n        while(enum1.next() != null) {\n          assertEquals(\"Different terms\", enum1.term(), enum2.next());\n          DocsAndPositionsEnum tp1 = enum1.docsAndPositions(liveDocs, null, false);\n          DocsAndPositionsEnum tp2 = enum2.docsAndPositions(liveDocs, null, false);\n\n          while(tp1.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n            assertTrue(tp2.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n            assertEquals(\"Different doc id in postinglist of term \" + enum1.term() + \".\", tp1.docID(), tp2.docID());\n            assertEquals(\"Different term frequence in postinglist of term \" + enum1.term() + \".\", tp1.freq(), tp2.freq());\n            for (int i = 0; i < tp1.freq(); i++) {\n              assertEquals(\"Different positions in postinglist of term \" + enum1.term() + \".\", tp1.nextPosition(), tp2.nextPosition());\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":1,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexReader#assertIndexEquals(DirectoryReader,DirectoryReader).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReader#assertIndexEquals(IndexReader,IndexReader).mjava","sourceNew":"    // TODO: maybe this can reuse the logic of test dueling codecs?\n    public static void assertIndexEquals(DirectoryReader index1, DirectoryReader index2) throws IOException {\n      assertEquals(\"IndexReaders have different values for numDocs.\", index1.numDocs(), index2.numDocs());\n      assertEquals(\"IndexReaders have different values for maxDoc.\", index1.maxDoc(), index2.maxDoc());\n      assertEquals(\"Only one IndexReader has deletions.\", index1.hasDeletions(), index2.hasDeletions());\n      assertEquals(\"Single segment test differs.\", index1.getSequentialSubReaders().length == 1, index2.getSequentialSubReaders().length == 1);\n      \n      // check field names\n      FieldInfos fieldInfos1 = MultiFields.getMergedFieldInfos(index1);\n      FieldInfos fieldInfos2 = MultiFields.getMergedFieldInfos(index2);\n      assertEquals(\"IndexReaders have different numbers of fields.\", fieldInfos1.size(), fieldInfos2.size());\n      final int numFields = fieldInfos1.size();\n      for(int fieldID=0;fieldID<numFields;fieldID++) {\n        final FieldInfo fieldInfo1 = fieldInfos1.fieldInfo(fieldID);\n        final FieldInfo fieldInfo2 = fieldInfos2.fieldInfo(fieldID);\n        assertEquals(\"Different field names.\", fieldInfo1.name, fieldInfo2.name);\n      }\n      \n      // check norms\n      for(FieldInfo fieldInfo : fieldInfos1) {\n        String curField = fieldInfo.name;\n        DocValues norms1 = MultiDocValues.getNormDocValues(index1, curField);\n        DocValues norms2 = MultiDocValues.getNormDocValues(index2, curField);\n        if (norms1 != null && norms2 != null)\n        {\n          // todo: generalize this (like TestDuelingCodecs assert)\n          byte[] b1 = (byte[]) norms1.getSource().getArray();\n          byte[] b2 = (byte[]) norms2.getSource().getArray();\n          assertEquals(b1.length, b2.length);\n\t        for (int i = 0; i < b1.length; i++) {\n\t          assertEquals(\"Norm different for doc \" + i + \" and field '\" + curField + \"'.\", b1[i], b2[i]);\n\t        }\n        }\n        else\n        {\n          assertSame(norms1, norms2);\n        }\n      }\n      \n      // check deletions\n      final Bits liveDocs1 = MultiFields.getLiveDocs(index1);\n      final Bits liveDocs2 = MultiFields.getLiveDocs(index2);\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        assertEquals(\"Doc \" + i + \" only deleted in one index.\",\n                     liveDocs1 == null || !liveDocs1.get(i),\n                     liveDocs2 == null || !liveDocs2.get(i));\n      }\n      \n      // check stored fields\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        if (liveDocs1 == null || liveDocs1.get(i)) {\n          Document doc1 = index1.document(i);\n          Document doc2 = index2.document(i);\n          List<IndexableField> field1 = doc1.getFields();\n          List<IndexableField> field2 = doc2.getFields();\n          assertEquals(\"Different numbers of fields for doc \" + i + \".\", field1.size(), field2.size());\n          Iterator<IndexableField> itField1 = field1.iterator();\n          Iterator<IndexableField> itField2 = field2.iterator();\n          while (itField1.hasNext()) {\n            Field curField1 = (Field) itField1.next();\n            Field curField2 = (Field) itField2.next();\n            assertEquals(\"Different fields names for doc \" + i + \".\", curField1.name(), curField2.name());\n            assertEquals(\"Different field values for doc \" + i + \".\", curField1.stringValue(), curField2.stringValue());\n          }          \n        }\n      }\n      \n      // check dictionary and posting lists\n      FieldsEnum fenum1 = MultiFields.getFields(index1).iterator();\n      FieldsEnum fenum2 = MultiFields.getFields(index1).iterator();\n      String field1 = null;\n      Bits liveDocs = MultiFields.getLiveDocs(index1);\n      while((field1=fenum1.next()) != null) {\n        assertEquals(\"Different fields\", field1, fenum2.next());\n        Terms terms1 = fenum1.terms();\n        if (terms1 == null) {\n          assertNull(fenum2.terms());\n          continue;\n        }\n        TermsEnum enum1 = terms1.iterator(null);\n\n        Terms terms2 = fenum2.terms();\n        assertNotNull(terms2);\n        TermsEnum enum2 = terms2.iterator(null);\n\n        while(enum1.next() != null) {\n          assertEquals(\"Different terms\", enum1.term(), enum2.next());\n          DocsAndPositionsEnum tp1 = enum1.docsAndPositions(liveDocs, null, false);\n          DocsAndPositionsEnum tp2 = enum2.docsAndPositions(liveDocs, null, false);\n\n          while(tp1.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n            assertTrue(tp2.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n            assertEquals(\"Different doc id in postinglist of term \" + enum1.term() + \".\", tp1.docID(), tp2.docID());\n            assertEquals(\"Different term frequence in postinglist of term \" + enum1.term() + \".\", tp1.freq(), tp2.freq());\n            for (int i = 0; i < tp1.freq(); i++) {\n              assertEquals(\"Different positions in postinglist of term \" + enum1.term() + \".\", tp1.nextPosition(), tp2.nextPosition());\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    // TODO: maybe this can reuse the logic of test dueling codecs?\n    public static void assertIndexEquals(IndexReader index1, IndexReader index2) throws IOException {\n      assertEquals(\"IndexReaders have different values for numDocs.\", index1.numDocs(), index2.numDocs());\n      assertEquals(\"IndexReaders have different values for maxDoc.\", index1.maxDoc(), index2.maxDoc());\n      assertEquals(\"Only one IndexReader has deletions.\", index1.hasDeletions(), index2.hasDeletions());\n      if (!(index1 instanceof ParallelReader)) {\n        assertEquals(\"Single segment test differs.\", index1.getSequentialSubReaders().length == 1, index2.getSequentialSubReaders().length == 1);\n      }\n      \n      // check field names\n      FieldInfos fieldInfos1 = ReaderUtil.getMergedFieldInfos(index1);\n      FieldInfos fieldInfos2 = ReaderUtil.getMergedFieldInfos(index2);\n      assertEquals(\"IndexReaders have different numbers of fields.\", fieldInfos1.size(), fieldInfos2.size());\n      final int numFields = fieldInfos1.size();\n      for(int fieldID=0;fieldID<numFields;fieldID++) {\n        final FieldInfo fieldInfo1 = fieldInfos1.fieldInfo(fieldID);\n        final FieldInfo fieldInfo2 = fieldInfos2.fieldInfo(fieldID);\n        assertEquals(\"Different field names.\", fieldInfo1.name, fieldInfo2.name);\n      }\n      \n      // check norms\n      for(FieldInfo fieldInfo : fieldInfos1) {\n        String curField = fieldInfo.name;\n        DocValues norms1 = MultiDocValues.getNormDocValues(index1, curField);\n        DocValues norms2 = MultiDocValues.getNormDocValues(index2, curField);\n        if (norms1 != null && norms2 != null)\n        {\n          // todo: generalize this (like TestDuelingCodecs assert)\n          byte[] b1 = (byte[]) norms1.getSource().getArray();\n          byte[] b2 = (byte[]) norms2.getSource().getArray();\n          assertEquals(b1.length, b2.length);\n\t        for (int i = 0; i < b1.length; i++) {\n\t          assertEquals(\"Norm different for doc \" + i + \" and field '\" + curField + \"'.\", b1[i], b2[i]);\n\t        }\n        }\n        else\n        {\n          assertSame(norms1, norms2);\n        }\n      }\n      \n      // check deletions\n      final Bits liveDocs1 = MultiFields.getLiveDocs(index1);\n      final Bits liveDocs2 = MultiFields.getLiveDocs(index2);\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        assertEquals(\"Doc \" + i + \" only deleted in one index.\",\n                     liveDocs1 == null || !liveDocs1.get(i),\n                     liveDocs2 == null || !liveDocs2.get(i));\n      }\n      \n      // check stored fields\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        if (liveDocs1 == null || liveDocs1.get(i)) {\n          Document doc1 = index1.document(i);\n          Document doc2 = index2.document(i);\n          List<IndexableField> field1 = doc1.getFields();\n          List<IndexableField> field2 = doc2.getFields();\n          assertEquals(\"Different numbers of fields for doc \" + i + \".\", field1.size(), field2.size());\n          Iterator<IndexableField> itField1 = field1.iterator();\n          Iterator<IndexableField> itField2 = field2.iterator();\n          while (itField1.hasNext()) {\n            Field curField1 = (Field) itField1.next();\n            Field curField2 = (Field) itField2.next();\n            assertEquals(\"Different fields names for doc \" + i + \".\", curField1.name(), curField2.name());\n            assertEquals(\"Different field values for doc \" + i + \".\", curField1.stringValue(), curField2.stringValue());\n          }          \n        }\n      }\n      \n      // check dictionary and posting lists\n      FieldsEnum fenum1 = MultiFields.getFields(index1).iterator();\n      FieldsEnum fenum2 = MultiFields.getFields(index1).iterator();\n      String field1 = null;\n      Bits liveDocs = MultiFields.getLiveDocs(index1);\n      while((field1=fenum1.next()) != null) {\n        assertEquals(\"Different fields\", field1, fenum2.next());\n        Terms terms1 = fenum1.terms();\n        if (terms1 == null) {\n          assertNull(fenum2.terms());\n          continue;\n        }\n        TermsEnum enum1 = terms1.iterator(null);\n\n        Terms terms2 = fenum2.terms();\n        assertNotNull(terms2);\n        TermsEnum enum2 = terms2.iterator(null);\n\n        while(enum1.next() != null) {\n          assertEquals(\"Different terms\", enum1.term(), enum2.next());\n          DocsAndPositionsEnum tp1 = enum1.docsAndPositions(liveDocs, null, false);\n          DocsAndPositionsEnum tp2 = enum2.docsAndPositions(liveDocs, null, false);\n\n          while(tp1.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n            assertTrue(tp2.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n            assertEquals(\"Different doc id in postinglist of term \" + enum1.term() + \".\", tp1.docID(), tp2.docID());\n            assertEquals(\"Different term frequence in postinglist of term \" + enum1.term() + \".\", tp1.freq(), tp2.freq());\n            for (int i = 0; i < tp1.freq(); i++) {\n              assertEquals(\"Different positions in postinglist of term \" + enum1.term() + \".\", tp1.nextPosition(), tp2.nextPosition());\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexReader#assertIndexEquals(DirectoryReader,DirectoryReader).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexReader#assertIndexEquals(DirectoryReader,DirectoryReader).mjava","sourceNew":"    // TODO: maybe this can reuse the logic of test dueling codecs?\n    public static void assertIndexEquals(DirectoryReader index1, DirectoryReader index2) throws IOException {\n      assertEquals(\"IndexReaders have different values for numDocs.\", index1.numDocs(), index2.numDocs());\n      assertEquals(\"IndexReaders have different values for maxDoc.\", index1.maxDoc(), index2.maxDoc());\n      assertEquals(\"Only one IndexReader has deletions.\", index1.hasDeletions(), index2.hasDeletions());\n      assertEquals(\"Single segment test differs.\", index1.getSequentialSubReaders().length == 1, index2.getSequentialSubReaders().length == 1);\n      \n      // check field names\n      FieldInfos fieldInfos1 = MultiFields.getMergedFieldInfos(index1);\n      FieldInfos fieldInfos2 = MultiFields.getMergedFieldInfos(index2);\n      assertEquals(\"IndexReaders have different numbers of fields.\", fieldInfos1.size(), fieldInfos2.size());\n      final int numFields = fieldInfos1.size();\n      for(int fieldID=0;fieldID<numFields;fieldID++) {\n        final FieldInfo fieldInfo1 = fieldInfos1.fieldInfo(fieldID);\n        final FieldInfo fieldInfo2 = fieldInfos2.fieldInfo(fieldID);\n        assertEquals(\"Different field names.\", fieldInfo1.name, fieldInfo2.name);\n      }\n      \n      // check norms\n      for(FieldInfo fieldInfo : fieldInfos1) {\n        String curField = fieldInfo.name;\n        DocValues norms1 = MultiDocValues.getNormDocValues(index1, curField);\n        DocValues norms2 = MultiDocValues.getNormDocValues(index2, curField);\n        if (norms1 != null && norms2 != null)\n        {\n          // todo: generalize this (like TestDuelingCodecs assert)\n          byte[] b1 = (byte[]) norms1.getSource().getArray();\n          byte[] b2 = (byte[]) norms2.getSource().getArray();\n          assertEquals(b1.length, b2.length);\n\t        for (int i = 0; i < b1.length; i++) {\n\t          assertEquals(\"Norm different for doc \" + i + \" and field '\" + curField + \"'.\", b1[i], b2[i]);\n\t        }\n        }\n        else\n        {\n          assertSame(norms1, norms2);\n        }\n      }\n      \n      // check deletions\n      final Bits liveDocs1 = MultiFields.getLiveDocs(index1);\n      final Bits liveDocs2 = MultiFields.getLiveDocs(index2);\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        assertEquals(\"Doc \" + i + \" only deleted in one index.\",\n                     liveDocs1 == null || !liveDocs1.get(i),\n                     liveDocs2 == null || !liveDocs2.get(i));\n      }\n      \n      // check stored fields\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        if (liveDocs1 == null || liveDocs1.get(i)) {\n          Document doc1 = index1.document(i);\n          Document doc2 = index2.document(i);\n          List<IndexableField> field1 = doc1.getFields();\n          List<IndexableField> field2 = doc2.getFields();\n          assertEquals(\"Different numbers of fields for doc \" + i + \".\", field1.size(), field2.size());\n          Iterator<IndexableField> itField1 = field1.iterator();\n          Iterator<IndexableField> itField2 = field2.iterator();\n          while (itField1.hasNext()) {\n            Field curField1 = (Field) itField1.next();\n            Field curField2 = (Field) itField2.next();\n            assertEquals(\"Different fields names for doc \" + i + \".\", curField1.name(), curField2.name());\n            assertEquals(\"Different field values for doc \" + i + \".\", curField1.stringValue(), curField2.stringValue());\n          }          \n        }\n      }\n      \n      // check dictionary and posting lists\n      FieldsEnum fenum1 = MultiFields.getFields(index1).iterator();\n      FieldsEnum fenum2 = MultiFields.getFields(index1).iterator();\n      String field1 = null;\n      Bits liveDocs = MultiFields.getLiveDocs(index1);\n      while((field1=fenum1.next()) != null) {\n        assertEquals(\"Different fields\", field1, fenum2.next());\n        Terms terms1 = fenum1.terms();\n        if (terms1 == null) {\n          assertNull(fenum2.terms());\n          continue;\n        }\n        TermsEnum enum1 = terms1.iterator(null);\n\n        Terms terms2 = fenum2.terms();\n        assertNotNull(terms2);\n        TermsEnum enum2 = terms2.iterator(null);\n\n        while(enum1.next() != null) {\n          assertEquals(\"Different terms\", enum1.term(), enum2.next());\n          DocsAndPositionsEnum tp1 = enum1.docsAndPositions(liveDocs, null, false);\n          DocsAndPositionsEnum tp2 = enum2.docsAndPositions(liveDocs, null, false);\n\n          while(tp1.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n            assertTrue(tp2.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n            assertEquals(\"Different doc id in postinglist of term \" + enum1.term() + \".\", tp1.docID(), tp2.docID());\n            assertEquals(\"Different term frequence in postinglist of term \" + enum1.term() + \".\", tp1.freq(), tp2.freq());\n            for (int i = 0; i < tp1.freq(); i++) {\n              assertEquals(\"Different positions in postinglist of term \" + enum1.term() + \".\", tp1.nextPosition(), tp2.nextPosition());\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    // TODO: maybe this can reuse the logic of test dueling codecs?\n    public static void assertIndexEquals(DirectoryReader index1, DirectoryReader index2) throws IOException {\n      assertEquals(\"IndexReaders have different values for numDocs.\", index1.numDocs(), index2.numDocs());\n      assertEquals(\"IndexReaders have different values for maxDoc.\", index1.maxDoc(), index2.maxDoc());\n      assertEquals(\"Only one IndexReader has deletions.\", index1.hasDeletions(), index2.hasDeletions());\n      assertEquals(\"Single segment test differs.\", index1.getSequentialSubReaders().length == 1, index2.getSequentialSubReaders().length == 1);\n      \n      // check field names\n      FieldInfos fieldInfos1 = MultiFields.getMergedFieldInfos(index1);\n      FieldInfos fieldInfos2 = MultiFields.getMergedFieldInfos(index2);\n      assertEquals(\"IndexReaders have different numbers of fields.\", fieldInfos1.size(), fieldInfos2.size());\n      final int numFields = fieldInfos1.size();\n      for(int fieldID=0;fieldID<numFields;fieldID++) {\n        final FieldInfo fieldInfo1 = fieldInfos1.fieldInfo(fieldID);\n        final FieldInfo fieldInfo2 = fieldInfos2.fieldInfo(fieldID);\n        assertEquals(\"Different field names.\", fieldInfo1.name, fieldInfo2.name);\n      }\n      \n      // check norms\n      for(FieldInfo fieldInfo : fieldInfos1) {\n        String curField = fieldInfo.name;\n        DocValues norms1 = MultiDocValues.getNormDocValues(index1, curField);\n        DocValues norms2 = MultiDocValues.getNormDocValues(index2, curField);\n        if (norms1 != null && norms2 != null)\n        {\n          // todo: generalize this (like TestDuelingCodecs assert)\n          byte[] b1 = (byte[]) norms1.getSource().getArray();\n          byte[] b2 = (byte[]) norms2.getSource().getArray();\n          assertEquals(b1.length, b2.length);\n\t        for (int i = 0; i < b1.length; i++) {\n\t          assertEquals(\"Norm different for doc \" + i + \" and field '\" + curField + \"'.\", b1[i], b2[i]);\n\t        }\n        }\n        else\n        {\n          assertSame(norms1, norms2);\n        }\n      }\n      \n      // check deletions\n      final Bits liveDocs1 = MultiFields.getLiveDocs(index1);\n      final Bits liveDocs2 = MultiFields.getLiveDocs(index2);\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        assertEquals(\"Doc \" + i + \" only deleted in one index.\",\n                     liveDocs1 == null || !liveDocs1.get(i),\n                     liveDocs2 == null || !liveDocs2.get(i));\n      }\n      \n      // check stored fields\n      for (int i = 0; i < index1.maxDoc(); i++) {\n        if (liveDocs1 == null || liveDocs1.get(i)) {\n          Document doc1 = index1.document(i);\n          Document doc2 = index2.document(i);\n          List<IndexableField> field1 = doc1.getFields();\n          List<IndexableField> field2 = doc2.getFields();\n          assertEquals(\"Different numbers of fields for doc \" + i + \".\", field1.size(), field2.size());\n          Iterator<IndexableField> itField1 = field1.iterator();\n          Iterator<IndexableField> itField2 = field2.iterator();\n          while (itField1.hasNext()) {\n            Field curField1 = (Field) itField1.next();\n            Field curField2 = (Field) itField2.next();\n            assertEquals(\"Different fields names for doc \" + i + \".\", curField1.name(), curField2.name());\n            assertEquals(\"Different field values for doc \" + i + \".\", curField1.stringValue(), curField2.stringValue());\n          }          \n        }\n      }\n      \n      // check dictionary and posting lists\n      FieldsEnum fenum1 = MultiFields.getFields(index1).iterator();\n      FieldsEnum fenum2 = MultiFields.getFields(index1).iterator();\n      String field1 = null;\n      Bits liveDocs = MultiFields.getLiveDocs(index1);\n      while((field1=fenum1.next()) != null) {\n        assertEquals(\"Different fields\", field1, fenum2.next());\n        Terms terms1 = fenum1.terms();\n        if (terms1 == null) {\n          assertNull(fenum2.terms());\n          continue;\n        }\n        TermsEnum enum1 = terms1.iterator(null);\n\n        Terms terms2 = fenum2.terms();\n        assertNotNull(terms2);\n        TermsEnum enum2 = terms2.iterator(null);\n\n        while(enum1.next() != null) {\n          assertEquals(\"Different terms\", enum1.term(), enum2.next());\n          DocsAndPositionsEnum tp1 = enum1.docsAndPositions(liveDocs, null, false);\n          DocsAndPositionsEnum tp2 = enum2.docsAndPositions(liveDocs, null, false);\n\n          while(tp1.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n            assertTrue(tp2.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n            assertEquals(\"Different doc id in postinglist of term \" + enum1.term() + \".\", tp1.docID(), tp2.docID());\n            assertEquals(\"Different term frequence in postinglist of term \" + enum1.term() + \".\", tp1.freq(), tp2.freq());\n            for (int i = 0; i < tp1.freq(); i++) {\n              assertEquals(\"Different positions in postinglist of term \" + enum1.term() + \".\", tp1.nextPosition(), tp2.nextPosition());\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d40b62adb64d8f7b2f85ee849349cfb0bef03f45":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d40b62adb64d8f7b2f85ee849349cfb0bef03f45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d40b62adb64d8f7b2f85ee849349cfb0bef03f45","5cab9a86bd67202d20b6adc463008c8e982b070a"],"d40b62adb64d8f7b2f85ee849349cfb0bef03f45":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}