{"path":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","commits":[{"id":"fdea49117913baff3ee1b0bb8d2c7d148e210e72","date":1331056250,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseMultiReader#BaseMultiReader(R[]).mjava","sourceNew":"  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","sourceOld":"  protected BaseMultiReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"/dev/null","sourceNew":"  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55fd9dcf98ceb0c5bf520ec1a7985676384b8747","date":1331629546,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","sourceOld":"  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","sourceOld":"  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"129b76265b35e595a40a3e0ae8a31cf82cdda4a5","date":1339627601,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","bugFix":null,"bugIntro":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","bugFix":["fdea49117913baff3ee1b0bb8d2c7d148e210e72"],"bugIntro":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe43a17fb193c95257604ee5486e9f6e2a392c28","date":1365104925,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    boolean hasDeletions = false;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      if (r.hasDeletions()) {\n        hasDeletions = true;\n      }\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n    this.hasDeletions = hasDeletions;\n  }\n\n","bugFix":["6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4","a2a81b3988dfbdfb187c425043b89868e359b238"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6b7c6630218ed9693cdb8643276513f9f0043f4","date":1406648084,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */ || maxDoc > IndexWriter.getActualMaxDocs()) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs());\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + Integer.MAX_VALUE);\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n  }\n\n","bugFix":null,"bugIntro":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98b44240f64a2d6935543ff25faee750b29204eb","date":1424972040,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    long maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = (int) maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n\n    if (maxDoc > IndexWriter.getActualMaxDocs()) {\n      if (this instanceof DirectoryReader) {\n        // A single index has too many documents and it is corrupt (IndexWriter prevents this as of LUCENE-6299)\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc, Arrays.toString(subReaders));\n      } else {\n        // Caller is building a MultiReader and it has too many documents; this case is just illegal arguments:\n        throw new IllegalArgumentException(\"Too many documents: composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc);\n      }\n    }\n\n    this.maxDoc = Math.toIntExact(maxDoc);\n    starts[subReaders.length] = this.maxDoc;\n    this.numDocs = Math.toIntExact(numDocs);\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */ || maxDoc > IndexWriter.getActualMaxDocs()) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs());\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98a04f56464afdffd4c430d6c47a0c868a38354e","date":1424985833,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    long maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = (int) maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n\n    if (maxDoc > IndexWriter.getActualMaxDocs()) {\n      if (this instanceof DirectoryReader) {\n        // A single index has too many documents and it is corrupt (IndexWriter prevents this as of LUCENE-6299)\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc, Arrays.toString(subReaders));\n      } else {\n        // Caller is building a MultiReader and it has too many documents; this case is just illegal arguments:\n        throw new IllegalArgumentException(\"Too many documents: composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc);\n      }\n    }\n\n    this.maxDoc = Math.toIntExact(maxDoc);\n    starts[subReaders.length] = this.maxDoc;\n    this.numDocs = Math.toIntExact(numDocs);\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */ || maxDoc > IndexWriter.getActualMaxDocs()) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs());\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n  }\n\n","bugFix":["129b76265b35e595a40a3e0ae8a31cf82cdda4a5","6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4","4d3e8520fd031bab31fd0e4d480e55958bc45efe","d6b7c6630218ed9693cdb8643276513f9f0043f4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    long maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = (int) maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n\n    if (maxDoc > IndexWriter.getActualMaxDocs()) {\n      if (this instanceof DirectoryReader) {\n        // A single index has too many documents and it is corrupt (IndexWriter prevents this as of LUCENE-6299)\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc, Arrays.toString(subReaders));\n      } else {\n        // Caller is building a MultiReader and it has too many documents; this case is just illegal arguments:\n        throw new IllegalArgumentException(\"Too many documents: composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc);\n      }\n    }\n\n    this.maxDoc = Math.toIntExact(maxDoc);\n    starts[subReaders.length] = this.maxDoc;\n    this.numDocs = Math.toIntExact(numDocs);\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    int maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      if (maxDoc < 0 /* overflow */ || maxDoc > IndexWriter.getActualMaxDocs()) {\n        throw new IllegalArgumentException(\"Too many documents, composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs());\n      }\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n    starts[subReaders.length] = maxDoc;\n    this.maxDoc = maxDoc;\n    this.numDocs = numDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"847bd9a78f79c81e9f9a2a64410c4805e6501143","date":1571071678,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    long maxDoc = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = (int) maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      r.registerParentReader(this);\n    }\n\n    if (maxDoc > IndexWriter.getActualMaxDocs()) {\n      if (this instanceof DirectoryReader) {\n        // A single index has too many documents and it is corrupt (IndexWriter prevents this as of LUCENE-6299)\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc, Arrays.toString(subReaders));\n      } else {\n        // Caller is building a MultiReader and it has too many documents; this case is just illegal arguments:\n        throw new IllegalArgumentException(\"Too many documents: composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc);\n      }\n    }\n\n    this.maxDoc = Math.toIntExact(maxDoc);\n    starts[subReaders.length] = this.maxDoc;\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    long maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = (int) maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n\n    if (maxDoc > IndexWriter.getActualMaxDocs()) {\n      if (this instanceof DirectoryReader) {\n        // A single index has too many documents and it is corrupt (IndexWriter prevents this as of LUCENE-6299)\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc, Arrays.toString(subReaders));\n      } else {\n        // Caller is building a MultiReader and it has too many documents; this case is just illegal arguments:\n        throw new IllegalArgumentException(\"Too many documents: composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc);\n      }\n    }\n\n    this.maxDoc = Math.toIntExact(maxDoc);\n    starts[subReaders.length] = this.maxDoc;\n    this.numDocs = Math.toIntExact(numDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader#BaseCompositeReader(R[]).mjava","sourceNew":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    long maxDoc = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = (int) maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      r.registerParentReader(this);\n    }\n\n    if (maxDoc > IndexWriter.getActualMaxDocs()) {\n      if (this instanceof DirectoryReader) {\n        // A single index has too many documents and it is corrupt (IndexWriter prevents this as of LUCENE-6299)\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc, Arrays.toString(subReaders));\n      } else {\n        // Caller is building a MultiReader and it has too many documents; this case is just illegal arguments:\n        throw new IllegalArgumentException(\"Too many documents: composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc);\n      }\n    }\n\n    this.maxDoc = Math.toIntExact(maxDoc);\n    starts[subReaders.length] = this.maxDoc;\n  }\n\n","sourceOld":"  /**\n   * Constructs a {@code BaseCompositeReader} on the given subReaders.\n   * @param subReaders the wrapped sub-readers. This array is returned by\n   * {@link #getSequentialSubReaders} and used to resolve the correct\n   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>\n   * cloned and not protected for modification, the subclass is responsible \n   * to do this.\n   */\n  protected BaseCompositeReader(R[] subReaders) throws IOException {\n    this.subReaders = subReaders;\n    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));\n    starts = new int[subReaders.length + 1];    // build starts array\n    long maxDoc = 0, numDocs = 0;\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = (int) maxDoc;\n      final IndexReader r = subReaders[i];\n      maxDoc += r.maxDoc();      // compute maxDocs\n      numDocs += r.numDocs();    // compute numDocs\n      r.registerParentReader(this);\n    }\n\n    if (maxDoc > IndexWriter.getActualMaxDocs()) {\n      if (this instanceof DirectoryReader) {\n        // A single index has too many documents and it is corrupt (IndexWriter prevents this as of LUCENE-6299)\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc, Arrays.toString(subReaders));\n      } else {\n        // Caller is building a MultiReader and it has too many documents; this case is just illegal arguments:\n        throw new IllegalArgumentException(\"Too many documents: composite IndexReaders cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + maxDoc);\n      }\n    }\n\n    this.maxDoc = Math.toIntExact(maxDoc);\n    starts[subReaders.length] = this.maxDoc;\n    this.numDocs = Math.toIntExact(numDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","55fd9dcf98ceb0c5bf520ec1a7985676384b8747"],"98a04f56464afdffd4c430d6c47a0c868a38354e":["d6b7c6630218ed9693cdb8643276513f9f0043f4","98b44240f64a2d6935543ff25faee750b29204eb"],"129b76265b35e595a40a3e0ae8a31cf82cdda4a5":["55fd9dcf98ceb0c5bf520ec1a7985676384b8747"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fdea49117913baff3ee1b0bb8d2c7d148e210e72"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["129b76265b35e595a40a3e0ae8a31cf82cdda4a5"],"fe43a17fb193c95257604ee5486e9f6e2a392c28":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"fdea49117913baff3ee1b0bb8d2c7d148e210e72":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d6b7c6630218ed9693cdb8643276513f9f0043f4","98a04f56464afdffd4c430d6c47a0c868a38354e"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"847bd9a78f79c81e9f9a2a64410c4805e6501143":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"d6b7c6630218ed9693cdb8643276513f9f0043f4":["fe43a17fb193c95257604ee5486e9f6e2a392c28"],"55fd9dcf98ceb0c5bf520ec1a7985676384b8747":["fdea49117913baff3ee1b0bb8d2c7d148e210e72"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"98b44240f64a2d6935543ff25faee750b29204eb":["d6b7c6630218ed9693cdb8643276513f9f0043f4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["847bd9a78f79c81e9f9a2a64410c4805e6501143"],"b0b597c65628ca9e73913a07e81691f8229bae35":["98a04f56464afdffd4c430d6c47a0c868a38354e","847bd9a78f79c81e9f9a2a64410c4805e6501143"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"98a04f56464afdffd4c430d6c47a0c868a38354e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","847bd9a78f79c81e9f9a2a64410c4805e6501143","b0b597c65628ca9e73913a07e81691f8229bae35"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"129b76265b35e595a40a3e0ae8a31cf82cdda4a5":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"fdea49117913baff3ee1b0bb8d2c7d148e210e72":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","55fd9dcf98ceb0c5bf520ec1a7985676384b8747"],"fe43a17fb193c95257604ee5486e9f6e2a392c28":["d6b7c6630218ed9693cdb8643276513f9f0043f4"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","fdea49117913baff3ee1b0bb8d2c7d148e210e72"],"d6b7c6630218ed9693cdb8643276513f9f0043f4":["98a04f56464afdffd4c430d6c47a0c868a38354e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","98b44240f64a2d6935543ff25faee750b29204eb"],"847bd9a78f79c81e9f9a2a64410c4805e6501143":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"55fd9dcf98ceb0c5bf520ec1a7985676384b8747":["38e3b736c7ca086d61b7dbb841c905ee115490da","129b76265b35e595a40a3e0ae8a31cf82cdda4a5"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe43a17fb193c95257604ee5486e9f6e2a392c28","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"98b44240f64a2d6935543ff25faee750b29204eb":["98a04f56464afdffd4c430d6c47a0c868a38354e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}