{"path":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","commits":[{"id":"8493925b2e70246f0961df584c01a8c2e61ee52f","date":1523611602,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","pathOld":"/dev/null","sourceNew":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    Collections.sort(entries,\n        Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    Builder<Long> fstBuilder = new Builder<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (lastToken != null && token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, (int) token.charAt(i));\n      }\n      fstBuilder.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstBuilder.finish());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c6453827f947004a68ad9db7418781e9df2f660","date":1523626811,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","pathOld":"/dev/null","sourceNew":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    Collections.sort(entries,\n        Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    Builder<Long> fstBuilder = new Builder<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (lastToken != null && token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, (int) token.charAt(i));\n      }\n      fstBuilder.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstBuilder.finish());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9839ec1abbcc2c8e6e064d4661f0bb442be29bb9","date":1536140155,"type":3,"author":"Namgyu Kim","isMerge":false,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","pathOld":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","sourceNew":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    entries.sort(Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    Builder<Long> fstBuilder = new Builder<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, (int) token.charAt(i));\n      }\n      fstBuilder.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstBuilder.finish());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","sourceOld":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    Collections.sort(entries,\n        Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    Builder<Long> fstBuilder = new Builder<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (lastToken != null && token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, (int) token.charAt(i));\n      }\n      fstBuilder.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstBuilder.finish());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9f7831922bb899baba6064894c8ebb795cdee2","date":1566842943,"type":3,"author":"Namgyu Kim","isMerge":false,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","pathOld":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","sourceNew":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    entries.sort(Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    Builder<Long> fstBuilder = new Builder<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, token.charAt(i));\n      }\n      fstBuilder.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstBuilder.finish());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","sourceOld":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    entries.sort(Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    Builder<Long> fstBuilder = new Builder<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, (int) token.charAt(i));\n      }\n      fstBuilder.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstBuilder.finish());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","pathOld":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","sourceNew":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    entries.sort(Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, token.charAt(i));\n      }\n      fstCompiler.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstCompiler.compile());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","sourceOld":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    entries.sort(Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    Builder<Long> fstBuilder = new Builder<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, token.charAt(i));\n      }\n      fstBuilder.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstBuilder.finish());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","pathOld":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/dict/UserDictionary#UserDictionary(List[String]).mjava","sourceNew":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    entries.sort(Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, token.charAt(i));\n      }\n      fstCompiler.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstCompiler.compile());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","sourceOld":"  private UserDictionary(List<String> entries) throws IOException {\n    final CharacterDefinition charDef = CharacterDefinition.getInstance();\n    entries.sort(Comparator.comparing(e -> e.split(\"\\\\s+\")[0]));\n\n    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n    Builder<Long> fstBuilder = new Builder<>(FST.INPUT_TYPE.BYTE2, fstOutput);\n    IntsRefBuilder scratch = new IntsRefBuilder();\n\n    String lastToken = null;\n    List<int[]> segmentations = new ArrayList<>(entries.size());\n    List<Short> rightIds = new ArrayList<>(entries.size());\n    long ord = 0;\n    for (String entry : entries) {\n      String[] splits = entry.split(\"\\\\s+\");\n      String token = splits[0];\n      if (token.equals(lastToken)) {\n        continue;\n      }\n      char lastChar = entry.charAt(entry.length()-1);\n      if (charDef.isHangul(lastChar)) {\n        if (charDef.hasCoda(lastChar)) {\n          rightIds.add(RIGHT_ID_T);\n        } else {\n          rightIds.add(RIGHT_ID_F);\n        }\n      } else {\n        rightIds.add(RIGHT_ID);\n      }\n\n      if (splits.length == 1) {\n        segmentations.add(null);\n      } else {\n        int[] length = new int[splits.length-1];\n        int offset = 0;\n        for (int i = 1; i < splits.length; i++) {\n          length[i-1] = splits[i].length();\n          offset += splits[i].length();\n        }\n        if (offset > token.length()) {\n          throw new IllegalArgumentException(\"Illegal user dictionary entry \" + entry +\n              \" - the segmentation is bigger than the surface form (\" + token + \")\");\n        }\n        segmentations.add(length);\n      }\n\n      // add mapping to FST\n      scratch.grow(token.length());\n      scratch.setLength(token.length());\n      for (int i = 0; i < token.length(); i++) {\n        scratch.setIntAt(i, token.charAt(i));\n      }\n      fstBuilder.add(scratch.get(), ord);\n      lastToken = token;\n      ord ++;\n    }\n    this.fst = new TokenInfoFST(fstBuilder.finish());\n    this.segmentations = segmentations.toArray(new int[segmentations.size()][]);\n    this.rightIds = new short[rightIds.size()];\n    for (int i = 0; i < rightIds.size(); i++) {\n      this.rightIds[i] = rightIds.get(i);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8493925b2e70246f0961df584c01a8c2e61ee52f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["ac9f7831922bb899baba6064894c8ebb795cdee2","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["ac9f7831922bb899baba6064894c8ebb795cdee2"],"ac9f7831922bb899baba6064894c8ebb795cdee2":["9839ec1abbcc2c8e6e064d4661f0bb442be29bb9"],"9839ec1abbcc2c8e6e064d4661f0bb442be29bb9":["5c6453827f947004a68ad9db7418781e9df2f660"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"5c6453827f947004a68ad9db7418781e9df2f660":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8493925b2e70246f0961df584c01a8c2e61ee52f"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8493925b2e70246f0961df584c01a8c2e61ee52f","5c6453827f947004a68ad9db7418781e9df2f660"],"8493925b2e70246f0961df584c01a8c2e61ee52f":["5c6453827f947004a68ad9db7418781e9df2f660"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"ac9f7831922bb899baba6064894c8ebb795cdee2":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9839ec1abbcc2c8e6e064d4661f0bb442be29bb9":["ac9f7831922bb899baba6064894c8ebb795cdee2"],"5c6453827f947004a68ad9db7418781e9df2f660":["9839ec1abbcc2c8e6e064d4661f0bb442be29bb9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}