{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testProcessEmptyRefinement().mjava","commits":[{"id":"84a99d9041ffa5585158e5a283ea1736b6b8b473","date":1532019928,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testProcessEmptyRefinement().mjava","pathOld":"/dev/null","sourceNew":"  @AwaitsFix(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12556\")\n  @Test\n  public void testProcessEmptyRefinement() throws Exception {\n    initServers();\n    final Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set(\"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()));\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3); // we only use 2, but assert at least 3 to also test empty shard\n    final SolrClient c0 = clients.get(0);\n    final SolrClient c1 = clients.get(1);\n\n    client.deleteByQuery(\"*:*\", null);\n    int id = 0;\n    \n    c0.add(sdoc(\"id\", id++, \"cat_s\", \"Ax\"));\n    c0.add(sdoc(\"id\", id++, \"cat_s\", \"Bx\"));\n    c0.add(sdoc(\"id\", id++, \"cat_s\", \"Cx\"));\n    \n    c1.add(sdoc(\"id\", id++, \"cat_s\", \"Ay\"));\n    c1.add(sdoc(\"id\", id++, \"cat_s\", \"By\"));\n    c1.add(sdoc(\"id\", id++, \"cat_s\", \"Cy\"));\n    c1.add(sdoc(\"id\", id++, \"cat_s\", \"Dy\"));\n    \n    client.commit();\n\n    // regardless of how much overrequest there is, in phase#1 \n    // all terms will tie on the sort criteria, and \"Ax\" should win the tiebreaker.\n    //\n    // When Ax is refined against c1, it's 'debug' sort value will increase, but regardless\n    // of the value of processEmpty, no other term should be returned in it's place\n    // (because if they are also correctly refined, then their 'debug' sort values will also increase\n    // and Ax will stll win the tie breaker -- and if they are not refined they shouldn't be returned)\n    for (int overrequest = 0; overrequest < 5; overrequest++) {\n      for (boolean pe : Arrays.asList(false, true)) {\n        ModifiableSolrParams p\n          = params(\"q\", \"*:*\", \"rows\", \"0\", \"json.facet\"\n                   , \"{\"\n                   + \" top:{ type:terms, field:cat_s, limit:1, overrequest:\"+overrequest+\", \"\n                   + \"       refine:true, sort: 'debug asc', \"\n                   + \"       facet:{ debug:'debug(numShards)', processEmpty:\"+pe+\" } } }\");\n        try {\n          client.testJQ(p\n                        , \"facets=={ count: \"+id+\",\"\n                        + \"  top:{ buckets:[ \"\n                        + \"    { val:Ax, count: 1, \"\n                        + \"      debug:\"+(pe ? 2 : 1)\n                        + \"      }\"\n                        + \"  ] } }\"\n                        );\n        } catch (AssertionError | RuntimeException e) {\n          throw new AssertionError(p + \" --> \" + e.getMessage(), e);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"84a99d9041ffa5585158e5a283ea1736b6b8b473":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["84a99d9041ffa5585158e5a283ea1736b6b8b473"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84a99d9041ffa5585158e5a283ea1736b6b8b473"],"84a99d9041ffa5585158e5a283ea1736b6b8b473":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}