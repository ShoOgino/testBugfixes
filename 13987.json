{"path":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","commits":[{"id":"65a70ca4e6df183f7a8f69687b55379fea0ddac2","date":1225224829,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"/dev/null","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    final int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, false, false, -1);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["17361a479c1f90310e847f62780e15542c5e65b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"516bcb3c0d409157f56056e1ecd5e5361ca4ae0b","date":1225722778,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    acceptableLimit = Math.max(limit,acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    \n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize + \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, false, false, -1);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    final int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? 1024 : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, false, false, -1);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","bugFix":null,"bugIntro":["dc809283a68a1108c6c8f7adc03ceec7a1475ad5","dc809283a68a1108c6c8f7adc03ceec7a1475ad5","dc809283a68a1108c6c8f7adc03ceec7a1475ad5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f69c7625b8081dea05bdca4231efca58cbfc0256","date":1225913627,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somehwere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    \n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize + \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, false, false, -1);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    acceptableLimit = Math.max(limit,acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    \n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize + \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, false, false, -1);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eaa3b356f379bef56d6457517e0158dac118e99e","date":1227476542,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n    \n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\" ,cleanupThread =\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somehwere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    \n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize + \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, false, false, -1);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa89a35683d73665c61d7af1d16f41649c25e5a7","date":1228684315,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread =\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n    \n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\" ,cleanupThread =\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71dca9d85d887e585f06edcb60629b14afc6aaed","date":1235979265,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread =\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount\n              + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd10f25652bcb979f0a522653b94f86ad65f6656","date":1260783720,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17361a479c1f90310e847f62780e15542c5e65b1","date":1267915764,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    if (persistence == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      persistence = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n    }\n\n    cumulativeStats = (List<ConcurrentLRUCache.Stats>) persistence;\n    cumulativeStats.add(cache.getStats());\n    return cumulativeStats;\n  }\n\n","bugFix":["65a70ca4e6df183f7a8f69687b55379fea0ddac2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","pathOld":"src/java/org/apache/solr/search/FastLRUCache#init(Map,Object,CacheRegenerator).mjava","sourceNew":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","sourceOld":"  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {\n    state = State.CREATED;\n    this.regenerator = regenerator;\n    name = (String) args.get(\"name\");\n    String str = (String) args.get(\"size\");\n    int limit = str == null ? 1024 : Integer.parseInt(str);\n    int minLimit;\n    str = (String) args.get(\"minSize\");\n    if (str == null) {\n      minLimit = (int) (limit * 0.9);\n    } else {\n      minLimit = Integer.parseInt(str);\n    }\n    if (minLimit==0) minLimit=1;\n    if (limit <= minLimit) limit=minLimit+1;\n\n    int acceptableLimit;\n    str = (String) args.get(\"acceptableSize\");\n    if (str == null) {\n      acceptableLimit = (int) (limit * 0.95);\n    } else {\n      acceptableLimit = Integer.parseInt(str);\n    }\n    // acceptable limit should be somewhere between minLimit and limit\n    acceptableLimit = Math.max(minLimit, acceptableLimit);\n\n    str = (String) args.get(\"initialSize\");\n    final int initialSize = str == null ? limit : Integer.parseInt(str);\n    str = (String) args.get(\"autowarmCount\");\n    autowarmCount = str == null ? 0 : Integer.parseInt(str);\n    str = (String) args.get(\"cleanupThread\");\n    boolean newThread = str == null ? false : Boolean.parseBoolean(str);\n\n    str = (String) args.get(\"showItems\");\n    showItems = str == null ? 0 : Integer.parseInt(str);\n\n\n    description = \"Concurrent LRU Cache(maxSize=\" + limit + \", initialSize=\" + initialSize +\n            \", minSize=\"+minLimit + \", acceptableSize=\"+acceptableLimit+\", cleanupThread=\"+newThread;\n    if (autowarmCount > 0) {\n      description += \", autowarmCount=\" + autowarmCount + \", regenerator=\" + regenerator;\n    }\n    description += ')';\n\n    cache = new ConcurrentLRUCache<K,V>(limit, minLimit, acceptableLimit, initialSize, newThread, false, null);\n    cache.setAlive(false);\n\n    statsList = (List<ConcurrentLRUCache.Stats>) persistence;\n    if (statsList == null) {\n      // must be the first time a cache of this type is being created\n      // Use a CopyOnWriteArrayList since puts are very rare and iteration may be a frequent operation\n      // because it is used in getStatistics()\n      statsList = new CopyOnWriteArrayList<ConcurrentLRUCache.Stats>();\n\n      // the first entry will be for cumulative stats of caches that have been closed.\n      statsList.add(new ConcurrentLRUCache.Stats());\n    }\n    statsList.add(cache.getStats());\n    return statsList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"fa89a35683d73665c61d7af1d16f41649c25e5a7":["eaa3b356f379bef56d6457517e0158dac118e99e"],"f69c7625b8081dea05bdca4231efca58cbfc0256":["516bcb3c0d409157f56056e1ecd5e5361ca4ae0b"],"eaa3b356f379bef56d6457517e0158dac118e99e":["f69c7625b8081dea05bdca4231efca58cbfc0256"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"71dca9d85d887e585f06edcb60629b14afc6aaed":["fa89a35683d73665c61d7af1d16f41649c25e5a7"],"ad94625fb8d088209f46650c8097196fec67f00c":["17361a479c1f90310e847f62780e15542c5e65b1"],"dd10f25652bcb979f0a522653b94f86ad65f6656":["71dca9d85d887e585f06edcb60629b14afc6aaed"],"65a70ca4e6df183f7a8f69687b55379fea0ddac2":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"516bcb3c0d409157f56056e1ecd5e5361ca4ae0b":["65a70ca4e6df183f7a8f69687b55379fea0ddac2"],"17361a479c1f90310e847f62780e15542c5e65b1":["dd10f25652bcb979f0a522653b94f86ad65f6656"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fa89a35683d73665c61d7af1d16f41649c25e5a7":["71dca9d85d887e585f06edcb60629b14afc6aaed"],"f69c7625b8081dea05bdca4231efca58cbfc0256":["eaa3b356f379bef56d6457517e0158dac118e99e"],"eaa3b356f379bef56d6457517e0158dac118e99e":["fa89a35683d73665c61d7af1d16f41649c25e5a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["65a70ca4e6df183f7a8f69687b55379fea0ddac2"],"71dca9d85d887e585f06edcb60629b14afc6aaed":["dd10f25652bcb979f0a522653b94f86ad65f6656"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"dd10f25652bcb979f0a522653b94f86ad65f6656":["17361a479c1f90310e847f62780e15542c5e65b1"],"65a70ca4e6df183f7a8f69687b55379fea0ddac2":["516bcb3c0d409157f56056e1ecd5e5361ca4ae0b"],"516bcb3c0d409157f56056e1ecd5e5361ca4ae0b":["f69c7625b8081dea05bdca4231efca58cbfc0256"],"17361a479c1f90310e847f62780e15542c5e65b1":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}