{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","commits":[{"id":"25b2820b242e28867a2f4edae536382216c511dc","date":1454059647,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d15e34266d75e4e8b95da046cd0afc812367b38","date":1454246129,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd4aa10c3623b9da92a555b8d04677af8fe86877","date":1456230278,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5296efc4b319f5647b606629c093a94b23692c6","date":1456267155,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","date":1456306182,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","date":1456936072,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","date":1457059932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":["adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","dd4aa10c3623b9da92a555b8d04677af8fe86877"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4522ffca5a1f420c6a02198c9332d7c596a30ca5","date":1457270822,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"25b2820b242e28867a2f4edae536382216c511dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4522ffca5a1f420c6a02198c9332d7c596a30ca5":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"dd4aa10c3623b9da92a555b8d04677af8fe86877":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8d15e34266d75e4e8b95da046cd0afc812367b38"],"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6":["8d15e34266d75e4e8b95da046cd0afc812367b38","a5296efc4b319f5647b606629c093a94b23692c6"],"a5296efc4b319f5647b606629c093a94b23692c6":["8d15e34266d75e4e8b95da046cd0afc812367b38","dd4aa10c3623b9da92a555b8d04677af8fe86877"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","25b2820b242e28867a2f4edae536382216c511dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4522ffca5a1f420c6a02198c9332d7c596a30ca5"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"]},"commit2Childs":{"25b2820b242e28867a2f4edae536382216c511dc":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"4522ffca5a1f420c6a02198c9332d7c596a30ca5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dd4aa10c3623b9da92a555b8d04677af8fe86877":["a5296efc4b319f5647b606629c093a94b23692c6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["25b2820b242e28867a2f4edae536382216c511dc","1e6acbaae7af722f17204ceccf0f7db5753eccf3","8d15e34266d75e4e8b95da046cd0afc812367b38"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["4522ffca5a1f420c6a02198c9332d7c596a30ca5"],"a5296efc4b319f5647b606629c093a94b23692c6":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["dd4aa10c3623b9da92a555b8d04677af8fe86877","1e6acbaae7af722f17204ceccf0f7db5753eccf3","1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","a5296efc4b319f5647b606629c093a94b23692c6"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}