{"path":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","commits":[{"id":"690dd789ebb9223a3c8689bf1f9a2da065db599f","date":1110333133,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"/dev/null","sourceNew":"    /**\r\n     * Reset the search results and links to the decorated (inner) table\r\n     * model from this table model.\r\n     */\r\n    private void reindex() {\r\n        try {\r\n            // recreate the RAMDirectory\r\n            directory = new RAMDirectory();\r\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\r\n\r\n            // iterate through all rows\r\n            for (int row=0; row < tableModel.getRowCount(); row++){\r\n\r\n                //for each row make a new document\r\n                Document document = new Document();\r\n                //add the row number of this row in the decorated table model\r\n                //this will allow us to retrive the results later\r\n                //and map this table model's row to a row in the decorated\r\n                //table model\r\n                document.add(new Field(ROW_NUMBER, \"\" + row, true, true, true));\r\n                //iterate through all columns\r\n                //index the value keyed by the column name\r\n                //NOTE: there could be a problem with using column names with spaces\r\n                for (int column=0; column < tableModel.getColumnCount(); column++){\r\n                    String columnName = tableModel.getColumnName(column);\r\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\r\n                    document.add(new Field(columnName, columnValue, true, true, true));\r\n                }\r\n                writer.addDocument(document);\r\n            }\r\n            writer.optimize();\r\n            writer.close();\r\n        } catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d084a2207d6589b283810431b6373c7a44fbd5b","date":1142958370,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\r\n     * Reset the search results and links to the decorated (inner) table\r\n     * model from this table model.\r\n     */\r\n    private void reindex() {\r\n        try {\r\n            // recreate the RAMDirectory\r\n            directory = new RAMDirectory();\r\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\r\n\r\n            // iterate through all rows\r\n            for (int row=0; row < tableModel.getRowCount(); row++){\r\n\r\n                //for each row make a new document\r\n                Document document = new Document();\r\n                //add the row number of this row in the decorated table model\r\n                //this will allow us to retrive the results later\r\n                //and map this table model's row to a row in the decorated\r\n                //table model\r\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.TOKENIZED));\r\n                //iterate through all columns\r\n                //index the value keyed by the column name\r\n                //NOTE: there could be a problem with using column names with spaces\r\n                for (int column=0; column < tableModel.getColumnCount(); column++){\r\n                    String columnName = tableModel.getColumnName(column);\r\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\r\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.TOKENIZED));\r\n                }\r\n                writer.addDocument(document);\r\n            }\r\n            writer.optimize();\r\n            writer.close();\r\n        } catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\n","sourceOld":"    /**\r\n     * Reset the search results and links to the decorated (inner) table\r\n     * model from this table model.\r\n     */\r\n    private void reindex() {\r\n        try {\r\n            // recreate the RAMDirectory\r\n            directory = new RAMDirectory();\r\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\r\n\r\n            // iterate through all rows\r\n            for (int row=0; row < tableModel.getRowCount(); row++){\r\n\r\n                //for each row make a new document\r\n                Document document = new Document();\r\n                //add the row number of this row in the decorated table model\r\n                //this will allow us to retrive the results later\r\n                //and map this table model's row to a row in the decorated\r\n                //table model\r\n                document.add(new Field(ROW_NUMBER, \"\" + row, true, true, true));\r\n                //iterate through all columns\r\n                //index the value keyed by the column name\r\n                //NOTE: there could be a problem with using column names with spaces\r\n                for (int column=0; column < tableModel.getColumnCount(); column++){\r\n                    String columnName = tableModel.getColumnName(column);\r\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\r\n                    document.add(new Field(columnName, columnValue, true, true, true));\r\n                }\r\n                writer.addDocument(document);\r\n            }\r\n            writer.optimize();\r\n            writer.close();\r\n        } catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a","date":1221082732,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\r\n     * Reset the search results and links to the decorated (inner) table\r\n     * model from this table model.\r\n     */\r\n    private void reindex() {\r\n        try {\r\n            // recreate the RAMDirectory\r\n            directory = new RAMDirectory();\r\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\r\n\r\n            // iterate through all rows\r\n            for (int row=0; row < tableModel.getRowCount(); row++){\r\n\r\n                //for each row make a new document\r\n                Document document = new Document();\r\n                //add the row number of this row in the decorated table model\r\n                //this will allow us to retrive the results later\r\n                //and map this table model's row to a row in the decorated\r\n                //table model\r\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\r\n                //iterate through all columns\r\n                //index the value keyed by the column name\r\n                //NOTE: there could be a problem with using column names with spaces\r\n                for (int column=0; column < tableModel.getColumnCount(); column++){\r\n                    String columnName = tableModel.getColumnName(column);\r\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\r\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\r\n                }\r\n                writer.addDocument(document);\r\n            }\r\n            writer.optimize();\r\n            writer.close();\r\n        } catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\n","sourceOld":"    /**\r\n     * Reset the search results and links to the decorated (inner) table\r\n     * model from this table model.\r\n     */\r\n    private void reindex() {\r\n        try {\r\n            // recreate the RAMDirectory\r\n            directory = new RAMDirectory();\r\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\r\n\r\n            // iterate through all rows\r\n            for (int row=0; row < tableModel.getRowCount(); row++){\r\n\r\n                //for each row make a new document\r\n                Document document = new Document();\r\n                //add the row number of this row in the decorated table model\r\n                //this will allow us to retrive the results later\r\n                //and map this table model's row to a row in the decorated\r\n                //table model\r\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.TOKENIZED));\r\n                //iterate through all columns\r\n                //index the value keyed by the column name\r\n                //NOTE: there could be a problem with using column names with spaces\r\n                for (int column=0; column < tableModel.getColumnCount(); column++){\r\n                    String columnName = tableModel.getColumnName(column);\r\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\r\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.TOKENIZED));\r\n                }\r\n                writer.addDocument(document);\r\n            }\r\n            writer.optimize();\r\n            writer.close();\r\n        } catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a361a621b184d9b73c9c9a37323a9845b8f8260","date":1226370946,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrive the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","sourceOld":"    /**\r\n     * Reset the search results and links to the decorated (inner) table\r\n     * model from this table model.\r\n     */\r\n    private void reindex() {\r\n        try {\r\n            // recreate the RAMDirectory\r\n            directory = new RAMDirectory();\r\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\r\n\r\n            // iterate through all rows\r\n            for (int row=0; row < tableModel.getRowCount(); row++){\r\n\r\n                //for each row make a new document\r\n                Document document = new Document();\r\n                //add the row number of this row in the decorated table model\r\n                //this will allow us to retrive the results later\r\n                //and map this table model's row to a row in the decorated\r\n                //table model\r\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\r\n                //iterate through all columns\r\n                //index the value keyed by the column name\r\n                //NOTE: there could be a problem with using column names with spaces\r\n                for (int column=0; column < tableModel.getColumnCount(); column++){\r\n                    String columnName = tableModel.getColumnName(column);\r\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\r\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\r\n                }\r\n                writer.addDocument(document);\r\n            }\r\n            writer.optimize();\r\n            writer.close();\r\n        } catch (Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","sourceOld":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrive the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87c966e9308847938a7c905c2e46a56d8df788b8","date":1255035452,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, analyzer, true, IndexWriter.MaxFieldLength.UNLIMITED);\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","sourceOld":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, analyzer, true);\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cedb00d2dd44640194401179358a2e3ba6051bf","date":1268243626,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Version.LUCENE_CURRENT).setAnalyzer(analyzer));\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","sourceOld":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, analyzer, true, IndexWriter.MaxFieldLength.UNLIMITED);\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52fea2c4081a1e552b98506691990be59503168","date":1268250331,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, analyzer, true, IndexWriter.MaxFieldLength.UNLIMITED);\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","sourceOld":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(Version.LUCENE_CURRENT).setAnalyzer(analyzer));\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","date":1268494368,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(\n                Version.LUCENE_CURRENT, analyzer));\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","sourceOld":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, analyzer, true, IndexWriter.MaxFieldLength.UNLIMITED);\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","pathOld":"contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher#reindex().mjava","sourceNew":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(\n                Version.LUCENE_CURRENT, analyzer));\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","sourceOld":"    /**\n     * Reset the search results and links to the decorated (inner) table\n     * model from this table model.\n     */\n    private void reindex() {\n        try {\n            // recreate the RAMDirectory\n            directory = new RAMDirectory();\n            IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(\n                Version.LUCENE_CURRENT, analyzer));\n\n            // iterate through all rows\n            for (int row=0; row < tableModel.getRowCount(); row++){\n\n                //for each row make a new document\n                Document document = new Document();\n                //add the row number of this row in the decorated table model\n                //this will allow us to retrieve the results later\n                //and map this table model's row to a row in the decorated\n                //table model\n                document.add(new Field(ROW_NUMBER, \"\" + row, Field.Store.YES, Field.Index.ANALYZED));\n                //iterate through all columns\n                //index the value keyed by the column name\n                //NOTE: there could be a problem with using column names with spaces\n                for (int column=0; column < tableModel.getColumnCount(); column++){\n                    String columnName = tableModel.getColumnName(column);\n                    String columnValue = String.valueOf(tableModel.getValueAt(row, column)).toLowerCase();\n                    document.add(new Field(columnName, columnValue, Field.Store.YES, Field.Index.ANALYZED));\n                }\n                writer.addDocument(document);\n            }\n            writer.optimize();\n            writer.close();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["e52fea2c4081a1e552b98506691990be59503168"],"690dd789ebb9223a3c8689bf1f9a2da065db599f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2d084a2207d6589b283810431b6373c7a44fbd5b":["690dd789ebb9223a3c8689bf1f9a2da065db599f"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["6a361a621b184d9b73c9c9a37323a9845b8f8260"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1cedb00d2dd44640194401179358a2e3ba6051bf":["87c966e9308847938a7c905c2e46a56d8df788b8"],"6a361a621b184d9b73c9c9a37323a9845b8f8260":["b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a"],"b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a":["2d084a2207d6589b283810431b6373c7a44fbd5b"],"e52fea2c4081a1e552b98506691990be59503168":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"87c966e9308847938a7c905c2e46a56d8df788b8":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"]},"commit2Childs":{"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"690dd789ebb9223a3c8689bf1f9a2da065db599f":["2d084a2207d6589b283810431b6373c7a44fbd5b"],"2d084a2207d6589b283810431b6373c7a44fbd5b":["b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["690dd789ebb9223a3c8689bf1f9a2da065db599f"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["87c966e9308847938a7c905c2e46a56d8df788b8"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["e52fea2c4081a1e552b98506691990be59503168"],"6a361a621b184d9b73c9c9a37323a9845b8f8260":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"b5015bd4c211c4f399ae66ee20fe6841ba5b0b6a":["6a361a621b184d9b73c9c9a37323a9845b8f8260"],"e52fea2c4081a1e552b98506691990be59503168":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"87c966e9308847938a7c905c2e46a56d8df788b8":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}