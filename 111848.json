{"path":"lucene/spatial3d/src/java/org/apache/lucene/bkdtree3d/BKD3DTreeWriter#build(int,int,PathSlice,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int,int,int[],long[]).mjava","commits":[{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/bkdtree3d/BKD3DTreeWriter#build(int,int,PathSlice,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int,int,int[],long[]).mjava","pathOld":"/dev/null","sourceNew":"  /** The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastXSorted,\n                     PathSlice lastYSorted,\n                     PathSlice lastZSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minX, int maxX,\n                     int minY, int maxY,\n                     int minZ, int maxZ,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    long count = lastXSorted.count;\n    assert count > 0;\n    assert count <= ArrayUtil.MAX_ARRAY_LENGTH;\n\n    assert count == lastYSorted.count;\n    assert count == lastZSorted.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \"\\n  lastXSorted=\" + lastXSorted + \"\\n  lastYSorted=\" + lastYSorted + \"\\n  lastZSorted=\" + lastZSorted + \"\\n  count=\" + lastXSorted.count + \" x=\" + minX + \" TO \" + maxX + \" y=\" + minY + \" TO \" + maxY + \" z=\" + minZ + \" TO \" + maxZ);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxX >= minX;\n      assert maxY >= minY;\n      assert maxZ >= minZ;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      // Sort by docID in the leaf so we get sequentiality at search time (may not matter?):\n      Reader reader = lastXSorted.writer.getReader(lastXSorted.start);\n\n      assert count <= scratchDocIDs.length: \"count=\" + count + \" scratchDocIDs.length=\" + scratchDocIDs.length;\n\n      boolean success = false;\n      try {\n        for (int i=0;i<count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          scratchDocIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(scratchDocIDs, 0, (int) count);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<count;i++) {\n        int docID = scratchDocIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<count;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = scratchDocIDs[i];\n        if (docID != lastDocID) {\n          out.writeInt(docID);\n          //System.out.println(\"  write docID=\" + docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n\n      int splitDim = getSplitDim(minX, maxX, minY, maxY, minZ, maxZ);\n      //System.out.println(\"  splitDim=\" + splitDim);\n\n      PathSlice source;\n\n      if (splitDim == 0) {\n        source = lastXSorted;\n      } else if (splitDim == 1) {\n        source = lastYSorted;\n      } else {\n        source = lastZSorted;\n      }\n\n      // We let ties go to either side, so we should never get down to count == 0, even\n      // in adversarial case (all values are the same):\n      assert count > 0;\n\n      // Inner node: partition/recurse\n      //if (DEBUG) System.out.println(\"  non-leaf\");\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int splitValue = markLeftTree(splitDim, source, bitSet,\n                                    minX, maxX,\n                                    minY, maxY,\n                                    minZ, maxZ);\n      long leftCount = count/2;\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition the other (not split) dims into sorted left and right sets, so we can recurse.\n      // This is somewhat hairy: we partition the next X, Y set according to how we had just\n      // partitioned the Z set, etc.\n\n      Writer[] leftWriters = new Writer[3];\n      Writer[] rightWriters = new Writer[3];\n\n      for(int dim=0;dim<3;dim++) {\n        if (dim == splitDim) {\n          continue;\n        }\n\n        Writer leftWriter = null;\n        Writer rightWriter = null;\n        Reader reader = null;\n\n        boolean success = false;\n\n        int nextLeftCount = 0;\n\n        PathSlice nextSource;\n        if (dim == 0) {\n          nextSource = lastXSorted;\n        } else if (dim == 1) {\n          nextSource = lastYSorted;\n        } else {\n          nextSource = lastZSorted;\n        }\n\n        try {\n          leftWriter = getWriter(leftCount);\n          rightWriter = getWriter(nextSource.count - leftCount);\n\n          assert nextSource.count == count;\n          reader = nextSource.writer.getReader(nextSource.start);\n\n          // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n          // changes the constant factor of building, not the big-oh:\n          for (int i=0;i<count;i++) {\n            boolean result = reader.next();\n            assert result;\n            int x = reader.x();\n            int y = reader.y();\n            int z = reader.z();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n            //System.out.println(\"  i=\" + i + \" x=\" + x + \" ord=\" + ord + \" docID=\" + docID);\n            if (bitSet.get(ord)) {\n              if (splitDim == 0) {\n                assert x <= splitValue: \"x=\" + x + \" splitValue=\" + splitValue;\n              } else if (splitDim == 1) {\n                assert y <= splitValue: \"y=\" + y + \" splitValue=\" + splitValue;\n              } else {\n                assert z <= splitValue: \"z=\" + z + \" splitValue=\" + splitValue;\n              }\n              leftWriter.append(x, y, z, ord, docID);\n              nextLeftCount++;\n            } else {\n              if (splitDim == 0) {\n                assert x >= splitValue: \"x=\" + x + \" splitValue=\" + splitValue;\n              } else if (splitDim == 1) {\n                assert y >= splitValue: \"y=\" + y + \" splitValue=\" + splitValue;\n              } else {\n                assert z >= splitValue: \"z=\" + z + \" splitValue=\" + splitValue;\n              }\n              rightWriter.append(x, y, z, ord, docID);\n            }\n          }\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(reader, leftWriter, rightWriter);\n          } else {\n            IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n          }\n        }\n\n        assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n        leftWriters[dim] = leftWriter;\n        rightWriters[dim] = rightWriter;\n      }\n      bitSet.clear(0, pointCount);\n\n      long rightCount = count - leftCount;\n\n      boolean success = false;\n      try {\n        if (splitDim == 0) {\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriters[1], 0, leftCount),\n                new PathSlice(leftWriters[2], 0, leftCount),\n                bitSet,\n                out,\n                minX, splitValue,\n                minY, maxY,\n                minZ, maxZ,\n                splitValues, leafBlockFPs);\n          leftWriters[1].destroy();\n          leftWriters[2].destroy();\n\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, rightCount),\n                new PathSlice(rightWriters[1], 0, rightCount),\n                new PathSlice(rightWriters[2], 0, rightCount),\n                bitSet,\n                out,\n                splitValue, maxX,\n                minY, maxY,\n                minZ, maxZ,\n                splitValues, leafBlockFPs);\n          rightWriters[1].destroy();\n          rightWriters[2].destroy();\n        } else if (splitDim == 1) {\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriters[0], 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriters[2], 0, leftCount),\n                bitSet,\n                out,\n                minX, maxX,\n                minY, splitValue,\n                minZ, maxZ,\n                splitValues, leafBlockFPs);\n          leftWriters[0].destroy();\n          leftWriters[2].destroy();\n\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriters[0], 0, rightCount),\n                new PathSlice(source.writer, source.start+leftCount, rightCount),    \n                new PathSlice(rightWriters[2], 0, rightCount),\n                bitSet,\n                out,\n                minX, maxX,\n                splitValue, maxY,\n                minZ, maxZ,\n                splitValues, leafBlockFPs);\n          rightWriters[0].destroy();\n          rightWriters[2].destroy();\n        } else {\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriters[0], 0, leftCount),\n                new PathSlice(leftWriters[1], 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minX, maxX,\n                minY, maxY,\n                minZ, splitValue,\n                splitValues, leafBlockFPs);\n          leftWriters[0].destroy();\n          leftWriters[1].destroy();\n\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriters[0], 0, rightCount),\n                new PathSlice(rightWriters[1], 0, rightCount),\n                new PathSlice(source.writer, source.start+leftCount, rightCount),    \n                bitSet,\n                out,\n                minX, maxX,\n                minY, maxY,\n                splitValue, maxZ,\n                splitValues, leafBlockFPs);\n          rightWriters[0].destroy();\n          rightWriters[1].destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          for(Writer writer : leftWriters) {\n            if (writer != null) {\n              try {\n                writer.destroy();\n              } catch (Throwable t) {\n                // Suppress to keep throwing original exc\n              }\n            }\n          }\n          for(Writer writer : rightWriters) {\n            if (writer != null) {\n              try {\n                writer.destroy();\n              } catch (Throwable t) {\n                // Suppress to keep throwing original exc\n              }\n            }\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/bkdtree3d/BKD3DTreeWriter#build(int,int,PathSlice,PathSlice,PathSlice,LongBitSet,IndexOutput,int,int,int,int,int,int,int[],long[]).mjava","sourceNew":null,"sourceOld":"  /** The incoming PathSlice for the dim we will split is already partitioned/sorted. */\n  private void build(int nodeID, int leafNodeOffset,\n                     PathSlice lastXSorted,\n                     PathSlice lastYSorted,\n                     PathSlice lastZSorted,\n                     LongBitSet bitSet,\n                     IndexOutput out,\n                     int minX, int maxX,\n                     int minY, int maxY,\n                     int minZ, int maxZ,\n                     int[] splitValues,\n                     long[] leafBlockFPs) throws IOException {\n\n    long count = lastXSorted.count;\n    assert count > 0;\n    assert count <= ArrayUtil.MAX_ARRAY_LENGTH;\n\n    assert count == lastYSorted.count;\n    assert count == lastZSorted.count;\n\n    //if (DEBUG) System.out.println(\"\\nBUILD: nodeID=\" + nodeID + \" leafNodeOffset=\" + leafNodeOffset + \"\\n  lastXSorted=\" + lastXSorted + \"\\n  lastYSorted=\" + lastYSorted + \"\\n  lastZSorted=\" + lastZSorted + \"\\n  count=\" + lastXSorted.count + \" x=\" + minX + \" TO \" + maxX + \" y=\" + minY + \" TO \" + maxY + \" z=\" + minZ + \" TO \" + maxZ);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node: write block\n      //if (DEBUG) System.out.println(\"  leaf\");\n      assert maxX >= minX;\n      assert maxY >= minY;\n      assert maxZ >= minZ;\n\n      //System.out.println(\"\\nleaf:\\n  lat range: \" + ((long) maxLatEnc-minLatEnc));\n      //System.out.println(\"  lon range: \" + ((long) maxLonEnc-minLonEnc));\n\n      // Sort by docID in the leaf so we get sequentiality at search time (may not matter?):\n      Reader reader = lastXSorted.writer.getReader(lastXSorted.start);\n\n      assert count <= scratchDocIDs.length: \"count=\" + count + \" scratchDocIDs.length=\" + scratchDocIDs.length;\n\n      boolean success = false;\n      try {\n        for (int i=0;i<count;i++) {\n\n          // NOTE: we discard ord at this point; we only needed it temporarily\n          // during building to uniquely identify each point to properly handle\n          // the multi-valued case (one docID having multiple values):\n\n          // We also discard lat/lon, since at search time, we reside on the\n          // wrapped doc values for this:\n\n          boolean result = reader.next();\n          assert result;\n          scratchDocIDs[i] = reader.docID();\n        }\n        success = true;\n      } finally {\n        if (success) {\n          IOUtils.close(reader);\n        } else {\n          IOUtils.closeWhileHandlingException(reader);\n        }\n      }\n\n      Arrays.sort(scratchDocIDs, 0, (int) count);\n\n      // Dedup docIDs: for the multi-valued case where more than one value for the doc\n      // wound up in this leaf cell, we only need to store the docID once:\n      int lastDocID = -1;\n      int uniqueCount = 0;\n      for(int i=0;i<count;i++) {\n        int docID = scratchDocIDs[i];\n        if (docID != lastDocID) {\n          uniqueCount++;\n          lastDocID = docID;\n        }\n      }\n      assert uniqueCount <= count;\n\n      long startFP = out.getFilePointer();\n      out.writeVInt(uniqueCount);\n\n      // Save the block file pointer:\n      leafBlockFPs[nodeID - leafNodeOffset] = startFP;\n      //System.out.println(\"    leafFP=\" + startFP);\n\n      lastDocID = -1;\n      for (int i=0;i<count;i++) {\n        // Absolute int encode; with \"vInt of deltas\" encoding, the .kdd size dropped from\n        // 697 MB -> 539 MB, but query time for 225 queries went from 1.65 sec -> 2.64 sec.\n        // I think if we also indexed prefix terms here we could do less costly compression\n        // on those lists:\n        int docID = scratchDocIDs[i];\n        if (docID != lastDocID) {\n          out.writeInt(docID);\n          //System.out.println(\"  write docID=\" + docID);\n          lastDocID = docID;\n        }\n      }\n      //long endFP = out.getFilePointer();\n      //System.out.println(\"  bytes/doc: \" + ((endFP - startFP) / count));\n    } else {\n\n      int splitDim = getSplitDim(minX, maxX, minY, maxY, minZ, maxZ);\n      //System.out.println(\"  splitDim=\" + splitDim);\n\n      PathSlice source;\n\n      if (splitDim == 0) {\n        source = lastXSorted;\n      } else if (splitDim == 1) {\n        source = lastYSorted;\n      } else {\n        source = lastZSorted;\n      }\n\n      // We let ties go to either side, so we should never get down to count == 0, even\n      // in adversarial case (all values are the same):\n      assert count > 0;\n\n      // Inner node: partition/recurse\n      //if (DEBUG) System.out.println(\"  non-leaf\");\n\n      assert nodeID < splitValues.length: \"nodeID=\" + nodeID + \" splitValues.length=\" + splitValues.length;\n\n      int splitValue = markLeftTree(splitDim, source, bitSet,\n                                    minX, maxX,\n                                    minY, maxY,\n                                    minZ, maxZ);\n      long leftCount = count/2;\n\n      // TODO: we could save split value in here so we don't have to re-open file later:\n\n      // Partition the other (not split) dims into sorted left and right sets, so we can recurse.\n      // This is somewhat hairy: we partition the next X, Y set according to how we had just\n      // partitioned the Z set, etc.\n\n      Writer[] leftWriters = new Writer[3];\n      Writer[] rightWriters = new Writer[3];\n\n      for(int dim=0;dim<3;dim++) {\n        if (dim == splitDim) {\n          continue;\n        }\n\n        Writer leftWriter = null;\n        Writer rightWriter = null;\n        Reader reader = null;\n\n        boolean success = false;\n\n        int nextLeftCount = 0;\n\n        PathSlice nextSource;\n        if (dim == 0) {\n          nextSource = lastXSorted;\n        } else if (dim == 1) {\n          nextSource = lastYSorted;\n        } else {\n          nextSource = lastZSorted;\n        }\n\n        try {\n          leftWriter = getWriter(leftCount);\n          rightWriter = getWriter(nextSource.count - leftCount);\n\n          assert nextSource.count == count;\n          reader = nextSource.writer.getReader(nextSource.start);\n\n          // TODO: we could compute the split value here for each sub-tree and save an O(N) pass on recursion, but makes code hairier and only\n          // changes the constant factor of building, not the big-oh:\n          for (int i=0;i<count;i++) {\n            boolean result = reader.next();\n            assert result;\n            int x = reader.x();\n            int y = reader.y();\n            int z = reader.z();\n            long ord = reader.ord();\n            int docID = reader.docID();\n            assert docID >= 0: \"docID=\" + docID + \" reader=\" + reader;\n            //System.out.println(\"  i=\" + i + \" x=\" + x + \" ord=\" + ord + \" docID=\" + docID);\n            if (bitSet.get(ord)) {\n              if (splitDim == 0) {\n                assert x <= splitValue: \"x=\" + x + \" splitValue=\" + splitValue;\n              } else if (splitDim == 1) {\n                assert y <= splitValue: \"y=\" + y + \" splitValue=\" + splitValue;\n              } else {\n                assert z <= splitValue: \"z=\" + z + \" splitValue=\" + splitValue;\n              }\n              leftWriter.append(x, y, z, ord, docID);\n              nextLeftCount++;\n            } else {\n              if (splitDim == 0) {\n                assert x >= splitValue: \"x=\" + x + \" splitValue=\" + splitValue;\n              } else if (splitDim == 1) {\n                assert y >= splitValue: \"y=\" + y + \" splitValue=\" + splitValue;\n              } else {\n                assert z >= splitValue: \"z=\" + z + \" splitValue=\" + splitValue;\n              }\n              rightWriter.append(x, y, z, ord, docID);\n            }\n          }\n          success = true;\n        } finally {\n          if (success) {\n            IOUtils.close(reader, leftWriter, rightWriter);\n          } else {\n            IOUtils.closeWhileHandlingException(reader, leftWriter, rightWriter);\n          }\n        }\n\n        assert leftCount == nextLeftCount: \"leftCount=\" + leftCount + \" nextLeftCount=\" + nextLeftCount;\n        leftWriters[dim] = leftWriter;\n        rightWriters[dim] = rightWriter;\n      }\n      bitSet.clear(0, pointCount);\n\n      long rightCount = count - leftCount;\n\n      boolean success = false;\n      try {\n        if (splitDim == 0) {\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriters[1], 0, leftCount),\n                new PathSlice(leftWriters[2], 0, leftCount),\n                bitSet,\n                out,\n                minX, splitValue,\n                minY, maxY,\n                minZ, maxZ,\n                splitValues, leafBlockFPs);\n          leftWriters[1].destroy();\n          leftWriters[2].destroy();\n\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(source.writer, source.start+leftCount, rightCount),\n                new PathSlice(rightWriters[1], 0, rightCount),\n                new PathSlice(rightWriters[2], 0, rightCount),\n                bitSet,\n                out,\n                splitValue, maxX,\n                minY, maxY,\n                minZ, maxZ,\n                splitValues, leafBlockFPs);\n          rightWriters[1].destroy();\n          rightWriters[2].destroy();\n        } else if (splitDim == 1) {\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriters[0], 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                new PathSlice(leftWriters[2], 0, leftCount),\n                bitSet,\n                out,\n                minX, maxX,\n                minY, splitValue,\n                minZ, maxZ,\n                splitValues, leafBlockFPs);\n          leftWriters[0].destroy();\n          leftWriters[2].destroy();\n\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriters[0], 0, rightCount),\n                new PathSlice(source.writer, source.start+leftCount, rightCount),    \n                new PathSlice(rightWriters[2], 0, rightCount),\n                bitSet,\n                out,\n                minX, maxX,\n                splitValue, maxY,\n                minZ, maxZ,\n                splitValues, leafBlockFPs);\n          rightWriters[0].destroy();\n          rightWriters[2].destroy();\n        } else {\n          build(2*nodeID, leafNodeOffset,\n                new PathSlice(leftWriters[0], 0, leftCount),\n                new PathSlice(leftWriters[1], 0, leftCount),\n                new PathSlice(source.writer, source.start, leftCount),\n                bitSet,\n                out,\n                minX, maxX,\n                minY, maxY,\n                minZ, splitValue,\n                splitValues, leafBlockFPs);\n          leftWriters[0].destroy();\n          leftWriters[1].destroy();\n\n          build(2*nodeID+1, leafNodeOffset,\n                new PathSlice(rightWriters[0], 0, rightCount),\n                new PathSlice(rightWriters[1], 0, rightCount),\n                new PathSlice(source.writer, source.start+leftCount, rightCount),    \n                bitSet,\n                out,\n                minX, maxX,\n                minY, maxY,\n                splitValue, maxZ,\n                splitValues, leafBlockFPs);\n          rightWriters[0].destroy();\n          rightWriters[1].destroy();\n        }\n        success = true;\n      } finally {\n        if (success == false) {\n          for(Writer writer : leftWriters) {\n            if (writer != null) {\n              try {\n                writer.destroy();\n              } catch (Throwable t) {\n                // Suppress to keep throwing original exc\n              }\n            }\n          }\n          for(Writer writer : rightWriters) {\n            if (writer != null) {\n              try {\n                writer.destroy();\n              } catch (Throwable t) {\n                // Suppress to keep throwing original exc\n              }\n            }\n          }\n        }\n      }\n\n      splitValues[nodeID] = splitValue;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f64b7098768253180859cd8faeae6b1a185b06ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["f64b7098768253180859cd8faeae6b1a185b06ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"f64b7098768253180859cd8faeae6b1a185b06ed":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f64b7098768253180859cd8faeae6b1a185b06ed"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}