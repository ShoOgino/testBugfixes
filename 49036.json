{"path":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","commits":[{"id":"ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c","date":1485769582,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","pathOld":"/dev/null","sourceNew":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.min(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n      this.freq = freq;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c9a209db8d858a699744d4141d223e81bfd50901"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","pathOld":"/dev/null","sourceNew":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.min(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n      this.freq = freq;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9a209db8d858a699744d4141d223e81bfd50901","date":1495175317,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","sourceNew":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.max(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n      this.freq = freq;\n    }\n\n","sourceOld":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.min(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n      this.freq = freq;\n    }\n\n","bugFix":["ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","sourceNew":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.max(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n      this.freq = freq;\n    }\n\n","sourceOld":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.min(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n      this.freq = freq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc14da055888b63b4f8c922d0e1579f3cb315ad7","date":1510744456,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","sourceNew":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.max(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n    }\n\n","sourceOld":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.max(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n      this.freq = freq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f625a75e1debd4c2bf7b827c6f8734582741d668","date":1554470649,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#setScoreAndFreq().mjava","sourceNew":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.max(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n    }\n\n","sourceOld":"    private void setScoreAndFreq() throws IOException {\n      if (childApproximation.docID() >= parentApproximation.docID()) {\n        return;\n      }\n      double score = scoreMode == ScoreMode.None ? 0 : childScorer.score();\n      int freq = 1;\n      while (childApproximation.nextDoc() < parentApproximation.docID()) {\n        if (childTwoPhase == null || childTwoPhase.matches()) {\n          final float childScore = childScorer.score();\n          freq += 1;\n          switch (scoreMode) {\n            case Total:\n            case Avg:\n              score += childScore;\n              break;\n            case Min:\n              score = Math.min(score, childScore);\n              break;\n            case Max:\n              score = Math.max(score, childScore);\n              break;\n            case None:\n              break;\n            default:\n              throw new AssertionError();\n          }\n        }\n      }\n      if (childApproximation.docID() == parentApproximation.docID() && (childTwoPhase == null || childTwoPhase.matches())) {\n        throw new IllegalStateException(\"Child query must not match same docs with parent filter. \"\n            + \"Combine them as must clauses (+) to find a problem doc. \"\n            + \"docId=\" + parentApproximation.docID() + \", \" + childScorer.getClass());\n      }\n      if (scoreMode == ScoreMode.Avg) {\n        score /= freq;\n      }\n      this.score = (float) score;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c","c9a209db8d858a699744d4141d223e81bfd50901"],"dc14da055888b63b4f8c922d0e1579f3cb315ad7":["c9a209db8d858a699744d4141d223e81bfd50901"],"c9a209db8d858a699744d4141d223e81bfd50901":["ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c"],"f625a75e1debd4c2bf7b827c6f8734582741d668":["dc14da055888b63b4f8c922d0e1579f3cb315ad7"],"ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f625a75e1debd4c2bf7b827c6f8734582741d668"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"c9a209db8d858a699744d4141d223e81bfd50901":["e9017cf144952056066919f1ebc7897ff9bd71b1","dc14da055888b63b4f8c922d0e1579f3cb315ad7"],"dc14da055888b63b4f8c922d0e1579f3cb315ad7":["f625a75e1debd4c2bf7b827c6f8734582741d668"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"ef7f129c81e71e8f69a5893aaf8b569bb7fe9b4c":["e9017cf144952056066919f1ebc7897ff9bd71b1","c9a209db8d858a699744d4141d223e81bfd50901","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"f625a75e1debd4c2bf7b827c6f8734582741d668":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}