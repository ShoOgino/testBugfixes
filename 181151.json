{"path":"src/test/org/apache/lucene/index/TestIndex.IndexThread#run().mjava","commits":[{"id":"0afa0bff72bc189cdf6fc95f80d80365a6417e3b","date":1118096970,"type":0,"author":"Daniel Naber","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndex.IndexThread#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      try {\n        for(int i = 0; i < ITERATIONS; i++) {\n          int rand = random.nextInt(101);\n          if (rand < 5) {\n            index.optimize();\n          } else if (rand < 60) {\n            Document doc = getDocument();\n            //System.out.println(\"add doc id=\" + doc.get(\"id\"));\n            index.addDocument(doc);\n            idStack.push(doc.get(\"id\"));\n            added++;\n          } else {\n            if (idStack.size() == 0) {\n              // not enough docs in index, let's wait for next chance\n            } else {\n              // we just delete the last document added and remove it\n              // from the id stack so that it won't be removed twice:\n              String delId = (String)idStack.pop();\n              //System.out.println(\"delete doc id = \" + delId);\n              index.delete(new Term(\"id\", new Integer(delId).toString()));\n              deleted++;\n            }\n          }\n          if (maxWait > 0) {\n            try {\n              rand = random.nextInt(maxWait);\n              //System.out.println(\"waiting \" + rand + \"ms\");\n              Thread.sleep(rand);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"959f192d46200c65ecff4fa688b244abca230b73","date":1118097808,"type":5,"author":"Daniel Naber","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexModifier.IndexThread#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndex.IndexThread#run().mjava","sourceNew":"    public void run() {\n      try {\n        for(int i = 0; i < ITERATIONS; i++) {\n          int rand = random.nextInt(101);\n          if (rand < 5) {\n            index.optimize();\n          } else if (rand < 60) {\n            Document doc = getDocument();\n            //System.out.println(\"add doc id=\" + doc.get(\"id\"));\n            index.addDocument(doc);\n            idStack.push(doc.get(\"id\"));\n            added++;\n          } else {\n            if (idStack.size() == 0) {\n              // not enough docs in index, let's wait for next chance\n            } else {\n              // we just delete the last document added and remove it\n              // from the id stack so that it won't be removed twice:\n              String delId = (String)idStack.pop();\n              //System.out.println(\"delete doc id = \" + delId);\n              index.delete(new Term(\"id\", new Integer(delId).toString()));\n              deleted++;\n            }\n          }\n          if (maxWait > 0) {\n            try {\n              rand = random.nextInt(maxWait);\n              //System.out.println(\"waiting \" + rand + \"ms\");\n              Thread.sleep(rand);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      try {\n        for(int i = 0; i < ITERATIONS; i++) {\n          int rand = random.nextInt(101);\n          if (rand < 5) {\n            index.optimize();\n          } else if (rand < 60) {\n            Document doc = getDocument();\n            //System.out.println(\"add doc id=\" + doc.get(\"id\"));\n            index.addDocument(doc);\n            idStack.push(doc.get(\"id\"));\n            added++;\n          } else {\n            if (idStack.size() == 0) {\n              // not enough docs in index, let's wait for next chance\n            } else {\n              // we just delete the last document added and remove it\n              // from the id stack so that it won't be removed twice:\n              String delId = (String)idStack.pop();\n              //System.out.println(\"delete doc id = \" + delId);\n              index.delete(new Term(\"id\", new Integer(delId).toString()));\n              deleted++;\n            }\n          }\n          if (maxWait > 0) {\n            try {\n              rand = random.nextInt(maxWait);\n              //System.out.println(\"waiting \" + rand + \"ms\");\n              Thread.sleep(rand);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"959f192d46200c65ecff4fa688b244abca230b73":["0afa0bff72bc189cdf6fc95f80d80365a6417e3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0afa0bff72bc189cdf6fc95f80d80365a6417e3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["959f192d46200c65ecff4fa688b244abca230b73"]},"commit2Childs":{"959f192d46200c65ecff4fa688b244abca230b73":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0afa0bff72bc189cdf6fc95f80d80365a6417e3b"],"0afa0bff72bc189cdf6fc95f80d80365a6417e3b":["959f192d46200c65ecff4fa688b244abca230b73"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}