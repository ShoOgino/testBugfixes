{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,int,boolean).mjava","commits":[{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":0,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** test selective indexing */\n  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDataDims, int numIndexDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDataDims][];\n    byte[][] expectedMaxValues = new byte[numDataDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDataDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      FieldType fieldType = new FieldType();\n      fieldType.setDimensions(numDataDims, numIndexDims, numBytesPerDim);\n      fieldType.freeze();\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        // pack the binary point\n        byte[] val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n\n        doc.add(new BinaryPoint(\"field\", val, fieldType));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n          xdoc.add(new BinaryPoint(\"field\", val, fieldType));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDataDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numIndexDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numIndexDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          if (FutureArrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numIndexDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numIndexDims][];\n        byte[][] queryMax = new byte[numIndexDims][];\n        for(int dim=0;dim<numIndexDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numIndexDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,int,boolean).mjava","sourceNew":"  /** test selective indexing */\n  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDataDims, int numIndexDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDataDims][];\n    byte[][] expectedMaxValues = new byte[numDataDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDataDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      FieldType fieldType = new FieldType();\n      fieldType.setDimensions(numDataDims, numIndexDims, numBytesPerDim);\n      fieldType.freeze();\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        // pack the binary point\n        byte[] val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n\n        doc.add(new BinaryPoint(\"field\", val, fieldType));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n          xdoc.add(new BinaryPoint(\"field\", val, fieldType));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDataDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiBits.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numIndexDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numIndexDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          if (FutureArrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numIndexDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numIndexDims][];\n        byte[][] queryMax = new byte[numIndexDims][];\n        for(int dim=0;dim<numIndexDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numIndexDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  /** test selective indexing */\n  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDataDims, int numIndexDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDataDims][];\n    byte[][] expectedMaxValues = new byte[numDataDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDataDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      FieldType fieldType = new FieldType();\n      fieldType.setDimensions(numDataDims, numIndexDims, numBytesPerDim);\n      fieldType.freeze();\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        // pack the binary point\n        byte[] val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n\n        doc.add(new BinaryPoint(\"field\", val, fieldType));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n          xdoc.add(new BinaryPoint(\"field\", val, fieldType));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDataDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiFields.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numIndexDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numIndexDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          if (FutureArrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numIndexDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numIndexDims][];\n        byte[][] queryMax = new byte[numIndexDims][];\n        for(int dim=0;dim<numIndexDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numIndexDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,int,boolean).mjava","sourceNew":"  /** test selective indexing */\n  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDataDims, int numIndexDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDataDims][];\n    byte[][] expectedMaxValues = new byte[numDataDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDataDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (Arrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (Arrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      FieldType fieldType = new FieldType();\n      fieldType.setDimensions(numDataDims, numIndexDims, numBytesPerDim);\n      fieldType.freeze();\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        // pack the binary point\n        byte[] val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n\n        doc.add(new BinaryPoint(\"field\", val, fieldType));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n          xdoc.add(new BinaryPoint(\"field\", val, fieldType));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDataDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiBits.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numIndexDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numIndexDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          if (Arrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (Arrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numIndexDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numIndexDims][];\n        byte[][] queryMax = new byte[numIndexDims][];\n        for(int dim=0;dim<numIndexDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numIndexDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  /** test selective indexing */\n  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDataDims, int numIndexDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDataDims][];\n    byte[][] expectedMaxValues = new byte[numDataDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDataDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      FieldType fieldType = new FieldType();\n      fieldType.setDimensions(numDataDims, numIndexDims, numBytesPerDim);\n      fieldType.freeze();\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        // pack the binary point\n        byte[] val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n\n        doc.add(new BinaryPoint(\"field\", val, fieldType));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n          xdoc.add(new BinaryPoint(\"field\", val, fieldType));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDataDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiBits.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numIndexDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numIndexDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          if (FutureArrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (FutureArrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numIndexDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numIndexDims][];\n        byte[][] queryMax = new byte[numIndexDims][];\n        for(int dim=0;dim<numIndexDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numIndexDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#verify(Directory,byte[][][],int[],int,int,int,boolean).mjava","sourceNew":"  /** test selective indexing */\n  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDims, int numIndexDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDims][];\n    byte[][] expectedMaxValues = new byte[numDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (Arrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (Arrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      FieldType fieldType = new FieldType();\n      fieldType.setDimensions(numDims, numIndexDims, numBytesPerDim);\n      fieldType.freeze();\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        // pack the binary point\n        byte[] val = flattenBinaryPoint(docValues[ord], numDims, numBytesPerDim);\n\n        doc.add(new BinaryPoint(\"field\", val, fieldType));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          val = flattenBinaryPoint(docValues[ord], numDims, numBytesPerDim);\n          xdoc.add(new BinaryPoint(\"field\", val, fieldType));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiBits.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numIndexDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numIndexDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          if (Arrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (Arrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numIndexDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numIndexDims][];\n        byte[][] queryMax = new byte[numIndexDims][];\n        for(int dim=0;dim<numIndexDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numIndexDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","sourceOld":"  /** test selective indexing */\n  private void verify(Directory dir, byte[][][] docValues, int[] ids, int numDataDims, int numIndexDims, int numBytesPerDim, boolean expectExceptions) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    // RandomIndexWriter is too slow:\n    boolean useRealWriter = docValues.length > 10000;\n\n    IndexWriterConfig iwc;\n    if (useRealWriter) {\n      iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n    } else {\n      iwc = newIndexWriterConfig();\n    }\n\n    if (expectExceptions) {\n      MergeScheduler ms = iwc.getMergeScheduler();\n      if (ms instanceof ConcurrentMergeScheduler) {\n        ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n      }\n    }\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    DirectoryReader r = null;\n\n    // Compute actual min/max values:\n    byte[][] expectedMinValues = new byte[numDataDims][];\n    byte[][] expectedMaxValues = new byte[numDataDims][];\n    for(int ord=0;ord<docValues.length;ord++) {\n      for(int dim=0;dim<numDataDims;dim++) {\n        if (ord == 0) {\n          expectedMinValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          expectedMaxValues[dim] = new byte[numBytesPerDim];\n          System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n        } else {\n          // TODO: it's cheating that we use StringHelper.compare for \"truth\": what if it's buggy?\n          if (Arrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMinValues[dim], 0, numBytesPerDim) < 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMinValues[dim], 0, numBytesPerDim);\n          }\n          if (Arrays.compareUnsigned(docValues[ord][dim], 0, numBytesPerDim, expectedMaxValues[dim], 0, numBytesPerDim) > 0) {\n            System.arraycopy(docValues[ord][dim], 0, expectedMaxValues[dim], 0, numBytesPerDim);\n          }\n        }\n      }\n    }\n\n    // 20% of the time we add into a separate directory, then at some point use\n    // addIndexes to bring the indexed point values to the main directory:\n    Directory saveDir;\n    RandomIndexWriter saveW;\n    int addIndexesAt;\n    if (random().nextInt(5) == 1) {\n      saveDir = dir;\n      saveW = w;\n      dir = getDirectory(numValues);\n      if (useRealWriter) {\n        iwc = new IndexWriterConfig(new MockAnalyzer(random()));\n      } else {\n        iwc = newIndexWriterConfig();\n      }\n      if (expectExceptions) {\n        MergeScheduler ms = iwc.getMergeScheduler();\n        if (ms instanceof ConcurrentMergeScheduler) {\n          ((ConcurrentMergeScheduler) ms).setSuppressExceptions();\n        }\n      }\n      w = new RandomIndexWriter(random(), dir, iwc);\n      addIndexesAt = TestUtil.nextInt(random(), 1, numValues-1);\n    } else {\n      saveW = null;\n      saveDir = null;\n      addIndexesAt = 0;\n    }\n\n    try {\n\n      FieldType fieldType = new FieldType();\n      fieldType.setDimensions(numDataDims, numIndexDims, numBytesPerDim);\n      fieldType.freeze();\n\n      Document doc = null;\n      int lastID = -1;\n      for(int ord=0;ord<numValues;ord++) {\n        int id;\n        if (ids == null) {\n          id = ord;\n        } else {\n          id = ids[ord];\n        }\n        if (id != lastID) {\n          if (doc != null) {\n            if (useRealWriter) {\n              w.w.addDocument(doc);\n            } else {\n              w.addDocument(doc);\n            }\n          }\n          doc = new Document();\n          doc.add(new NumericDocValuesField(\"id\", id));\n        }\n        // pack the binary point\n        byte[] val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n\n        doc.add(new BinaryPoint(\"field\", val, fieldType));\n        lastID = id;\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents without this field\n          if (useRealWriter) {\n            w.w.addDocument(new Document());\n          } else {\n            w.addDocument(new Document());\n          }\n          if (VERBOSE) {\n            System.out.println(\"add empty doc\");\n          }\n        }\n\n        if (random().nextInt(30) == 17) {\n          // randomly index some documents with this field, but we will delete them:\n          Document xdoc = new Document();\n          val = flattenBinaryPoint(docValues[ord], numDataDims, numBytesPerDim);\n          xdoc.add(new BinaryPoint(\"field\", val, fieldType));\n          xdoc.add(new StringField(\"nukeme\", \"yes\", Field.Store.NO));\n          if (useRealWriter) {\n            w.w.addDocument(xdoc);\n          } else {\n            w.addDocument(xdoc);\n          }\n          if (VERBOSE) {\n            System.out.println(\"add doc doc-to-delete\");\n          }\n\n          if (random().nextInt(5) == 1) {\n            if (useRealWriter) {\n              w.w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            } else {\n              w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n            }\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" id=\" + id);\n          for(int dim=0;dim<numDataDims;dim++) {\n            System.out.println(\"    dim=\" + dim + \" value=\" + new BytesRef(docValues[ord][dim]));\n          }\n        }\n\n        if (saveW != null && ord >= addIndexesAt) {\n          switchIndex(w, dir, saveW);\n          w = saveW;\n          dir = saveDir;\n          saveW = null;\n          saveDir = null;\n        }\n      }\n      w.addDocument(doc);\n      w.deleteDocuments(new Term(\"nukeme\", \"yes\"));\n\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: now force merge\");\n        }\n        w.forceMerge(1);\n      }\n\n      r = w.getReader();\n      w.close();\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: reader=\" + r);\n      }\n\n      NumericDocValues idValues = MultiDocValues.getNumericValues(r, \"id\");\n      int[] docIDToID = new int[r.maxDoc()];\n      {\n        int docID;\n        while ((docID = idValues.nextDoc()) != NO_MORE_DOCS) {\n          docIDToID[docID] = (int) idValues.longValue();\n        }\n      }\n\n      Bits liveDocs = MultiBits.getLiveDocs(r);\n\n      // Verify min/max values are correct:\n      byte[] minValues = new byte[numIndexDims*numBytesPerDim];\n      Arrays.fill(minValues, (byte) 0xff);\n\n      byte[] maxValues = new byte[numIndexDims*numBytesPerDim];\n\n      for(LeafReaderContext ctx : r.leaves()) {\n        PointValues dimValues = ctx.reader().getPointValues(\"field\");\n        if (dimValues == null) {\n          continue;\n        }\n\n        byte[] leafMinValues = dimValues.getMinPackedValue();\n        byte[] leafMaxValues = dimValues.getMaxPackedValue();\n        for(int dim=0;dim<numIndexDims;dim++) {\n          if (Arrays.compareUnsigned(leafMinValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, minValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) < 0) {\n            System.arraycopy(leafMinValues, dim*numBytesPerDim, minValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n          if (Arrays.compareUnsigned(leafMaxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, maxValues, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim) > 0) {\n            System.arraycopy(leafMaxValues, dim*numBytesPerDim, maxValues, dim*numBytesPerDim, numBytesPerDim);\n          }\n        }\n      }\n\n      byte[] scratch = new byte[numBytesPerDim];\n      for(int dim=0;dim<numIndexDims;dim++) {\n        System.arraycopy(minValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMin=\" + new BytesRef(expectedMinValues[dim]) + \" min=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMinValues[dim], scratch));\n        System.arraycopy(maxValues, dim*numBytesPerDim, scratch, 0, numBytesPerDim);\n        //System.out.println(\"dim=\" + dim + \" expectedMax=\" + new BytesRef(expectedMaxValues[dim]) + \" max=\" + new BytesRef(scratch));\n        assertTrue(Arrays.equals(expectedMaxValues[dim], scratch));\n      }\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numIndexDims][];\n        byte[][] queryMax = new byte[numIndexDims][];\n        for(int dim=0;dim<numIndexDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (Arrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        if (VERBOSE) {\n          for(int dim=0;dim<numIndexDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \"\\n    queryMin=\" + new BytesRef(queryMin[dim]) + \"\\n    queryMax=\" + new BytesRef(queryMax[dim]));\n          }\n        }\n\n        final BitSet hits = new BitSet();\n\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n\n          dimValues.intersect(new PointValues.IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                if (liveDocs == null || liveDocs.get(docBase+docID)) {\n                  hits.set(docIDToID[docBase+docID]);\n                }\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                if (liveDocs != null && liveDocs.get(docBase+docID) == false) {\n                  return;\n                }\n\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  //System.out.println(\"  dim=\" + dim + \" value=\" + new BytesRef(packedValue, dim*numBytesPerDim, numBytesPerDim));\n                  if (Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      Arrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docIDToID[docBase+docID]);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                //System.out.println(\"compare\");\n                for(int dim=0;dim<numIndexDims;dim++) {\n                  if (Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                      Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    //System.out.println(\"  query_outside_cell\");\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (Arrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                             Arrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  //System.out.println(\"  query_crosses_cell\");\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  //System.out.println(\"  cell_inside_query\");\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                Arrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int id;\n            if (ids == null) {\n              id = ord;\n            } else {\n              id = ids[ord];\n            }\n            expected.set(id);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        int failCount = 0;\n        int successCount = 0;\n        for(int id=0;id<limit;id++) {\n          if (expected.get(id) != hits.get(id)) {\n            System.out.println(\"FAIL: id=\" + id);\n            failCount++;\n          } else {\n            successCount++;\n          }\n        }\n\n        if (failCount != 0) {\n          for(int docID=0;docID<r.maxDoc();docID++) {\n            System.out.println(\"  docID=\" + docID + \" id=\" + docIDToID[docID]);\n          }\n\n          fail(failCount + \" docs failed; \" + successCount + \" docs succeeded\");\n        }\n      }\n    } finally {\n      IOUtils.closeWhileHandlingException(r, w, saveW, saveDir == null ? null : dir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"f6652c943595e92c187ee904c382863013eae28f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["f6652c943595e92c187ee904c382863013eae28f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"]},"commit2Childs":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f6652c943595e92c187ee904c382863013eae28f"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}