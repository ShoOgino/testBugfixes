{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAlias#fromProps(String,Map[String,String]).mjava","commits":[{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAlias#fromProps(String,Map[String,String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Factory method for implementations of this interface. There should be no reason to construct instances\n   * elsewhere, and routed alias types are encouraged to have package private constructors.\n   *\n   * @param aliasName The alias name (will be returned by {@link #getAliasName()}\n   * @param props     The properties from an overseer message.\n   * @return An implementation appropriate for the supplied properties, or null if no type is specified.\n   * @throws SolrException If the properties are invalid or the router type is unknown.\n   */\n  static RoutedAlias fromProps(String aliasName, Map<String, String> props) throws SolrException {\n\n    String typeStr = props.get(ROUTER_TYPE_NAME);\n    if (typeStr == null) {\n      return null; // non-routed aliases are being created\n    }\n    SupportedRouterTypes routerType;\n    try {\n       routerType = SupportedRouterTypes.valueOf(typeStr.toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(BAD_REQUEST, \"Router name: \" + typeStr + \" is not in supported types, \"\n          + Arrays.asList(SupportedRouterTypes.values()));\n    }\n    switch (routerType) {\n      case TIME:\n        return new TimeRoutedAlias(aliasName, props);\n      case CATEGORY:\n        return new CategoryRoutedAlias(aliasName, props);\n      default:\n        // if we got a type not handled by the switch there's been a bogus implementation.\n        throw new SolrException(SERVER_ERROR, \"Router \" + routerType + \" is not fully implemented. If you see this\" +\n            \"error in an official release please file a bug report. Available types were:\"\n            + Arrays.asList(SupportedRouterTypes.values()));\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAlias#fromProps(String,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAlias#fromProps(String,Map[String,String]).mjava","sourceNew":"  /**\n   * Factory method for implementations of this interface. There should be no reason to construct instances\n   * elsewhere, and routed alias types are encouraged to have package private constructors.\n   *\n   * @param aliasName The alias name (will be returned by {@link #getAliasName()}\n   * @param props     The properties from an overseer message.\n   * @return An implementation appropriate for the supplied properties, or null if no type is specified.\n   * @throws SolrException If the properties are invalid or the router type is unknown.\n   */\n  public static RoutedAlias fromProps(String aliasName, Map<String, String> props) throws SolrException {\n\n    String typeStr = props.get(ROUTER_TYPE_NAME);\n    if (typeStr == null) {\n      return null; // non-routed aliases are being created\n    }\n    List<RoutedAliasTypes> routerTypes = new ArrayList<>();\n    // check for Dimensional[foo,bar,baz]\n    if (typeStr.startsWith(DIMENSIONAL)) {\n      // multi-dimensional routed alias\n      typeStr = typeStr.substring(DIMENSIONAL.length(), typeStr.length() - 1);\n      String[] types = typeStr.split(\",\");\n      java.util.List<String> fields = new ArrayList<>();\n      if (types.length > 2) {\n        throw new SolrException(BAD_REQUEST,\"More than 2 dimensions is not supported yet. \" +\n            \"Please monitor SOLR-13628 for progress\");\n      }\n      for (int i = 0; i < types.length; i++) {\n        String type = types[i];\n        addRouterTypeOf(type, routerTypes);\n\n        // v2 api case - the v2 -> v1 mapping mechanisms can't handle this conversion because they expect\n        // strings or arrays of strings, not lists of objects.\n        if (props.containsKey(\"router.routerList\")) {\n          @SuppressWarnings(\"unchecked\")  // working around solrparams inability to express lists of objects\n              HashMap tmp = new HashMap(props);\n          @SuppressWarnings(\"unchecked\")  // working around solrparams inability to express lists of objects\n              List<Map<String, Object>> v2RouterList = (List<Map<String, Object>>) tmp.get(\"router.routerList\");\n          Map<String, Object> o = v2RouterList.get(i);\n          for (Map.Entry<String, Object> entry : o.entrySet()) {\n            props.put(ROUTER_PREFIX + i + \".\" + entry.getKey(), String.valueOf(entry.getValue()));\n          }\n        }\n        // Here we need to push the type into each dimension's params. We could have eschewed the\n        // \"Dimensional[dim1,dim2]\" style notation, to simplify this case but I think it's nice\n        // to be able to understand the dimensionality at a glance without having to hunt for name properties\n        // in the list of properties for each dimension.\n        String typeName = ROUTER_PREFIX + i + \".name\";\n        // can't use computeIfAbsent because the non-dimensional case where typeName is present\n        // happens to be an unmodifiable map and will fail.\n        if (!props.containsKey(typeName)) {\n          props.put(typeName, type);\n        }\n        fields.add(props.get(ROUTER_PREFIX + i + \".field\"));\n      }\n      // this next remove is checked for key because when we build from aliases.json's data it we get an\n      // immutable map which would cause  UnsupportedOperationException to be thrown. This remove is here\n      // to prevent this property from making it into aliases.json\n      //noinspection RedundantCollectionOperation\n      if (props.containsKey(\"router.routerList\")) {\n        props.remove(\"router.routerList\");\n      }\n      // Keep code that handles single dimensions happy by providing this value, otherwise ignored.\n      if (!props.containsKey(ROUTER_FIELD)) {\n        props.put(ROUTER_FIELD, String.join(\",\", fields));\n      }\n    } else {\n      // non-dimensional case\n      addRouterTypeOf(typeStr, routerTypes);\n    }\n    if (routerTypes.size() == 1) {\n      RoutedAliasTypes routerType = routerTypes.get(0);\n      return routedAliasForType(aliasName, props, routerType);\n    } else {\n      List<RoutedAlias> dimensions = new ArrayList<>();\n      // this array allows us to get past the chicken/egg problem of needing access to the\n      // DRA inside the dimensions, but needing the dimensions to create the DRA\n      DimensionalRoutedAlias[] dra = new DimensionalRoutedAlias[1];\n      for (int i = 0; i < routerTypes.size(); i++) {\n        RoutedAliasTypes routerType = routerTypes.get(i);\n        // NOTE setting the name to empty string is very important here, as that allows us to simply\n        // concatenate the \"names\" of the parts to get the correct collection name for the DRA\n        dimensions.add(DimensionalRoutedAlias.dimensionForType( selectForIndex(i, props), routerType, i, () -> dra[0]));\n      }\n      return dra[0] = new DimensionalRoutedAlias(dimensions, props.get(CommonParams.NAME), props);\n    }\n  }\n\n","sourceOld":"  /**\n   * Factory method for implementations of this interface. There should be no reason to construct instances\n   * elsewhere, and routed alias types are encouraged to have package private constructors.\n   *\n   * @param aliasName The alias name (will be returned by {@link #getAliasName()}\n   * @param props     The properties from an overseer message.\n   * @return An implementation appropriate for the supplied properties, or null if no type is specified.\n   * @throws SolrException If the properties are invalid or the router type is unknown.\n   */\n  static RoutedAlias fromProps(String aliasName, Map<String, String> props) throws SolrException {\n\n    String typeStr = props.get(ROUTER_TYPE_NAME);\n    if (typeStr == null) {\n      return null; // non-routed aliases are being created\n    }\n    SupportedRouterTypes routerType;\n    try {\n       routerType = SupportedRouterTypes.valueOf(typeStr.toUpperCase(Locale.ENGLISH));\n    } catch (IllegalArgumentException e) {\n      throw new SolrException(BAD_REQUEST, \"Router name: \" + typeStr + \" is not in supported types, \"\n          + Arrays.asList(SupportedRouterTypes.values()));\n    }\n    switch (routerType) {\n      case TIME:\n        return new TimeRoutedAlias(aliasName, props);\n      case CATEGORY:\n        return new CategoryRoutedAlias(aliasName, props);\n      default:\n        // if we got a type not handled by the switch there's been a bogus implementation.\n        throw new SolrException(SERVER_ERROR, \"Router \" + routerType + \" is not fully implemented. If you see this\" +\n            \"error in an official release please file a bug report. Available types were:\"\n            + Arrays.asList(SupportedRouterTypes.values()));\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAlias#fromProps(String,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAlias#fromProps(String,Map[String,String]).mjava","sourceNew":"  /**\n   * Factory method for implementations of this interface. There should be no reason to construct instances\n   * elsewhere, and routed alias types are encouraged to have package private constructors.\n   *\n   * @param aliasName The alias name (will be returned by {@link #getAliasName()}\n   * @param props     The properties from an overseer message.\n   * @return An implementation appropriate for the supplied properties, or null if no type is specified.\n   * @throws SolrException If the properties are invalid or the router type is unknown.\n   */\n  public static RoutedAlias fromProps(String aliasName, Map<String, String> props) throws SolrException {\n\n    String typeStr = props.get(ROUTER_TYPE_NAME);\n    if (typeStr == null) {\n      return null; // non-routed aliases are being created\n    }\n    List<RoutedAliasTypes> routerTypes = new ArrayList<>();\n    // check for Dimensional[foo,bar,baz]\n    if (typeStr.startsWith(DIMENSIONAL)) {\n      // multi-dimensional routed alias\n      typeStr = typeStr.substring(DIMENSIONAL.length(), typeStr.length() - 1);\n      String[] types = typeStr.split(\",\");\n      java.util.List<String> fields = new ArrayList<>();\n      if (types.length > 2) {\n        throw new SolrException(BAD_REQUEST,\"More than 2 dimensions is not supported yet. \" +\n            \"Please monitor SOLR-13628 for progress\");\n      }\n      for (int i = 0; i < types.length; i++) {\n        String type = types[i];\n        addRouterTypeOf(type, routerTypes);\n\n        // v2 api case - the v2 -> v1 mapping mechanisms can't handle this conversion because they expect\n        // strings or arrays of strings, not lists of objects.\n        if (props.containsKey(\"router.routerList\")) {\n          @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n          HashMap tmp = new HashMap(props);\n          @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n          List<Map<String, Object>> v2RouterList = (List<Map<String, Object>>) tmp.get(\"router.routerList\");\n          Map<String, Object> o = v2RouterList.get(i);\n          for (Map.Entry<String, Object> entry : o.entrySet()) {\n            props.put(ROUTER_PREFIX + i + \".\" + entry.getKey(), String.valueOf(entry.getValue()));\n          }\n        }\n        // Here we need to push the type into each dimension's params. We could have eschewed the\n        // \"Dimensional[dim1,dim2]\" style notation, to simplify this case but I think it's nice\n        // to be able to understand the dimensionality at a glance without having to hunt for name properties\n        // in the list of properties for each dimension.\n        String typeName = ROUTER_PREFIX + i + \".name\";\n        // can't use computeIfAbsent because the non-dimensional case where typeName is present\n        // happens to be an unmodifiable map and will fail.\n        if (!props.containsKey(typeName)) {\n          props.put(typeName, type);\n        }\n        fields.add(props.get(ROUTER_PREFIX + i + \".field\"));\n      }\n      // this next remove is checked for key because when we build from aliases.json's data it we get an\n      // immutable map which would cause  UnsupportedOperationException to be thrown. This remove is here\n      // to prevent this property from making it into aliases.json\n      //noinspection RedundantCollectionOperation\n      if (props.containsKey(\"router.routerList\")) {\n        props.remove(\"router.routerList\");\n      }\n      // Keep code that handles single dimensions happy by providing this value, otherwise ignored.\n      if (!props.containsKey(ROUTER_FIELD)) {\n        props.put(ROUTER_FIELD, String.join(\",\", fields));\n      }\n    } else {\n      // non-dimensional case\n      addRouterTypeOf(typeStr, routerTypes);\n    }\n    if (routerTypes.size() == 1) {\n      RoutedAliasTypes routerType = routerTypes.get(0);\n      return routedAliasForType(aliasName, props, routerType);\n    } else {\n      List<RoutedAlias> dimensions = new ArrayList<>();\n      // this array allows us to get past the chicken/egg problem of needing access to the\n      // DRA inside the dimensions, but needing the dimensions to create the DRA\n      DimensionalRoutedAlias[] dra = new DimensionalRoutedAlias[1];\n      for (int i = 0; i < routerTypes.size(); i++) {\n        RoutedAliasTypes routerType = routerTypes.get(i);\n        // NOTE setting the name to empty string is very important here, as that allows us to simply\n        // concatenate the \"names\" of the parts to get the correct collection name for the DRA\n        dimensions.add(DimensionalRoutedAlias.dimensionForType( selectForIndex(i, props), routerType, i, () -> dra[0]));\n      }\n      return dra[0] = new DimensionalRoutedAlias(dimensions, props.get(CommonParams.NAME), props);\n    }\n  }\n\n","sourceOld":"  /**\n   * Factory method for implementations of this interface. There should be no reason to construct instances\n   * elsewhere, and routed alias types are encouraged to have package private constructors.\n   *\n   * @param aliasName The alias name (will be returned by {@link #getAliasName()}\n   * @param props     The properties from an overseer message.\n   * @return An implementation appropriate for the supplied properties, or null if no type is specified.\n   * @throws SolrException If the properties are invalid or the router type is unknown.\n   */\n  public static RoutedAlias fromProps(String aliasName, Map<String, String> props) throws SolrException {\n\n    String typeStr = props.get(ROUTER_TYPE_NAME);\n    if (typeStr == null) {\n      return null; // non-routed aliases are being created\n    }\n    List<RoutedAliasTypes> routerTypes = new ArrayList<>();\n    // check for Dimensional[foo,bar,baz]\n    if (typeStr.startsWith(DIMENSIONAL)) {\n      // multi-dimensional routed alias\n      typeStr = typeStr.substring(DIMENSIONAL.length(), typeStr.length() - 1);\n      String[] types = typeStr.split(\",\");\n      java.util.List<String> fields = new ArrayList<>();\n      if (types.length > 2) {\n        throw new SolrException(BAD_REQUEST,\"More than 2 dimensions is not supported yet. \" +\n            \"Please monitor SOLR-13628 for progress\");\n      }\n      for (int i = 0; i < types.length; i++) {\n        String type = types[i];\n        addRouterTypeOf(type, routerTypes);\n\n        // v2 api case - the v2 -> v1 mapping mechanisms can't handle this conversion because they expect\n        // strings or arrays of strings, not lists of objects.\n        if (props.containsKey(\"router.routerList\")) {\n          @SuppressWarnings(\"unchecked\")  // working around solrparams inability to express lists of objects\n              HashMap tmp = new HashMap(props);\n          @SuppressWarnings(\"unchecked\")  // working around solrparams inability to express lists of objects\n              List<Map<String, Object>> v2RouterList = (List<Map<String, Object>>) tmp.get(\"router.routerList\");\n          Map<String, Object> o = v2RouterList.get(i);\n          for (Map.Entry<String, Object> entry : o.entrySet()) {\n            props.put(ROUTER_PREFIX + i + \".\" + entry.getKey(), String.valueOf(entry.getValue()));\n          }\n        }\n        // Here we need to push the type into each dimension's params. We could have eschewed the\n        // \"Dimensional[dim1,dim2]\" style notation, to simplify this case but I think it's nice\n        // to be able to understand the dimensionality at a glance without having to hunt for name properties\n        // in the list of properties for each dimension.\n        String typeName = ROUTER_PREFIX + i + \".name\";\n        // can't use computeIfAbsent because the non-dimensional case where typeName is present\n        // happens to be an unmodifiable map and will fail.\n        if (!props.containsKey(typeName)) {\n          props.put(typeName, type);\n        }\n        fields.add(props.get(ROUTER_PREFIX + i + \".field\"));\n      }\n      // this next remove is checked for key because when we build from aliases.json's data it we get an\n      // immutable map which would cause  UnsupportedOperationException to be thrown. This remove is here\n      // to prevent this property from making it into aliases.json\n      //noinspection RedundantCollectionOperation\n      if (props.containsKey(\"router.routerList\")) {\n        props.remove(\"router.routerList\");\n      }\n      // Keep code that handles single dimensions happy by providing this value, otherwise ignored.\n      if (!props.containsKey(ROUTER_FIELD)) {\n        props.put(ROUTER_FIELD, String.join(\",\", fields));\n      }\n    } else {\n      // non-dimensional case\n      addRouterTypeOf(typeStr, routerTypes);\n    }\n    if (routerTypes.size() == 1) {\n      RoutedAliasTypes routerType = routerTypes.get(0);\n      return routedAliasForType(aliasName, props, routerType);\n    } else {\n      List<RoutedAlias> dimensions = new ArrayList<>();\n      // this array allows us to get past the chicken/egg problem of needing access to the\n      // DRA inside the dimensions, but needing the dimensions to create the DRA\n      DimensionalRoutedAlias[] dra = new DimensionalRoutedAlias[1];\n      for (int i = 0; i < routerTypes.size(); i++) {\n        RoutedAliasTypes routerType = routerTypes.get(i);\n        // NOTE setting the name to empty string is very important here, as that allows us to simply\n        // concatenate the \"names\" of the parts to get the correct collection name for the DRA\n        dimensions.add(DimensionalRoutedAlias.dimensionForType( selectForIndex(i, props), routerType, i, () -> dra[0]));\n      }\n      return dra[0] = new DimensionalRoutedAlias(dimensions, props.get(CommonParams.NAME), props);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eba8995e4d085569e201ecf8bf75d1cb02fa74bf","date":1592955411,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAlias#fromProps(String,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/RoutedAlias#fromProps(String,Map[String,String]).mjava","sourceNew":"  /**\n   * Factory method for implementations of this interface. There should be no reason to construct instances\n   * elsewhere, and routed alias types are encouraged to have package private constructors.\n   *\n   * @param aliasName The alias name (will be returned by {@link #getAliasName()}\n   * @param props     The properties from an overseer message.\n   * @return An implementation appropriate for the supplied properties, or null if no type is specified.\n   * @throws SolrException If the properties are invalid or the router type is unknown.\n   */\n  public static RoutedAlias fromProps(String aliasName, Map<String, String> props) throws SolrException {\n\n    String typeStr = props.get(ROUTER_TYPE_NAME);\n    if (typeStr == null) {\n      return null; // non-routed aliases are being created\n    }\n    List<RoutedAliasTypes> routerTypes = new ArrayList<>();\n    // check for Dimensional[foo,bar,baz]\n    if (typeStr.startsWith(DIMENSIONAL)) {\n      // multi-dimensional routed alias\n      typeStr = typeStr.substring(DIMENSIONAL.length(), typeStr.length() - 1);\n      String[] types = typeStr.split(\",\");\n      java.util.List<String> fields = new ArrayList<>();\n      if (types.length > 2) {\n        throw new SolrException(BAD_REQUEST,\"More than 2 dimensions is not supported yet. \" +\n            \"Please monitor SOLR-13628 for progress\");\n      }\n      for (int i = 0; i < types.length; i++) {\n        String type = types[i];\n        addRouterTypeOf(type, routerTypes);\n\n        // v2 api case - the v2 -> v1 mapping mechanisms can't handle this conversion because they expect\n        // strings or arrays of strings, not lists of objects.\n        if (props.containsKey(\"router.routerList\")) {\n          @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n          HashMap tmp = new HashMap(props);\n          @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n          List<Map<String, Object>> v2RouterList = (List<Map<String, Object>>) tmp.get(\"router.routerList\");\n          Map<String, Object> o = v2RouterList.get(i);\n          for (Map.Entry<String, Object> entry : o.entrySet()) {\n            props.put(ROUTER_PREFIX + i + \".\" + entry.getKey(), String.valueOf(entry.getValue()));\n          }\n        }\n        // Here we need to push the type into each dimension's params. We could have eschewed the\n        // \"Dimensional[dim1,dim2]\" style notation, to simplify this case but I think it's nice\n        // to be able to understand the dimensionality at a glance without having to hunt for name properties\n        // in the list of properties for each dimension.\n        String typeName = ROUTER_PREFIX + i + \".name\";\n        // can't use computeIfAbsent because the non-dimensional case where typeName is present\n        // happens to be an unmodifiable map and will fail.\n        if (!props.containsKey(typeName)) {\n          props.put(typeName, type);\n        }\n        fields.add(props.get(ROUTER_PREFIX + i + \".field\"));\n      }\n      // this next remove is checked for key because when we build from aliases.json's data it we get an\n      // immutable map which would cause  UnsupportedOperationException to be thrown. This remove is here\n      // to prevent this property from making it into aliases.json\n      if (props.containsKey(\"router.routerList\")) {\n        props.remove(\"router.routerList\");\n      }\n      // Keep code that handles single dimensions happy by providing this value, otherwise ignored.\n      if (!props.containsKey(ROUTER_FIELD)) {\n        props.put(ROUTER_FIELD, String.join(\",\", fields));\n      }\n    } else {\n      // non-dimensional case\n      addRouterTypeOf(typeStr, routerTypes);\n    }\n    if (routerTypes.size() == 1) {\n      RoutedAliasTypes routerType = routerTypes.get(0);\n      return routedAliasForType(aliasName, props, routerType);\n    } else {\n      List<RoutedAlias> dimensions = new ArrayList<>();\n      // this array allows us to get past the chicken/egg problem of needing access to the\n      // DRA inside the dimensions, but needing the dimensions to create the DRA\n      DimensionalRoutedAlias[] dra = new DimensionalRoutedAlias[1];\n      for (int i = 0; i < routerTypes.size(); i++) {\n        RoutedAliasTypes routerType = routerTypes.get(i);\n        // NOTE setting the name to empty string is very important here, as that allows us to simply\n        // concatenate the \"names\" of the parts to get the correct collection name for the DRA\n        dimensions.add(DimensionalRoutedAlias.dimensionForType( selectForIndex(i, props), routerType, i, () -> dra[0]));\n      }\n      return dra[0] = new DimensionalRoutedAlias(dimensions, props.get(CommonParams.NAME), props);\n    }\n  }\n\n","sourceOld":"  /**\n   * Factory method for implementations of this interface. There should be no reason to construct instances\n   * elsewhere, and routed alias types are encouraged to have package private constructors.\n   *\n   * @param aliasName The alias name (will be returned by {@link #getAliasName()}\n   * @param props     The properties from an overseer message.\n   * @return An implementation appropriate for the supplied properties, or null if no type is specified.\n   * @throws SolrException If the properties are invalid or the router type is unknown.\n   */\n  public static RoutedAlias fromProps(String aliasName, Map<String, String> props) throws SolrException {\n\n    String typeStr = props.get(ROUTER_TYPE_NAME);\n    if (typeStr == null) {\n      return null; // non-routed aliases are being created\n    }\n    List<RoutedAliasTypes> routerTypes = new ArrayList<>();\n    // check for Dimensional[foo,bar,baz]\n    if (typeStr.startsWith(DIMENSIONAL)) {\n      // multi-dimensional routed alias\n      typeStr = typeStr.substring(DIMENSIONAL.length(), typeStr.length() - 1);\n      String[] types = typeStr.split(\",\");\n      java.util.List<String> fields = new ArrayList<>();\n      if (types.length > 2) {\n        throw new SolrException(BAD_REQUEST,\"More than 2 dimensions is not supported yet. \" +\n            \"Please monitor SOLR-13628 for progress\");\n      }\n      for (int i = 0; i < types.length; i++) {\n        String type = types[i];\n        addRouterTypeOf(type, routerTypes);\n\n        // v2 api case - the v2 -> v1 mapping mechanisms can't handle this conversion because they expect\n        // strings or arrays of strings, not lists of objects.\n        if (props.containsKey(\"router.routerList\")) {\n          @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n          HashMap tmp = new HashMap(props);\n          @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n          List<Map<String, Object>> v2RouterList = (List<Map<String, Object>>) tmp.get(\"router.routerList\");\n          Map<String, Object> o = v2RouterList.get(i);\n          for (Map.Entry<String, Object> entry : o.entrySet()) {\n            props.put(ROUTER_PREFIX + i + \".\" + entry.getKey(), String.valueOf(entry.getValue()));\n          }\n        }\n        // Here we need to push the type into each dimension's params. We could have eschewed the\n        // \"Dimensional[dim1,dim2]\" style notation, to simplify this case but I think it's nice\n        // to be able to understand the dimensionality at a glance without having to hunt for name properties\n        // in the list of properties for each dimension.\n        String typeName = ROUTER_PREFIX + i + \".name\";\n        // can't use computeIfAbsent because the non-dimensional case where typeName is present\n        // happens to be an unmodifiable map and will fail.\n        if (!props.containsKey(typeName)) {\n          props.put(typeName, type);\n        }\n        fields.add(props.get(ROUTER_PREFIX + i + \".field\"));\n      }\n      // this next remove is checked for key because when we build from aliases.json's data it we get an\n      // immutable map which would cause  UnsupportedOperationException to be thrown. This remove is here\n      // to prevent this property from making it into aliases.json\n      //noinspection RedundantCollectionOperation\n      if (props.containsKey(\"router.routerList\")) {\n        props.remove(\"router.routerList\");\n      }\n      // Keep code that handles single dimensions happy by providing this value, otherwise ignored.\n      if (!props.containsKey(ROUTER_FIELD)) {\n        props.put(ROUTER_FIELD, String.join(\",\", fields));\n      }\n    } else {\n      // non-dimensional case\n      addRouterTypeOf(typeStr, routerTypes);\n    }\n    if (routerTypes.size() == 1) {\n      RoutedAliasTypes routerType = routerTypes.get(0);\n      return routedAliasForType(aliasName, props, routerType);\n    } else {\n      List<RoutedAlias> dimensions = new ArrayList<>();\n      // this array allows us to get past the chicken/egg problem of needing access to the\n      // DRA inside the dimensions, but needing the dimensions to create the DRA\n      DimensionalRoutedAlias[] dra = new DimensionalRoutedAlias[1];\n      for (int i = 0; i < routerTypes.size(); i++) {\n        RoutedAliasTypes routerType = routerTypes.get(i);\n        // NOTE setting the name to empty string is very important here, as that allows us to simply\n        // concatenate the \"names\" of the parts to get the correct collection name for the DRA\n        dimensions.add(DimensionalRoutedAlias.dimensionForType( selectForIndex(i, props), routerType, i, () -> dra[0]));\n      }\n      return dra[0] = new DimensionalRoutedAlias(dimensions, props.get(CommonParams.NAME), props);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eba8995e4d085569e201ecf8bf75d1cb02fa74bf":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"b627755385655c7cd3fb296f17593658805cf4d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["b627755385655c7cd3fb296f17593658805cf4d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eba8995e4d085569e201ecf8bf75d1cb02fa74bf"]},"commit2Childs":{"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["eba8995e4d085569e201ecf8bf75d1cb02fa74bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b627755385655c7cd3fb296f17593658805cf4d5"],"eba8995e4d085569e201ecf8bf75d1cb02fa74bf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b627755385655c7cd3fb296f17593658805cf4d5":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}