{"path":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","commits":[{"id":"28088b0a688977b79dec2cc9119cff2fb4aab7ee","date":1321197996,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final IndexDocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        assert arr != null;\n        if (arr instanceof byte[]) {\n          // 8 bit packed\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          // 16 bit packed\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          // 32 bit packed\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n      }\n\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, docBase);\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c577254a6bc9c287cd0d54c0f9227af0f59d06f6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c577254a6bc9c287cd0d54c0f9227af0f59d06f6","date":1321384628,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final IndexDocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        assert arr != null;\n        if (arr instanceof byte[]) {\n          // 8 bit packed\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          // 16 bit packed\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          // 32 bit packed\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n      }\n\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, docBase);\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final IndexDocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        assert arr != null;\n        if (arr instanceof byte[]) {\n          // 8 bit packed\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          // 16 bit packed\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          // 32 bit packed\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n      }\n\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, docBase);\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":["28088b0a688977b79dec2cc9119cff2fb4aab7ee"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b78413670e9b208da66999360aa5dc09ed36436e","date":1323277658,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final IndexDocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final IndexDocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        assert arr != null;\n        if (arr instanceof byte[]) {\n          // 8 bit packed\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          // 16 bit packed\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          // 32 bit packed\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n      }\n\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, docBase);\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final DocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final IndexDocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final DocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final IndexDocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = IndexDocValues.getDefaultSortedSource(ValueType.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n      if (docToOrd.hasArray()) {\n        final Object arr = docToOrd.getArray();\n        assert arr != null;\n        if (arr instanceof byte[]) {\n          // 8 bit packed\n          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n        } else if (arr instanceof short[]) {\n          // 16 bit packed\n          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n        } else if (arr instanceof int[]) {\n          // 32 bit packed\n          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n        }\n      }\n\n      if (perSegComp == null) {\n        perSegComp = new AnyOrdComparator(docToOrd, docBase);\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6fff8f4b218bd0626afcdce82027bafeb84a50a4","date":1327229950,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final DocValues dv = context.reader().docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader().maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader());\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final DocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final DocValues dv = context.reader().docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader().maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader());\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final DocValues dv = context.reader.docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader.maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader);\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldComparator.TermOrdValDocValuesComparator#setNextReader(AtomicReaderContext).mjava","sourceNew":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final DocValues dv = context.reader().docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader().maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader());\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","sourceOld":"    @Override\n    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n      final int docBase = context.docBase;\n\n      final DocValues dv = context.reader().docValues(field);\n      if (dv == null) {\n        // This may mean entire segment had no docs with\n        // this DV field; use default field value (empty\n        // byte[]) in this case:\n        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader().maxDoc());\n      } else {\n        termsIndex = dv.getSource().asSortedSource();\n        if (termsIndex == null) {\n          // This means segment has doc values, but they are\n          // not able to provide a sorted source; consider\n          // this a hard error:\n          throw new IllegalStateException(\"DocValues exist for field \\\"\" + field + \"\\\", but not as a sorted source: type=\" + dv.getSource().type() + \" reader=\" + context.reader());\n        }\n      }\n\n      comp = termsIndex.getComparator();\n\n      FieldComparator perSegComp = null;\n      if (termsIndex.hasPackedDocToOrd()) {\n        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();\n        if (docToOrd.hasArray()) {\n          final Object arr = docToOrd.getArray();\n          assert arr != null;\n          if (arr instanceof byte[]) {\n            // 8 bit packed\n            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);\n          } else if (arr instanceof short[]) {\n            // 16 bit packed\n            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);\n          } else if (arr instanceof int[]) {\n            // 32 bit packed\n            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);\n          }\n        }\n\n        if (perSegComp == null) {\n          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);\n        }\n      } else {\n        if (perSegComp == null) {\n          perSegComp = new AnyOrdComparator(docBase);\n        }\n      }\n        \n      currentReaderGen++;\n      if (bottomSlot != -1) {\n        perSegComp.setBottom(bottomSlot);\n      }\n\n      return perSegComp;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c577254a6bc9c287cd0d54c0f9227af0f59d06f6":["28088b0a688977b79dec2cc9119cff2fb4aab7ee"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["b78413670e9b208da66999360aa5dc09ed36436e"],"b78413670e9b208da66999360aa5dc09ed36436e":["c577254a6bc9c287cd0d54c0f9227af0f59d06f6"],"28088b0a688977b79dec2cc9119cff2fb4aab7ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["d638301ad1cfcae567b681b893bc8781f0ee48a5","6fff8f4b218bd0626afcdce82027bafeb84a50a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["c577254a6bc9c287cd0d54c0f9227af0f59d06f6","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"]},"commit2Childs":{"c577254a6bc9c287cd0d54c0f9227af0f59d06f6":["b78413670e9b208da66999360aa5dc09ed36436e","d638301ad1cfcae567b681b893bc8781f0ee48a5"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["28088b0a688977b79dec2cc9119cff2fb4aab7ee"],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"b78413670e9b208da66999360aa5dc09ed36436e":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"28088b0a688977b79dec2cc9119cff2fb4aab7ee":["c577254a6bc9c287cd0d54c0f9227af0f59d06f6"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["6fff8f4b218bd0626afcdce82027bafeb84a50a4","5cab9a86bd67202d20b6adc463008c8e982b070a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}