{"path":"lucene/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","commits":[{"id":"5eae7c5ddae4b9692a6691d2d252ab6a4229457b","date":1325870827,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases ,int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(int[],int[][],SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases ,int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(int[] docBases ,int[][] docMaps,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == docBases[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final int numDocs = currentSlice.docToOrdEnd - currentSlice.docToOrdStart;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5eae7c5ddae4b9692a6691d2d252ab6a4229457b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5eae7c5ddae4b9692a6691d2d252ab6a4229457b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eae7c5ddae4b9692a6691d2d252ab6a4229457b"],"5eae7c5ddae4b9692a6691d2d252ab6a4229457b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}