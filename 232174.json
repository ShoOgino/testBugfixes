{"path":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","commits":[{"id":"6ecd298fdc085e7eba27afa7fae58df1ba1a2808","date":1295102557,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(stats, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"510b1bab59313a7f87bbe48f2e273db6ca9d3f67","date":1295109995,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      wrappedPostingsWriter.finishTerm(stats, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(stats, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16843358872ed92ba92888ab99df297550b9a36a","date":1295144724,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(int,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      wrappedPostingsWriter.finishTerm(stats, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(int docCount, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      termsOut.writeByte((byte) 0);\n      wrappedPostingsWriter.finishTerm(docCount, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      termsOut.writeByte((byte) 1);\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1add9ddc0005b07550d4350720aac22dc9886b3","date":1295549635,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + stats.docFreq);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    if (pendingCount == -1) {\n      wrappedPostingsWriter.finishTerm(stats);\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      buffer2.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(buffer2);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      wrappedPostingsWriter.finishTerm(stats, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":5,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriterImpl#finishTerm(TermStats,boolean).mjava","sourceNew":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + stats.docFreq);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    if (pendingCount == -1) {\n      wrappedPostingsWriter.finishTerm(stats);\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      buffer2.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(buffer2);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","sourceOld":"  /** Called when we are done adding docs to this term */\n  @Override\n  public void finishTerm(TermStats stats, boolean isIndexTerm) throws IOException {\n    //System.out.println(\"PW   finishTerm docCount=\" + docCount);\n\n    assert pendingCount > 0 || pendingCount == -1;\n\n    pendingIsIndexTerm |= isIndexTerm;\n\n    if (pendingCount == -1) {\n      wrappedPostingsWriter.finishTerm(stats, pendingIsIndexTerm);\n      pendingIsIndexTerm = false;\n    } else {\n\n      // There were few enough total occurrences for this\n      // term, so we fully inline our postings data into\n      // terms dict, now:\n\n      // TODO: it'd be better to share this encoding logic\n      // in some inner codec that knows how to write a\n      // single doc / single position, etc.  This way if a\n      // given codec wants to store other interesting\n      // stuff, it could use this pulsing codec to do so\n\n      if (!omitTF) {\n        int lastDocID = 0;\n        int pendingIDX = 0;\n        while(pendingIDX < pendingCount) {\n          final Position doc = pending[pendingIDX];\n\n          final int delta = doc.docID - lastDocID;\n          lastDocID = doc.docID;\n\n          //System.out.println(\"  write doc=\" + doc.docID + \" freq=\" + doc.termFreq);\n\n          if (doc.termFreq == 1) {\n            buffer.writeVInt((delta<<1)|1);\n          } else {\n            buffer.writeVInt(delta<<1);\n            buffer.writeVInt(doc.termFreq);\n          }\n\n          int lastPos = 0;\n          int lastPayloadLength = -1;\n          for(int posIDX=0;posIDX<doc.termFreq;posIDX++) {\n            final Position pos = pending[pendingIDX++];\n            assert pos.docID == doc.docID;\n            final int posDelta = pos.pos - lastPos;\n            lastPos = pos.pos;\n            //System.out.println(\"    write pos=\" + pos.pos);\n            if (storePayloads) {\n              final int payloadLength = pos.payload == null ? 0 : pos.payload.length;\n              if (payloadLength != lastPayloadLength) {\n                buffer.writeVInt((posDelta << 1)|1);\n                buffer.writeVInt(payloadLength);\n                lastPayloadLength = payloadLength;\n              } else {\n                buffer.writeVInt(posDelta << 1);\n              }\n              if (payloadLength > 0) {\n                buffer.writeBytes(pos.payload.bytes, 0, pos.payload.length);\n              }\n            } else {\n              buffer.writeVInt(posDelta);\n            }\n          }\n        }\n      } else {\n        int lastDocID = 0;\n        for(int posIDX=0;posIDX<pendingCount;posIDX++) {\n          final Position doc = pending[posIDX];\n          buffer.writeVInt(doc.docID - lastDocID);\n          lastDocID = doc.docID;\n        }\n      }\n      \n      //System.out.println(\"  bytes=\" + buffer.getFilePointer());\n      termsOut.writeVInt((int) buffer.getFilePointer());\n      buffer.writeTo(termsOut);\n      buffer.reset();\n    }\n\n    pendingCount = 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"510b1bab59313a7f87bbe48f2e273db6ca9d3f67":["6ecd298fdc085e7eba27afa7fae58df1ba1a2808"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"16843358872ed92ba92888ab99df297550b9a36a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","510b1bab59313a7f87bbe48f2e273db6ca9d3f67"],"b1add9ddc0005b07550d4350720aac22dc9886b3":["510b1bab59313a7f87bbe48f2e273db6ca9d3f67"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["16843358872ed92ba92888ab99df297550b9a36a","b1add9ddc0005b07550d4350720aac22dc9886b3"],"6ecd298fdc085e7eba27afa7fae58df1ba1a2808":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1add9ddc0005b07550d4350720aac22dc9886b3"]},"commit2Childs":{"510b1bab59313a7f87bbe48f2e273db6ca9d3f67":["16843358872ed92ba92888ab99df297550b9a36a","b1add9ddc0005b07550d4350720aac22dc9886b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["16843358872ed92ba92888ab99df297550b9a36a","6ecd298fdc085e7eba27afa7fae58df1ba1a2808"],"16843358872ed92ba92888ab99df297550b9a36a":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"b1add9ddc0005b07550d4350720aac22dc9886b3":["e79a6d080bdd5b2a8f56342cf571b5476de04180","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":[],"6ecd298fdc085e7eba27afa7fae58df1ba1a2808":["510b1bab59313a7f87bbe48f2e273db6ca9d3f67"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e79a6d080bdd5b2a8f56342cf571b5476de04180","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}