{"path":"solr/core/src/java/org/apache/solr/handler/export/ExportBuffers#ExportBuffers(ExportWriter,List[LeafReaderContext],SolrIndexSearcher,OutputStream,IteratorWriter.ItemWriter,Sort,int,int,Timer,Timer,Timer).mjava","commits":[{"id":"1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee","date":1593704090,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/export/ExportBuffers#ExportBuffers(ExportWriter,List[LeafReaderContext],SolrIndexSearcher,OutputStream,IteratorWriter.ItemWriter,Sort,int,int,Timer,Timer,Timer).mjava","pathOld":"/dev/null","sourceNew":"  ExportBuffers(ExportWriter exportWriter, List<LeafReaderContext> leaves, SolrIndexSearcher searcher,\n                OutputStream os, IteratorWriter.ItemWriter rawWriter, Sort sort, int queueSize, int totalHits,\n                Timer writeOutputBufferTimer, Timer fillerWaitTimer, Timer writerWaitTimer) throws IOException {\n    this.exportWriter = exportWriter;\n    this.leaves = leaves;\n    this.os = os;\n    this.rawWriter = rawWriter;\n    this.writer = new IteratorWriter.ItemWriter() {\n      @Override\n      public IteratorWriter.ItemWriter add(Object o) throws IOException {\n        rawWriter.add(o);\n        outputCounter.increment();\n        return this;\n      }\n    };\n    this.writeOutputBufferTimer = writeOutputBufferTimer;\n    this.fillerWaitTimer = fillerWaitTimer;\n    this.writerWaitTimer = writerWaitTimer;\n    this.bufferOne = new Buffer(queueSize);\n    this.bufferTwo = new Buffer(queueSize);\n    this.totalHits = totalHits;\n    fillBuffer = bufferOne;\n    outputBuffer = bufferTwo;\n    SortDoc writerSortDoc = exportWriter.getSortDoc(searcher, sort.getSort());\n    bufferOne.initialize(writerSortDoc);\n    bufferTwo.initialize(writerSortDoc);\n    barrier = new CyclicBarrier(2, () -> swapBuffers());\n    filler = () -> {\n      try {\n        log.debug(\"--- filler start {}\", Thread.currentThread());\n        SortDoc sortDoc = exportWriter.getSortDoc(searcher, sort.getSort());\n        Buffer buffer = getFillBuffer();\n        SortQueue queue = new SortQueue(queueSize, sortDoc);\n        long lastOutputCounter = 0;\n        for (int count = 0; count < totalHits; ) {\n          log.debug(\"--- filler fillOutDocs in {}\", fillBuffer);\n          exportWriter.fillOutDocs(leaves, sortDoc, queue, buffer);\n          count += (buffer.outDocsIndex + 1);\n          log.debug(\"--- filler count={}, exchange buffer from {}\", count, buffer);\n          Timer.Context timerContext = getFillerWaitTimer().time();\n          try {\n            exchangeBuffers();\n          } finally {\n            timerContext.stop();\n          }\n          buffer = getFillBuffer();\n          if (outputCounter.longValue() > lastOutputCounter) {\n            lastOutputCounter = outputCounter.longValue();\n            flushOutput();\n          }\n          log.debug(\"--- filler got empty buffer {}\", buffer);\n        }\n        buffer.outDocsIndex = Buffer.NO_MORE_DOCS;\n        log.debug(\"--- filler final exchange buffer from {}\", buffer);\n        Timer.Context timerContext = getFillerWaitTimer().time();\n        try {\n          exchangeBuffers();\n        } finally {\n          timerContext.stop();\n        }\n        buffer = getFillBuffer();\n        log.debug(\"--- filler final got buffer {}\", buffer);\n      } catch (Throwable e) {\n        log.error(\"filler\", e);\n        error(e);\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt();\n        }\n        shutdownNow();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11b8c26c13b294e143adb7359d48c525f7052def","date":1593853283,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/export/ExportBuffers#ExportBuffers(ExportWriter,List[LeafReaderContext],SolrIndexSearcher,OutputStream,IteratorWriter.ItemWriter,Sort,int,int,Timer,Timer,Timer).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/export/ExportBuffers#ExportBuffers(ExportWriter,List[LeafReaderContext],SolrIndexSearcher,OutputStream,IteratorWriter.ItemWriter,Sort,int,int,Timer,Timer,Timer).mjava","sourceNew":"  ExportBuffers(ExportWriter exportWriter, List<LeafReaderContext> leaves, SolrIndexSearcher searcher,\n                OutputStream os, IteratorWriter.ItemWriter rawWriter, Sort sort, int queueSize, int totalHits,\n                Timer writeOutputBufferTimer, Timer fillerWaitTimer, Timer writerWaitTimer) throws IOException {\n    this.exportWriter = exportWriter;\n    this.leaves = leaves;\n    this.os = os;\n    this.rawWriter = rawWriter;\n    this.writer = new IteratorWriter.ItemWriter() {\n      @Override\n      public IteratorWriter.ItemWriter add(Object o) throws IOException {\n        rawWriter.add(o);\n        outputCounter.increment();\n        return this;\n      }\n    };\n    this.writeOutputBufferTimer = writeOutputBufferTimer;\n    this.fillerWaitTimer = fillerWaitTimer;\n    this.writerWaitTimer = writerWaitTimer;\n    this.bufferOne = new Buffer(queueSize);\n    this.bufferTwo = new Buffer(queueSize);\n    this.totalHits = totalHits;\n    fillBuffer = bufferOne;\n    outputBuffer = bufferTwo;\n    SortDoc writerSortDoc = exportWriter.getSortDoc(searcher, sort.getSort());\n    bufferOne.initialize(writerSortDoc);\n    bufferTwo.initialize(writerSortDoc);\n    barrier = new CyclicBarrier(2, () -> swapBuffers());\n    filler = () -> {\n      try {\n        // log.debug(\"--- filler start {}\", Thread.currentThread());\n        SortDoc sortDoc = exportWriter.getSortDoc(searcher, sort.getSort());\n        Buffer buffer = getFillBuffer();\n        SortQueue queue = new SortQueue(queueSize, sortDoc);\n        long lastOutputCounter = 0;\n        for (int count = 0; count < totalHits; ) {\n          // log.debug(\"--- filler fillOutDocs in {}\", fillBuffer);\n          exportWriter.fillOutDocs(leaves, sortDoc, queue, buffer);\n          count += (buffer.outDocsIndex + 1);\n          // log.debug(\"--- filler count={}, exchange buffer from {}\", count, buffer);\n          Timer.Context timerContext = getFillerWaitTimer().time();\n          try {\n            exchangeBuffers();\n          } finally {\n            timerContext.stop();\n          }\n          buffer = getFillBuffer();\n          if (outputCounter.longValue() > lastOutputCounter) {\n            lastOutputCounter = outputCounter.longValue();\n            flushOutput();\n          }\n          // log.debug(\"--- filler got empty buffer {}\", buffer);\n        }\n        buffer.outDocsIndex = Buffer.NO_MORE_DOCS;\n        // log.debug(\"--- filler final exchange buffer from {}\", buffer);\n        Timer.Context timerContext = getFillerWaitTimer().time();\n        try {\n          exchangeBuffers();\n        } finally {\n          timerContext.stop();\n        }\n        buffer = getFillBuffer();\n        // log.debug(\"--- filler final got buffer {}\", buffer);\n      } catch (Throwable e) {\n        log.error(\"filler\", e);\n        error(e);\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt();\n        }\n        shutdownNow();\n      }\n    };\n  }\n\n","sourceOld":"  ExportBuffers(ExportWriter exportWriter, List<LeafReaderContext> leaves, SolrIndexSearcher searcher,\n                OutputStream os, IteratorWriter.ItemWriter rawWriter, Sort sort, int queueSize, int totalHits,\n                Timer writeOutputBufferTimer, Timer fillerWaitTimer, Timer writerWaitTimer) throws IOException {\n    this.exportWriter = exportWriter;\n    this.leaves = leaves;\n    this.os = os;\n    this.rawWriter = rawWriter;\n    this.writer = new IteratorWriter.ItemWriter() {\n      @Override\n      public IteratorWriter.ItemWriter add(Object o) throws IOException {\n        rawWriter.add(o);\n        outputCounter.increment();\n        return this;\n      }\n    };\n    this.writeOutputBufferTimer = writeOutputBufferTimer;\n    this.fillerWaitTimer = fillerWaitTimer;\n    this.writerWaitTimer = writerWaitTimer;\n    this.bufferOne = new Buffer(queueSize);\n    this.bufferTwo = new Buffer(queueSize);\n    this.totalHits = totalHits;\n    fillBuffer = bufferOne;\n    outputBuffer = bufferTwo;\n    SortDoc writerSortDoc = exportWriter.getSortDoc(searcher, sort.getSort());\n    bufferOne.initialize(writerSortDoc);\n    bufferTwo.initialize(writerSortDoc);\n    barrier = new CyclicBarrier(2, () -> swapBuffers());\n    filler = () -> {\n      try {\n        log.debug(\"--- filler start {}\", Thread.currentThread());\n        SortDoc sortDoc = exportWriter.getSortDoc(searcher, sort.getSort());\n        Buffer buffer = getFillBuffer();\n        SortQueue queue = new SortQueue(queueSize, sortDoc);\n        long lastOutputCounter = 0;\n        for (int count = 0; count < totalHits; ) {\n          log.debug(\"--- filler fillOutDocs in {}\", fillBuffer);\n          exportWriter.fillOutDocs(leaves, sortDoc, queue, buffer);\n          count += (buffer.outDocsIndex + 1);\n          log.debug(\"--- filler count={}, exchange buffer from {}\", count, buffer);\n          Timer.Context timerContext = getFillerWaitTimer().time();\n          try {\n            exchangeBuffers();\n          } finally {\n            timerContext.stop();\n          }\n          buffer = getFillBuffer();\n          if (outputCounter.longValue() > lastOutputCounter) {\n            lastOutputCounter = outputCounter.longValue();\n            flushOutput();\n          }\n          log.debug(\"--- filler got empty buffer {}\", buffer);\n        }\n        buffer.outDocsIndex = Buffer.NO_MORE_DOCS;\n        log.debug(\"--- filler final exchange buffer from {}\", buffer);\n        Timer.Context timerContext = getFillerWaitTimer().time();\n        try {\n          exchangeBuffers();\n        } finally {\n          timerContext.stop();\n        }\n        buffer = getFillBuffer();\n        log.debug(\"--- filler final got buffer {}\", buffer);\n      } catch (Throwable e) {\n        log.error(\"filler\", e);\n        error(e);\n        if (e instanceof InterruptedException) {\n          Thread.currentThread().interrupt();\n        }\n        shutdownNow();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"11b8c26c13b294e143adb7359d48c525f7052def":["1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee"],"1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["11b8c26c13b294e143adb7359d48c525f7052def"]},"commit2Childs":{"11b8c26c13b294e143adb7359d48c525f7052def":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee":["11b8c26c13b294e143adb7359d48c525f7052def"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d810b19e2ed4ec2e2b3d79844c7d5dea82794ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}