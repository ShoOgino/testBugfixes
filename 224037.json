{"path":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int n) throws IOException {\n    return search(createNormalizedWeight(query), after, n);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int n) throws IOException {\n    return search(createNormalizedWeight(query), after, n);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int n) throws IOException {\n    return search(createNormalizedWeight(query), after, n);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int n) throws IOException {\n    return search(createNormalizedWeight(query), after, n);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    if (executor == null) {\n      final TopScoreDocCollector collector = TopScoreDocCollector.create(numHits, after);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopScoreDocCollector[] collectors = new TopScoreDocCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopScoreDocCollector.create(numHits, after);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopScoreDocCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopDocs>() {\n          @Override\n          public TopDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopDocs[] topDocs = new TopDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(numHits, topDocs);\n    }\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int n) throws IOException {\n    return search(createNormalizedWeight(query), after, n);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"954e59be3da8dc1b046646ad7af4b466852009d3","date":1423482367,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    if (executor == null) {\n      final TopScoreDocCollector collector = TopScoreDocCollector.create(numHits, after);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopScoreDocCollector[] collectors = new TopScoreDocCollector[leafSlices.length];\n      int postingsFlags = PostingsEnum.FLAG_NONE;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopScoreDocCollector.create(numHits, after);\n        if (collectors[i].needsScores())\n          postingsFlags |= PostingsEnum.FLAG_FREQS;\n      }\n\n      final Weight weight = createNormalizedWeight(query, postingsFlags);\n      final List<Future<TopDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopScoreDocCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopDocs>() {\n          @Override\n          public TopDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopDocs[] topDocs = new TopDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(numHits, topDocs);\n    }\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    if (executor == null) {\n      final TopScoreDocCollector collector = TopScoreDocCollector.create(numHits, after);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopScoreDocCollector[] collectors = new TopScoreDocCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopScoreDocCollector.create(numHits, after);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopScoreDocCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopDocs>() {\n          @Override\n          public TopDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopDocs[] topDocs = new TopDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(numHits, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a47d642ab24da1a811adce4bda9cc52c520ca13","date":1423483323,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    if (executor == null) {\n      final TopScoreDocCollector collector = TopScoreDocCollector.create(numHits, after);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopScoreDocCollector[] collectors = new TopScoreDocCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopScoreDocCollector.create(numHits, after);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopScoreDocCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopDocs>() {\n          @Override\n          public TopDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopDocs[] topDocs = new TopDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(numHits, topDocs);\n    }\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    if (executor == null) {\n      final TopScoreDocCollector collector = TopScoreDocCollector.create(numHits, after);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopScoreDocCollector[] collectors = new TopScoreDocCollector[leafSlices.length];\n      int postingsFlags = PostingsEnum.FLAG_NONE;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopScoreDocCollector.create(numHits, after);\n        if (collectors[i].needsScores())\n          postingsFlags |= PostingsEnum.FLAG_FREQS;\n      }\n\n      final Weight weight = createNormalizedWeight(query, postingsFlags);\n      final List<Future<TopDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopScoreDocCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopDocs>() {\n          @Override\n          public TopDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopDocs[] topDocs = new TopDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(numHits, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"308eabc0d18aa58a75b0a130d08524e98661807b","date":1425056617,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    if (executor == null) {\n      final TopScoreDocCollector collector = TopScoreDocCollector.create(numHits, after);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopScoreDocCollector[] collectors = new TopScoreDocCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopScoreDocCollector.create(numHits, after);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopScoreDocCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopDocs>() {\n          @Override\n          public TopDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopDocs[] topDocs = new TopDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(numHits, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    if (executor == null) {\n      final TopScoreDocCollector collector = TopScoreDocCollector.create(numHits, after);\n      search(query, collector);\n      return collector.topDocs();\n    } else {\n      final TopScoreDocCollector[] collectors = new TopScoreDocCollector[leafSlices.length];\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        collectors[i] = TopScoreDocCollector.create(numHits, after);\n        needsScores |= collectors[i].needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<TopDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final TopScoreDocCollector collector = collectors[i];\n        topDocsFutures.add(executor.submit(new Callable<TopDocs>() {\n          @Override\n          public TopDocs call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector.topDocs();\n          }\n        }));\n      }\n\n      final TopDocs[] topDocs = new TopDocs[leafSlices.length];\n      for (int i = 0; i < topDocs.length; ++i) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return TopDocs.merge(numHits, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a5b816df64f2b489d1e711be80f9416f9862c1b","date":1487973679,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"561792440e4f0b973fc254e639df1ce2d6b88b0a","date":1490791706,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dba5b5b372fde605473eb1e87830355faf41833e","date":1490873947,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n    numHits = Math.min(numHits, limit);\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, true);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, true);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, Integer.MAX_VALUE);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, true);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e708f948b384f9aa85c665caee4486eb2d9e197d","date":1533106881,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, Integer.MAX_VALUE);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36c70eb3b44de4355a7168b762cadc0f1cf194bc","date":1561542955,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws BooleanQuery.TooManyClauses If a query would exceed \n   *         {@link BooleanQuery#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36510a8e3c1ec60d366b45f8f716e9dc47589661","date":1561989412,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4f6b0fb6f08ac48f438f03002a283a63cb9992","date":1561992803,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fccd4a691aac1aff06ab8110d8693514a34160c3","date":1562092518,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs, true);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, TOTAL_HITS_THRESHOLD);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09bee0b4882762434fd0b5095fc34ee6058442e1","date":1569398789,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74844ead01492c17079ed382d0924f4df2fa72e3","date":1569970726,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final BottomValueChecker bottomValueChecker = (executor == null || leafSlices.length <= 1) ? null : BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final MaxScoreAccumulator minScoreAcc = (executor == null || leafSlices.length <= 1) ? null : new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final BottomValueChecker bottomValueChecker = (executor == null || leafSlices.length <= 1) ? null : BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final MaxScoreAccumulator minScoreAcc = (executor == null || leafSlices.length <= 1) ? null : new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final BottomValueChecker bottomValueChecker = BottomValueChecker.createMaxBottomScoreChecker();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, bottomValueChecker);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60a97329527e682292497dd2f6fae1c519840bae","date":1587668642,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#searchAfter(ScoreDoc,Query,int).mjava","sourceNew":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(Math.max(TOTAL_HITS_THRESHOLD, numHits)) :\n          HitsThresholdChecker.createShared(Math.max(TOTAL_HITS_THRESHOLD, numHits));\n\n      private final MaxScoreAccumulator minScoreAcc = (executor == null || leafSlices.length <= 1) ? null : new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","sourceOld":"  /** Finds the top <code>n</code>\n   * hits for <code>query</code> where all results are after a previous \n   * result (<code>after</code>).\n   * <p>\n   * By passing the bottom result from a previous page as <code>after</code>,\n   * this method can be used for efficient 'deep-paging' across potentially\n   * large result sets.\n   *\n   * @throws TooManyClauses If a query would exceed\n   *         {@link IndexSearcher#getMaxClauseCount()} clauses.\n   */\n  public TopDocs searchAfter(ScoreDoc after, Query query, int numHits) throws IOException {\n    final int limit = Math.max(1, reader.maxDoc());\n    if (after != null && after.doc >= limit) {\n      throw new IllegalArgumentException(\"after.doc exceeds the number of documents in the reader: after.doc=\"\n          + after.doc + \" limit=\" + limit);\n    }\n\n    final int cappedNumHits = Math.min(numHits, limit);\n\n    final CollectorManager<TopScoreDocCollector, TopDocs> manager = new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n      private final HitsThresholdChecker hitsThresholdChecker = (executor == null || leafSlices.length <= 1) ? HitsThresholdChecker.create(TOTAL_HITS_THRESHOLD) :\n          HitsThresholdChecker.createShared(TOTAL_HITS_THRESHOLD);\n\n      private final MaxScoreAccumulator minScoreAcc = (executor == null || leafSlices.length <= 1) ? null : new MaxScoreAccumulator();\n\n      @Override\n      public TopScoreDocCollector newCollector() throws IOException {\n        return TopScoreDocCollector.create(cappedNumHits, after, hitsThresholdChecker, minScoreAcc);\n      }\n\n      @Override\n      public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n        final TopDocs[] topDocs = new TopDocs[collectors.size()];\n        int i = 0;\n        for (TopScoreDocCollector collector : collectors) {\n          topDocs[i++] = collector.topDocs();\n        }\n        return TopDocs.merge(0, cappedNumHits, topDocs);\n      }\n\n    };\n\n    return search(query, manager);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"6a47d642ab24da1a811adce4bda9cc52c520ca13":["954e59be3da8dc1b046646ad7af4b466852009d3"],"fb17639909a369c1e64866842e5c213440acc17e":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"e708f948b384f9aa85c665caee4486eb2d9e197d":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dba5b5b372fde605473eb1e87830355faf41833e":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"308eabc0d18aa58a75b0a130d08524e98661807b":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6a47d642ab24da1a811adce4bda9cc52c520ca13","308eabc0d18aa58a75b0a130d08524e98661807b"],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["308eabc0d18aa58a75b0a130d08524e98661807b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9fc47cb7b4346802411bb432f501ed0673d7119e":["561792440e4f0b973fc254e639df1ce2d6b88b0a"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["417142ff08fda9cf0b72d5133e63097a166c6458"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"807314aa41c10866aec273a0e54fd0d24d8971de":["74844ead01492c17079ed382d0924f4df2fa72e3"],"954e59be3da8dc1b046646ad7af4b466852009d3":["fb17639909a369c1e64866842e5c213440acc17e"],"417142ff08fda9cf0b72d5133e63097a166c6458":["561792440e4f0b973fc254e639df1ce2d6b88b0a","9fc47cb7b4346802411bb432f501ed0673d7119e"],"36510a8e3c1ec60d366b45f8f716e9dc47589661":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"561792440e4f0b973fc254e639df1ce2d6b88b0a":["9a5b816df64f2b489d1e711be80f9416f9862c1b"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["09bee0b4882762434fd0b5095fc34ee6058442e1","807314aa41c10866aec273a0e54fd0d24d8971de"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"60a97329527e682292497dd2f6fae1c519840bae":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"74844ead01492c17079ed382d0924f4df2fa72e3":["09bee0b4882762434fd0b5095fc34ee6058442e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60a97329527e682292497dd2f6fae1c519840bae"],"09bee0b4882762434fd0b5095fc34ee6058442e1":["e19eef45a852c3316ae52fdf941731448ece967a"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["09bee0b4882762434fd0b5095fc34ee6058442e1"],"6a47d642ab24da1a811adce4bda9cc52c520ca13":["308eabc0d18aa58a75b0a130d08524e98661807b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"fb17639909a369c1e64866842e5c213440acc17e":["954e59be3da8dc1b046646ad7af4b466852009d3"],"e708f948b384f9aa85c665caee4486eb2d9e197d":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"dba5b5b372fde605473eb1e87830355faf41833e":[],"308eabc0d18aa58a75b0a130d08524e98661807b":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9a5b816df64f2b489d1e711be80f9416f9862c1b"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"9a5b816df64f2b489d1e711be80f9416f9862c1b":["dba5b5b372fde605473eb1e87830355faf41833e","561792440e4f0b973fc254e639df1ce2d6b88b0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["fb17639909a369c1e64866842e5c213440acc17e"],"807314aa41c10866aec273a0e54fd0d24d8971de":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"954e59be3da8dc1b046646ad7af4b466852009d3":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"417142ff08fda9cf0b72d5133e63097a166c6458":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"36510a8e3c1ec60d366b45f8f716e9dc47589661":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"561792440e4f0b973fc254e639df1ce2d6b88b0a":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["60a97329527e682292497dd2f6fae1c519840bae"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["e19eef45a852c3316ae52fdf941731448ece967a"],"60a97329527e682292497dd2f6fae1c519840bae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"74844ead01492c17079ed382d0924f4df2fa72e3":["807314aa41c10866aec273a0e54fd0d24d8971de"],"09bee0b4882762434fd0b5095fc34ee6058442e1":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","74844ead01492c17079ed382d0924f4df2fa72e3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dba5b5b372fde605473eb1e87830355faf41833e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}