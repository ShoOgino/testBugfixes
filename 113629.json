{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","commits":[{"id":"70285ef5917fa2c8feec026d4be4d9c20fa89162","date":1401366288,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * <p>\n   * <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValueType();\n      if (dvType == null) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateDocValues\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c48871ed951104729f5e17a8ee1091b43fa18980"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValueType();\n      if (dvType == null) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateDocValues\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * <p>\n   * <b>NOTE</b>: if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValueType();\n      if (dvType == null) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateDocValues\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["c48871ed951104729f5e17a8ee1091b43fa18980"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2bb2842e561df4e8e9ad89010605fc86ac265465","date":1414768208,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValueType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NO) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateDocValues\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValueType();\n      if (dvType == null) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateDocValues\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f95ce1375367b92d411a06175eab3915fe93c6bc","date":1414788502,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValueType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateDocValues\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValueType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NO) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateDocValues\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e","date":1415435053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateDocValues\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValueType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateDocValues\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c48871ed951104729f5e17a8ee1091b43fa18980","date":1446564542,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateDocValues\");\n    }\n  }\n\n","bugFix":["949847c0040cd70a68222d526cb0da7bf6cbb3c2","70285ef5917fa2c8feec026d4be4d9c20fa89162"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad0d09e969f4763b0df4230f8e3f74357872a4e4","date":1459188769,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType cannot be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n    }\n  }\n\n","bugFix":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23a29a4862e38cc3b9bff14a888901c7c878885b","date":1464135767,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16ebfabc294f23b88b6a39722a02c9d39b353195","date":1464343867,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      if (docWriter.updateDocValues(dvUpdates)) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65233715955663909ad948e05aa3fed614f4a57b","date":1481324713,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"110125c995236a7f61057dd04b039ed2d267f3a1","date":1521014987,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates, true);\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = new DocValuesUpdate[updates.length];\n    for (int i = 0; i < updates.length; i++) {\n      final Field f = updates[i];\n      final DocValuesType dvType = f.fieldType().docValuesType();\n      if (dvType == null) {\n        throw new NullPointerException(\"DocValuesType must not be null (field: \\\"\" + f.name() + \"\\\")\");\n      }\n      if (dvType == DocValuesType.NONE) {\n        throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields! field=\" + f.name());\n      }\n      if (!globalFieldNumberMap.contains(f.name(), dvType)) {\n        throw new IllegalArgumentException(\"can only update existing docvalues fields! field=\" + f.name() + \", type=\" + dvType);\n      }\n      if (config.getIndexSortFields().contains(f.name())) {\n        throw new IllegalArgumentException(\"cannot update docvalues field involved in the index sort, field=\" + f.name() + \", sort=\" + config.getIndexSort());\n      }\n      switch (dvType) {\n        case NUMERIC:\n          dvUpdates[i] = new NumericDocValuesUpdate(term, f.name(), (Long) f.numericValue());\n          break;\n        case BINARY:\n          dvUpdates[i] = new BinaryDocValuesUpdate(term, f.name(), f.binaryValue());\n          break;\n        default:\n          throw new IllegalArgumentException(\"can only update NUMERIC or BINARY fields: field=\" + f.name() + \", type=\" + dvType);\n      }\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates, true);\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n      throw tragedy;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates, true);\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36d13f271b6649357e07f71f7e46559479f69b5b","date":1523888226,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates);\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n      throw tragedy;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates, true);\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n      throw tragedy;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33adea025f43af3243278587a46b8d9fd2e8ccf9","date":1525885077,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together. If a doc values fields data is <code>null</code> the existing\n   * value is removed from all documents matching the term.\n   *\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates);\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n      throw tragedy;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together.\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates);\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n      throw tragedy;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a9b6ed5e493fd780f940f307e17673df92a4419","date":1583776063,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateDocValues(Term,Field...).mjava","sourceNew":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together. If a doc values fields data is <code>null</code> the existing\n   * value is removed from all documents matching the term.\n   *\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates);\n    try {\n      return maybeProcessEvents(docWriter.updateDocValues(dvUpdates));\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n      throw tragedy;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates documents' DocValues fields to the given values. Each field update\n   * is applied to the set of documents that are associated with the\n   * {@link Term} to the same value. All updates are atomically applied and\n   * flushed together. If a doc values fields data is <code>null</code> the existing\n   * value is removed from all documents matching the term.\n   *\n   * \n   * @param updates\n   *          the updates to apply\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateDocValues(Term term, Field... updates) throws IOException {\n    ensureOpen();\n    DocValuesUpdate[] dvUpdates = buildDocValuesUpdate(term, updates);\n    try {\n      long seqNo = docWriter.updateDocValues(dvUpdates);\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateDocValues\");\n      throw tragedy;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"65233715955663909ad948e05aa3fed614f4a57b":["191128ac5b85671b1671e2c857437694283b6ebf"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["110125c995236a7f61057dd04b039ed2d267f3a1"],"0a9b6ed5e493fd780f940f307e17673df92a4419":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"36d13f271b6649357e07f71f7e46559479f69b5b":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["36d13f271b6649357e07f71f7e46559479f69b5b"],"23a29a4862e38cc3b9bff14a888901c7c878885b":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"6483e4260c08168709c02238ae083a51519a28dd":["ad0d09e969f4763b0df4230f8e3f74357872a4e4","16ebfabc294f23b88b6a39722a02c9d39b353195"],"191128ac5b85671b1671e2c857437694283b6ebf":["ad0d09e969f4763b0df4230f8e3f74357872a4e4","6483e4260c08168709c02238ae083a51519a28dd"],"110125c995236a7f61057dd04b039ed2d267f3a1":["65233715955663909ad948e05aa3fed614f4a57b"],"70285ef5917fa2c8feec026d4be4d9c20fa89162":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["23a29a4862e38cc3b9bff14a888901c7c878885b"],"f95ce1375367b92d411a06175eab3915fe93c6bc":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["ad0d09e969f4763b0df4230f8e3f74357872a4e4","191128ac5b85671b1671e2c857437694283b6ebf"],"c48871ed951104729f5e17a8ee1091b43fa18980":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["c48871ed951104729f5e17a8ee1091b43fa18980"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","65233715955663909ad948e05aa3fed614f4a57b"],"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e":["f95ce1375367b92d411a06175eab3915fe93c6bc"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["70285ef5917fa2c8feec026d4be4d9c20fa89162"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0a9b6ed5e493fd780f940f307e17673df92a4419"]},"commit2Childs":{"65233715955663909ad948e05aa3fed614f4a57b":["110125c995236a7f61057dd04b039ed2d267f3a1","9856095f7afb5a607bf5e65077615ed91273508c"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["36d13f271b6649357e07f71f7e46559479f69b5b"],"0a9b6ed5e493fd780f940f307e17673df92a4419":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"36d13f271b6649357e07f71f7e46559479f69b5b":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["0a9b6ed5e493fd780f940f307e17673df92a4419"],"23a29a4862e38cc3b9bff14a888901c7c878885b":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"2bb2842e561df4e8e9ad89010605fc86ac265465":["f95ce1375367b92d411a06175eab3915fe93c6bc"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["65233715955663909ad948e05aa3fed614f4a57b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"110125c995236a7f61057dd04b039ed2d267f3a1":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["6483e4260c08168709c02238ae083a51519a28dd"],"70285ef5917fa2c8feec026d4be4d9c20fa89162":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"f95ce1375367b92d411a06175eab3915fe93c6bc":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"c48871ed951104729f5e17a8ee1091b43fa18980":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70285ef5917fa2c8feec026d4be4d9c20fa89162"],"ad0d09e969f4763b0df4230f8e3f74357872a4e4":["23a29a4862e38cc3b9bff14a888901c7c878885b","6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e":["c48871ed951104729f5e17a8ee1091b43fa18980"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["2bb2842e561df4e8e9ad89010605fc86ac265465"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}