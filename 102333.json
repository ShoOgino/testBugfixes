{"path":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","commits":[{"id":"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","date":1361851792,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,String).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is shutdown\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryStrat = new RecoveryStrategy(cc, cd, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, String name) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is shutdown\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryStrat = new RecoveryStrategy(cc, name, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ab6ceed580cbfeb78d02fc47368a12b7be14970","date":1363406765,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    // check before we grab the lock\n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is shutdown\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      // to be air tight we must also check after lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is shutdown\");\n        return;\n      }\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryStrat = new RecoveryStrategy(cc, cd, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is shutdown\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryStrat = new RecoveryStrategy(cc, cd, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    // check before we grab the lock\n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is close\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      // to be air tight we must also check after lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is close\");\n        return;\n      }\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is close\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryStrat = new RecoveryStrategy(cc, cd, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    // check before we grab the lock\n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is shutdown\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      // to be air tight we must also check after lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is shutdown\");\n        return;\n      }\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryStrat = new RecoveryStrategy(cc, cd, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","date":1423420267,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    // check before we grab the lock\n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is close\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      // to be air tight we must also check after lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is close\");\n        return;\n      }\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is close\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryThrottle.minimumWaitBetweenActions();\n      recoveryThrottle.markAttemptingAction();\n      \n      recoveryStrat = new RecoveryStrategy(cc, cd, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    // check before we grab the lock\n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is close\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      // to be air tight we must also check after lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is close\");\n        return;\n      }\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is close\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryStrat = new RecoveryStrategy(cc, cd, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    MDCLoggingContext.setCoreDescriptor(cd);\n    try {\n      if (SKIP_AUTO_RECOVERY) {\n        log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n        return;\n      }\n      \n      // check before we grab the lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is shutdown\");\n        return;\n      }\n      \n      synchronized (recoveryLock) {\n        // to be air tight we must also check after lock\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        log.info(\"Running recovery - first canceling any ongoing recovery\");\n        cancelRecovery();\n        \n        while (recoveryRunning) {\n          try {\n            recoveryLock.wait(1000);\n          } catch (InterruptedException e) {\n          \n          }\n          // check again for those that were waiting\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          if (closed) return;\n        }\n        \n        // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for\n        // local tlog recovery)\n        boolean recoveringAfterStartup = recoveryStrat == null;\n        \n        recoveryThrottle.minimumWaitBetweenActions();\n        recoveryThrottle.markAttemptingAction();\n        \n        recoveryStrat = new RecoveryStrategy(cc, cd, this);\n        recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n        recoveryStrat.start();\n        recoveryRunning = true;\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    if (SKIP_AUTO_RECOVERY) {\n      log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n      return;\n    }\n    \n    // check before we grab the lock\n    if (cc.isShutDown()) {\n      log.warn(\"Skipping recovery because Solr is close\");\n      return;\n    }\n    \n    synchronized (recoveryLock) {\n      // to be air tight we must also check after lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is close\");\n        return;\n      }\n      log.info(\"Running recovery - first canceling any ongoing recovery\");\n      cancelRecovery();\n      \n      while (recoveryRunning) {\n        try {\n          recoveryLock.wait(1000);\n        } catch (InterruptedException e) {\n\n        }\n        // check again for those that were waiting\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is close\");\n          return;\n        }\n        if (closed) return;\n      }\n\n      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)\n      boolean recoveringAfterStartup = recoveryStrat == null;\n\n      recoveryThrottle.minimumWaitBetweenActions();\n      recoveryThrottle.markAttemptingAction();\n      \n      recoveryStrat = new RecoveryStrategy(cc, cd, this);\n      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n      recoveryStrat.start();\n      recoveryRunning = true;\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["3c3f78fc552394c5911fc8e26627b33263967e83"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c3f78fc552394c5911fc8e26627b33263967e83","date":1443796813,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    MDCLoggingContext.setCoreDescriptor(cd);\n    try {\n      if (SKIP_AUTO_RECOVERY) {\n        log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n        return;\n      }\n      \n      // check before we grab the lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is shutdown\");\n        return;\n      }\n      \n      synchronized (recoveryLock) {\n        // to be air tight we must also check after lock\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        log.info(\"Running recovery - first canceling any ongoing recovery\");\n        cancelRecovery();\n        \n        while (recoveryRunning) {\n          try {\n            recoveryLock.wait(1000);\n          } catch (InterruptedException e) {\n          \n          }\n          // check again for those that were waiting\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          if (closed) return;\n        }\n        \n        recoveryThrottle.minimumWaitBetweenActions();\n        recoveryThrottle.markAttemptingAction();\n        \n        recoveryStrat = new RecoveryStrategy(cc, cd, this);\n        recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n        recoveryStrat.start();\n        recoveryRunning = true;\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    MDCLoggingContext.setCoreDescriptor(cd);\n    try {\n      if (SKIP_AUTO_RECOVERY) {\n        log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n        return;\n      }\n      \n      // check before we grab the lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is shutdown\");\n        return;\n      }\n      \n      synchronized (recoveryLock) {\n        // to be air tight we must also check after lock\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        log.info(\"Running recovery - first canceling any ongoing recovery\");\n        cancelRecovery();\n        \n        while (recoveryRunning) {\n          try {\n            recoveryLock.wait(1000);\n          } catch (InterruptedException e) {\n          \n          }\n          // check again for those that were waiting\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          if (closed) return;\n        }\n        \n        // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for\n        // local tlog recovery)\n        boolean recoveringAfterStartup = recoveryStrat == null;\n        \n        recoveryThrottle.minimumWaitBetweenActions();\n        recoveryThrottle.markAttemptingAction();\n        \n        recoveryStrat = new RecoveryStrategy(cc, cd, this);\n        recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n        recoveryStrat.start();\n        recoveryRunning = true;\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9e52dc3261e61fb422a343ba4e6df9a9fab88e6","date":1448994587,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    MDCLoggingContext.setCoreDescriptor(cd);\n    try {\n      if (SKIP_AUTO_RECOVERY) {\n        log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n        return;\n      }\n      \n      // check before we grab the lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is shutdown\");\n        return;\n      }\n      \n      synchronized (recoveryLock) {\n        // to be air tight we must also check after lock\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        log.info(\"Running recovery - first canceling any ongoing recovery\");\n        cancelRecovery();\n        \n        while (recoveryRunning) {\n          try {\n            recoveryLock.wait(1000);\n          } catch (InterruptedException e) {\n          \n          }\n          // check again for those that were waiting\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          if (closed) return;\n        }\n        \n        recoveryThrottle.minimumWaitBetweenActions();\n        recoveryThrottle.markAttemptingAction();\n        \n        recoveryStrat = new RecoveryStrategy(cc, cd, this);\n        recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n        future = cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryStrat);\n        recoveryRunning = true;\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    MDCLoggingContext.setCoreDescriptor(cd);\n    try {\n      if (SKIP_AUTO_RECOVERY) {\n        log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n        return;\n      }\n      \n      // check before we grab the lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is shutdown\");\n        return;\n      }\n      \n      synchronized (recoveryLock) {\n        // to be air tight we must also check after lock\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        log.info(\"Running recovery - first canceling any ongoing recovery\");\n        cancelRecovery();\n        \n        while (recoveryRunning) {\n          try {\n            recoveryLock.wait(1000);\n          } catch (InterruptedException e) {\n          \n          }\n          // check again for those that were waiting\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          if (closed) return;\n        }\n        \n        recoveryThrottle.minimumWaitBetweenActions();\n        recoveryThrottle.markAttemptingAction();\n        \n        recoveryStrat = new RecoveryStrategy(cc, cd, this);\n        recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n        recoveryStrat.start();\n        recoveryRunning = true;\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"faee9bc2585a43773210f032b2bdcff90d9a12bf","date":1450411263,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = new RecoveryStrategy(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    MDCLoggingContext.setCoreDescriptor(cd);\n    try {\n      if (SKIP_AUTO_RECOVERY) {\n        log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n        return;\n      }\n      \n      // check before we grab the lock\n      if (cc.isShutDown()) {\n        log.warn(\"Skipping recovery because Solr is shutdown\");\n        return;\n      }\n      \n      synchronized (recoveryLock) {\n        // to be air tight we must also check after lock\n        if (cc.isShutDown()) {\n          log.warn(\"Skipping recovery because Solr is shutdown\");\n          return;\n        }\n        log.info(\"Running recovery - first canceling any ongoing recovery\");\n        cancelRecovery();\n        \n        while (recoveryRunning) {\n          try {\n            recoveryLock.wait(1000);\n          } catch (InterruptedException e) {\n          \n          }\n          // check again for those that were waiting\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          if (closed) return;\n        }\n        \n        recoveryThrottle.minimumWaitBetweenActions();\n        recoveryThrottle.markAttemptingAction();\n        \n        recoveryStrat = new RecoveryStrategy(cc, cd, this);\n        recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n        future = cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryStrat);\n        recoveryRunning = true;\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["3646ead588297558973dbd1162e69791e822b944"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"75f8e92726dcfea10834d4aa3d5dc66d62e71abb","date":1450706438,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = new RecoveryStrategy(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = new RecoveryStrategy(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7392b75d2c2f2aecf31188732a0764fe0dc74ade","date":1489420141,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = new RecoveryStrategy(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5413931a874939770ede57e7f5ce5c64c1d2366c","date":1494979390,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Runnable recoveryTask = new Runnable() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryTask);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f","date":1495081498,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Runnable recoveryTask = new Runnable() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryTask);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Runnable recoveryTask = new Runnable() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryTask);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Thread thread = new Thread() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(thread);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Runnable recoveryTask = new Runnable() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked && recoveryWaiting.get() > 0) {\n              return;\n            }\n\n            recoveryWaiting.incrementAndGet();\n            cancelRecovery();\n            \n            recoveryLock.lock();\n            try {\n              // don't use recoveryLock.getQueueLength() for this\n              if (recoveryWaiting.decrementAndGet() > 0) {\n                // another recovery waiting behind us, let it run now instead of after we finish\n                return;\n              }\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryTask);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Runnable recoveryTask = new Runnable() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked) {\n              if (recoveryWaiting.get() > 0) {\n                return;\n              }\n              recoveryWaiting.incrementAndGet();\n            } else {\n              recoveryWaiting.incrementAndGet();\n              cancelRecovery();\n            }\n            \n            recoveryLock.lock();\n            try {\n              recoveryWaiting.decrementAndGet();\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryTask);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3646ead588297558973dbd1162e69791e822b944","date":1525482176,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#doRecovery(CoreContainer,CoreDescriptor).mjava","sourceNew":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Runnable recoveryTask = new Runnable() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked && recoveryWaiting.get() > 0) {\n              return;\n            }\n\n            recoveryWaiting.incrementAndGet();\n            cancelRecovery();\n            \n            recoveryLock.lock();\n            try {\n              // don't use recoveryLock.getQueueLength() for this\n              if (recoveryWaiting.decrementAndGet() > 0) {\n                // another recovery waiting behind us, let it run now instead of after we finish\n                return;\n              }\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      //\n      // avoid deadlock: we can't use the recovery executor here!\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryTask);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {\n    \n    Runnable recoveryTask = new Runnable() {\n      @Override\n      public void run() {\n        MDCLoggingContext.setCoreDescriptor(cc, cd);\n        try {\n          if (SKIP_AUTO_RECOVERY) {\n            log.warn(\"Skipping recovery according to sys prop solrcloud.skip.autorecovery\");\n            return;\n          }\n          \n          // check before we grab the lock\n          if (cc.isShutDown()) {\n            log.warn(\"Skipping recovery because Solr is shutdown\");\n            return;\n          }\n          \n          // if we can't get the lock, another recovery is running\n          // we check to see if there is already one waiting to go\n          // after the current one, and if there is, bail\n          boolean locked = recoveryLock.tryLock();\n          try {\n            if (!locked && recoveryWaiting.get() > 0) {\n              return;\n            }\n\n            recoveryWaiting.incrementAndGet();\n            cancelRecovery();\n            \n            recoveryLock.lock();\n            try {\n              // don't use recoveryLock.getQueueLength() for this\n              if (recoveryWaiting.decrementAndGet() > 0) {\n                // another recovery waiting behind us, let it run now instead of after we finish\n                return;\n              }\n              \n              // to be air tight we must also check after lock\n              if (cc.isShutDown()) {\n                log.warn(\"Skipping recovery because Solr is shutdown\");\n                return;\n              }\n              log.info(\"Running recovery\");\n              \n              recoveryThrottle.minimumWaitBetweenActions();\n              recoveryThrottle.markAttemptingAction();\n              \n              recoveryStrat = recoveryStrategyBuilder.create(cc, cd, DefaultSolrCoreState.this);\n              recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);\n              Future<?> future = cc.getUpdateShardHandler().getRecoveryExecutor().submit(recoveryStrat);\n              try {\n                future.get();\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              } catch (ExecutionException e) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, e);\n              }\n            } finally {\n              recoveryLock.unlock();\n            }\n          } finally {\n            if (locked) recoveryLock.unlock();\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    };\n    try {\n      // we make recovery requests async - that async request may\n      // have to 'wait in line' a bit or bail if a recovery is \n      // already queued up - the recovery execution itself is run\n      // in another thread on another 'recovery' executor.\n      // The update executor is interrupted on shutdown and should \n      // not do disk IO.\n      // The recovery executor is not interrupted on shutdown.\n      //\n      // avoid deadlock: we can't use the recovery executor here\n      cc.getUpdateShardHandler().getUpdateExecutor().submit(recoveryTask);\n    } catch (RejectedExecutionException e) {\n      // fine, we are shutting down\n    }\n  }\n\n","bugFix":["faee9bc2585a43773210f032b2bdcff90d9a12bf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"b9e52dc3261e61fb422a343ba4e6df9a9fab88e6":["3c3f78fc552394c5911fc8e26627b33263967e83"],"faee9bc2585a43773210f032b2bdcff90d9a12bf":["b9e52dc3261e61fb422a343ba4e6df9a9fab88e6"],"2ab6ceed580cbfeb78d02fc47368a12b7be14970":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"84f20f331d8001864545c7021812d8c6509c7593":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","5413931a874939770ede57e7f5ce5c64c1d2366c"],"5413931a874939770ede57e7f5ce5c64c1d2366c":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"3646ead588297558973dbd1162e69791e822b944":["84f20f331d8001864545c7021812d8c6509c7593"],"3c3f78fc552394c5911fc8e26627b33263967e83":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["2ab6ceed580cbfeb78d02fc47368a12b7be14970"],"75f8e92726dcfea10834d4aa3d5dc66d62e71abb":["faee9bc2585a43773210f032b2bdcff90d9a12bf"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["75f8e92726dcfea10834d4aa3d5dc66d62e71abb"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3646ead588297558973dbd1162e69791e822b944"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"b9e52dc3261e61fb422a343ba4e6df9a9fab88e6":["faee9bc2585a43773210f032b2bdcff90d9a12bf"],"faee9bc2585a43773210f032b2bdcff90d9a12bf":["75f8e92726dcfea10834d4aa3d5dc66d62e71abb"],"2ab6ceed580cbfeb78d02fc47368a12b7be14970":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"84f20f331d8001864545c7021812d8c6509c7593":["3646ead588297558973dbd1162e69791e822b944"],"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f":["84f20f331d8001864545c7021812d8c6509c7593","e9017cf144952056066919f1ebc7897ff9bd71b1"],"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"5413931a874939770ede57e7f5ce5c64c1d2366c":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f","5413931a874939770ede57e7f5ce5c64c1d2366c"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["3c3f78fc552394c5911fc8e26627b33263967e83"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"3646ead588297558973dbd1162e69791e822b944":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3c3f78fc552394c5911fc8e26627b33263967e83":["b9e52dc3261e61fb422a343ba4e6df9a9fab88e6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"75f8e92726dcfea10834d4aa3d5dc66d62e71abb":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["2ab6ceed580cbfeb78d02fc47368a12b7be14970"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}