{"path":"src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","commits":[{"id":"777b7ef341decfee8757f492d8a154637cd7a384","date":1260037647,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"/dev/null","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9cc904db9f72d0c14131b0ee7d92ec565c45b0f","date":1266745649,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5ff9e61d5748484a6d8e00a9cb7689cb4841922","date":1266772579,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","pathOld":"src/test/org/apache/lucene/util/LuceneTestCaseJ4#tearDown().mjava","sourceNew":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","sourceOld":"  @After\n  public void tearDown() throws Exception {\n    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);\n    try {\n      // this isn't as useful as calling directly from the scope where the\n      // index readers are used, because they could be gc'ed just before\n      // tearDown is called.\n      // But it's better then nothing.\n      assertSaneFieldCaches(getTestLabel());\n\n      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {\n        // Clear the failure so that we don't just keep\n        // failing subsequent test cases\n        ConcurrentMergeScheduler.clearUnhandledExceptions();\n        fail(\"ConcurrentMergeScheduler hit unhandled exceptions\");\n      }\n    } finally {\n      purgeFieldCache(FieldCache.DEFAULT);\n    }\n    \n    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);\n    if (!uncaughtExceptions.isEmpty()) {\n      System.err.println(\"The following exceptions were thrown by threads:\");\n      for (UncaughtExceptionEntry entry : uncaughtExceptions) {\n        System.err.println(\"*** Thread: \" + entry.thread.getName() + \" ***\");\n        entry.exception.printStackTrace(System.err);\n      }\n      fail(\"Some threads throwed uncaught exceptions!\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d5ff9e61d5748484a6d8e00a9cb7689cb4841922":["a9cc904db9f72d0c14131b0ee7d92ec565c45b0f"],"777b7ef341decfee8757f492d8a154637cd7a384":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d5ff9e61d5748484a6d8e00a9cb7689cb4841922"],"a9cc904db9f72d0c14131b0ee7d92ec565c45b0f":["777b7ef341decfee8757f492d8a154637cd7a384"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["777b7ef341decfee8757f492d8a154637cd7a384"],"d5ff9e61d5748484a6d8e00a9cb7689cb4841922":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"777b7ef341decfee8757f492d8a154637cd7a384":["a9cc904db9f72d0c14131b0ee7d92ec565c45b0f"],"a9cc904db9f72d0c14131b0ee7d92ec565c45b0f":["d5ff9e61d5748484a6d8e00a9cb7689cb4841922"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}