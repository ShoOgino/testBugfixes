{"path":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","commits":[{"id":"42a7d0b384f0022c5a29e562b809ebf73991d7e6","date":1082489615,"type":0,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n      this.closeDir = closeDir;\n      directory = d;\n      analyzer = a;\n\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;                   // save it\n\n      synchronized (directory) {        // in- & inter-process sync\n        new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), COMMIT_LOCK_TIMEOUT) {\n            public Object doBody() throws IOException {\n              if (create)\n                segmentInfos.write(directory);\n              else\n                segmentInfos.read(directory);\n              return null;\n            }\n          }.run();\n      }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5a664b1395d4341b88e32d36297d7670f1a665ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14e0bcefcbabf34d28e4fd7060dabc9a9fe37cea","date":1142635892,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","sourceNew":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n      this.closeDir = closeDir;\n      directory = d;\n      analyzer = a;\n\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;                   // save it\n\n      synchronized (directory) {        // in- & inter-process sync\n        new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), commitLockTimeout) {\n            public Object doBody() throws IOException {\n              if (create)\n                segmentInfos.write(directory);\n              else\n                segmentInfos.read(directory);\n              return null;\n            }\n          }.run();\n      }\n  }\n\n","sourceOld":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n      this.closeDir = closeDir;\n      directory = d;\n      analyzer = a;\n\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;                   // save it\n\n      synchronized (directory) {        // in- & inter-process sync\n        new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), COMMIT_LOCK_TIMEOUT) {\n            public Object doBody() throws IOException {\n              if (create)\n                segmentInfos.write(directory);\n              else\n                segmentInfos.read(directory);\n              return null;\n            }\n          }.run();\n      }\n  }\n\n","bugFix":null,"bugIntro":["5a664b1395d4341b88e32d36297d7670f1a665ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b71d5c456630716ddede23f6899b4f5fc1890f00","date":1163802857,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","sourceNew":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n      this.closeDir = closeDir;\n      directory = d;\n      analyzer = a;\n\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;                   // save it\n\n      try {\n        synchronized (directory) {        // in- & inter-process sync\n          new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), commitLockTimeout) {\n              public Object doBody() throws IOException {\n                if (create)\n                  segmentInfos.write(directory);\n                else\n                  segmentInfos.read(directory);\n                return null;\n              }\n            }.run();\n        }\n      } catch (IOException e) {\n        // the doBody method failed\n        this.writeLock.release();\n        this.writeLock = null;\n        throw e;\n      }\n  }\n\n","sourceOld":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n      this.closeDir = closeDir;\n      directory = d;\n      analyzer = a;\n\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;                   // save it\n\n      synchronized (directory) {        // in- & inter-process sync\n        new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), commitLockTimeout) {\n            public Object doBody() throws IOException {\n              if (create)\n                segmentInfos.write(directory);\n              else\n                segmentInfos.read(directory);\n              return null;\n            }\n          }.run();\n      }\n  }\n\n","bugFix":null,"bugIntro":["5a664b1395d4341b88e32d36297d7670f1a665ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","sourceNew":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n      this.closeDir = closeDir;\n      directory = d;\n      analyzer = a;\n\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;                   // save it\n\n      try {\n        if (create) {\n          // Try to read first.  This is to allow create\n          // against an index that's currently open for\n          // searching.  In this case we write the next\n          // segments_N file with no segments:\n          try {\n            segmentInfos.read(directory);\n            segmentInfos.clear();\n          } catch (IOException e) {\n            // Likely this means it's a fresh directory\n          }\n          segmentInfos.write(directory);\n        } else {\n          segmentInfos.read(directory);\n        }\n\n        // Create a deleter to keep track of which files can\n        // be deleted:\n        deleter = new IndexFileDeleter(segmentInfos, directory);\n        deleter.setInfoStream(infoStream);\n        deleter.findDeletableFiles();\n        deleter.deleteFiles();\n\n      } catch (IOException e) {\n        this.writeLock.release();\n        this.writeLock = null;\n        throw e;\n      }\n  }\n\n","sourceOld":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n      this.closeDir = closeDir;\n      directory = d;\n      analyzer = a;\n\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;                   // save it\n\n      try {\n        synchronized (directory) {        // in- & inter-process sync\n          new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), commitLockTimeout) {\n              public Object doBody() throws IOException {\n                if (create)\n                  segmentInfos.write(directory);\n                else\n                  segmentInfos.read(directory);\n                return null;\n              }\n            }.run();\n        }\n      } catch (IOException e) {\n        // the doBody method failed\n        this.writeLock.release();\n        this.writeLock = null;\n        throw e;\n      }\n  }\n\n","bugFix":null,"bugIntro":["5a664b1395d4341b88e32d36297d7670f1a665ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a664b1395d4341b88e32d36297d7670f1a665ac","date":1166527887,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","sourceNew":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n    init(d, a, create, closeDir);\n  }\n\n","sourceOld":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n      this.closeDir = closeDir;\n      directory = d;\n      analyzer = a;\n\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;                   // save it\n\n      try {\n        if (create) {\n          // Try to read first.  This is to allow create\n          // against an index that's currently open for\n          // searching.  In this case we write the next\n          // segments_N file with no segments:\n          try {\n            segmentInfos.read(directory);\n            segmentInfos.clear();\n          } catch (IOException e) {\n            // Likely this means it's a fresh directory\n          }\n          segmentInfos.write(directory);\n        } else {\n          segmentInfos.read(directory);\n        }\n\n        // Create a deleter to keep track of which files can\n        // be deleted:\n        deleter = new IndexFileDeleter(segmentInfos, directory);\n        deleter.setInfoStream(infoStream);\n        deleter.findDeletableFiles();\n        deleter.deleteFiles();\n\n      } catch (IOException e) {\n        this.writeLock.release();\n        this.writeLock = null;\n        throw e;\n      }\n  }\n\n","bugFix":["284c1d3c8b19931bf6f312fae7470487f5d9e580","14e0bcefcbabf34d28e4fd7060dabc9a9fe37cea","42a7d0b384f0022c5a29e562b809ebf73991d7e6","b71d5c456630716ddede23f6899b4f5fc1890f00"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4197136e4c43daac35ea22e9ef6a2e97ddef6a47","date":1172042533,"type":4,"author":"Doron Cohen","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,Analyzer,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir)\n    throws IOException {\n    init(d, a, create, closeDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"14e0bcefcbabf34d28e4fd7060dabc9a9fe37cea":["42a7d0b384f0022c5a29e562b809ebf73991d7e6"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["b71d5c456630716ddede23f6899b4f5fc1890f00"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b71d5c456630716ddede23f6899b4f5fc1890f00":["14e0bcefcbabf34d28e4fd7060dabc9a9fe37cea"],"42a7d0b384f0022c5a29e562b809ebf73991d7e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a664b1395d4341b88e32d36297d7670f1a665ac":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"4197136e4c43daac35ea22e9ef6a2e97ddef6a47":["5a664b1395d4341b88e32d36297d7670f1a665ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4197136e4c43daac35ea22e9ef6a2e97ddef6a47"]},"commit2Childs":{"14e0bcefcbabf34d28e4fd7060dabc9a9fe37cea":["b71d5c456630716ddede23f6899b4f5fc1890f00"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["5a664b1395d4341b88e32d36297d7670f1a665ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["42a7d0b384f0022c5a29e562b809ebf73991d7e6"],"42a7d0b384f0022c5a29e562b809ebf73991d7e6":["14e0bcefcbabf34d28e4fd7060dabc9a9fe37cea"],"b71d5c456630716ddede23f6899b4f5fc1890f00":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"5a664b1395d4341b88e32d36297d7670f1a665ac":["4197136e4c43daac35ea22e9ef6a2e97ddef6a47"],"4197136e4c43daac35ea22e9ef6a2e97ddef6a47":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}