{"path":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77301f098b899884dd472e6b27fb5f8136189fe3","date":1415988476,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrderedNonOverlap(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":["98bc22650ab0fe51f9c00513397bfa42a64fc663"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30de45e50bdc1a79a6797f34dca6271c8866cb6e","date":1427790465,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.size() - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans.get(i);\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrderedNonOverlap(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.size() - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans.get(i);\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrderedNonOverlap(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d1a832d7282403b4783b9435f19a5ba2e9dbdf7","date":1428071973,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans[subSpans.length - 1];\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.size() - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans.get(i);\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans[subSpans.length - 1];\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.size() - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans.get(i);\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d530e71ed32ab23b34ca3fc72b080a554a40404","date":1432026158,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans[subSpans.length - 1];\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    buffer = collector.buffer();\n    buffer.collectCandidate(subSpans[subSpans.length - 1]);\n    buffer.accept();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      buffer.collectCandidate(prevSpans);\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        buffer.collectCandidate(prevSpans);\n      }\n\n      buffer.accept();\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans[subSpans.length - 1];\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6ee9d8242a0cf1c4d14c2252cba08a37562c806","date":1433925249,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":null,"sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans[subSpans.length - 1];\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    buffer = collector.buffer();\n    buffer.collectCandidate(subSpans[subSpans.length - 1]);\n    buffer.accept();\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      buffer.collectCandidate(prevSpans);\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        buffer.collectCandidate(prevSpans);\n      }\n\n      buffer.accept();\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d6ee9d8242a0cf1c4d14c2252cba08a37562c806":["2d530e71ed32ab23b34ca3fc72b080a554a40404"],"77301f098b899884dd472e6b27fb5f8136189fe3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3d1a832d7282403b4783b9435f19a5ba2e9dbdf7":["30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["fab172655716b96f7e42376116235017a922de3a","3d1a832d7282403b4783b9435f19a5ba2e9dbdf7"],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["3d1a832d7282403b4783b9435f19a5ba2e9dbdf7"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["77301f098b899884dd472e6b27fb5f8136189fe3"],"fab172655716b96f7e42376116235017a922de3a":["77301f098b899884dd472e6b27fb5f8136189fe3","30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d6ee9d8242a0cf1c4d14c2252cba08a37562c806"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["77301f098b899884dd472e6b27fb5f8136189fe3"],"d6ee9d8242a0cf1c4d14c2252cba08a37562c806":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"77301f098b899884dd472e6b27fb5f8136189fe3":["30de45e50bdc1a79a6797f34dca6271c8866cb6e","fab172655716b96f7e42376116235017a922de3a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3d1a832d7282403b4783b9435f19a5ba2e9dbdf7":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","2d530e71ed32ab23b34ca3fc72b080a554a40404"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["d6ee9d8242a0cf1c4d14c2252cba08a37562c806"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["3d1a832d7282403b4783b9435f19a5ba2e9dbdf7","fab172655716b96f7e42376116235017a922de3a"],"fab172655716b96f7e42376116235017a922de3a":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}