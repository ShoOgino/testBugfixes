{"path":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","commits":[{"id":"dedd8b6e67b7ac7a77554562fddcf90e0031a95c","date":1391930936,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        try {\n          if (!success) {\n            cancelElection();\n          }\n        } finally {\n          if (core != null) {\n            core.close();\n          }\n        }\n        \n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        try {\n          if (!success) {\n            cancelElection();\n          }\n        } finally {\n          if (core != null) {\n            core.close();\n          }\n        }\n        \n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e332392bbbdd01cb69ad6a89051f483cda38e15e","date":1395758779,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (!success)\n          cancelElection();\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n    \n    SolrCore core = null;\n    try {\n      \n      core = cc.getCore(coreName);\n      \n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    } finally {\n      if (core != null) {\n        core.close();\n      }\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try {\n        core = cc.getCore(coreName);\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        try {\n          if (!success) {\n            cancelElection();\n          }\n        } finally {\n          if (core != null) {\n            core.close();\n          }\n        }\n        \n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["9cef9edf6786c51f767f53339f5be3ccb5e1a491"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cef9edf6786c51f767f53339f5be3ccb5e1a491","date":1397590125,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      }\n    }\n    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n    boolean success = false;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n      success = true;\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                  + cc.getCoreNames());\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      } finally {\n        if (!success)\n          cancelElection();\n      }\n    }\n    \n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","d9405f486872f1e416304dfe389741f4ee2f8a4d","e332392bbbdd01cb69ad6a89051f483cda38e15e","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5455c7b3fed6c1671990a44c19071cb0488c2c25","date":1413557414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(leaderSeqPath, core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(leaderSeqPath, core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","date":1423420267,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n    \n    lt.minimumWaitBetweenActions();\n    lt.markAttemptingAction();\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Fatal Error, SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","bugFix":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"bugIntro":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c94d2661bc1c14426980ec7882e951fdcff08d0","date":1427167177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n    \n    lt.minimumWaitBetweenActions();\n    lt.markAttemptingAction();\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          log.error(\"Error in solrcloud_debug block\", e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n    \n    lt.minimumWaitBetweenActions();\n    lt.markAttemptingAction();\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","bugFix":["c52ad29218ee436d52c57bf0829b98acad9de379"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n    \n    lt.minimumWaitBetweenActions();\n    lt.markAttemptingAction();\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          log.error(\"Error in solrcloud_debug block\", e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n    \n    lt.minimumWaitBetweenActions();\n    lt.markAttemptingAction();\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n      }\n      \n      boolean isLeader = true;\n      try {\n        super.runLeaderProcess(weAreReplacement, 0);\n      } catch (Exception e) {\n        isLeader = false;\n        SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n        \n        try (SolrCore core = cc.getCore(coreName)) {\n          \n          if (core == null) {\n            log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n            return;\n          }\n          \n          core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n          \n          // we could not publish ourselves as leader - try and rejoin election\n          rejoinLeaderElection(core);\n        }\n      }\n      \n      if (isLeader) {\n        // check for any replicas in my shard that were set to down by the previous leader\n        try {\n          startLeaderInitiatedRecoveryOnReplicas(coreName);\n        } catch (Exception exc) {\n          // don't want leader election to fail because of\n          // an error trying to tell others to recover\n        }\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    log.info(\"Running the leader process for shard \" + shardId);\n    \n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n    \n    lt.minimumWaitBetweenActions();\n    lt.markAttemptingAction();\n    \n    // clear the leader in clusterstate\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,\n        collection);\n    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n    \n    int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n    if (!weAreReplacement) {\n      waitForReplicasToComeUp(leaderVoteWait);\n    }\n\n    try (SolrCore core = cc.getCore(coreName)) {\n\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"SolrCore not found:\" + coreName + \" in \"\n                + cc.getCoreNames());\n      }\n      \n      // should I be leader?\n      if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n        rejoinLeaderElection(core);\n        return;\n      }\n      \n      log.info(\"I may be the new leader - try and sync\");\n \n      \n      // we are going to attempt to be the leader\n      // first cancel any current recovery\n      core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n      \n      if (weAreReplacement) {\n        // wait a moment for any floating updates to finish\n        try {\n          Thread.sleep(2500);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n        }\n      }\n      \n      boolean success = false;\n      try {\n        success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n      } catch (Exception e) {\n        SolrException.log(log, \"Exception while trying to sync\", e);\n        success = false;\n      }\n      \n      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n      if (!success) {\n        boolean hasRecentUpdates = false;\n        if (ulog != null) {\n          // TODO: we could optimize this if necessary\n          UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n          try {\n            hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n          } finally {\n            recentUpdates.close();\n          }\n        }\n\n        if (!hasRecentUpdates) {\n          // we failed sync, but we have no versions - we can't sync in that case\n          // - we were active\n          // before, so become leader anyway\n          log.info(\"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n          success = true;\n        }\n      }\n      \n      // solrcloud_debug\n      if (log.isDebugEnabled()) {\n        try {\n          RefCounted<SolrIndexSearcher> searchHolder = core\n              .getNewestSearcher(false);\n          SolrIndexSearcher searcher = searchHolder.get();\n          try {\n            log.debug(core.getCoreDescriptor().getCoreContainer()\n                .getZkController().getNodeName()\n                + \" synched \"\n                + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n          } finally {\n            searchHolder.decref();\n          }\n        } catch (Exception e) {\n          log.error(\"Error in solrcloud_debug block\", e);\n        }\n      }\n      if (!success) {\n        rejoinLeaderElection(core);\n        return;\n      }\n\n      log.info(\"I am the new leader: \"\n          + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n      core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n    }\n\n    boolean isLeader = true;\n    try {\n      super.runLeaderProcess(weAreReplacement, 0);\n    } catch (Exception e) {\n      isLeader = false;\n      SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n  \n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          return;\n        }\n        \n        core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n        \n        // we could not publish ourselves as leader - try and rejoin election\n        rejoinLeaderElection(core);\n      }\n    }\n\n    if (isLeader) {\n      // check for any replicas in my shard that were set to down by the previous leader\n      try {\n        startLeaderInitiatedRecoveryOnReplicas(coreName);\n      } catch (Exception exc) {\n        // don't want leader election to fail because of\n        // an error trying to tell others to recover\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":["9f1bee4bba8988141f8357bda2ccd9405926c4e5","bb62cc3362417c3e5136f2f26d34a1072ad633eb","6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064","b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n      }\n      \n      boolean isLeader = true;\n      try {\n        super.runLeaderProcess(weAreReplacement, 0);\n      } catch (Exception e) {\n        isLeader = false;\n        SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n        \n        try (SolrCore core = cc.getCore(coreName)) {\n          \n          if (core == null) {\n            log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n            return;\n          }\n          \n          core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n          \n          // we could not publish ourselves as leader - try and rejoin election\n          rejoinLeaderElection(core);\n        }\n      }\n      \n      if (isLeader) {\n        // check for any replicas in my shard that were set to down by the previous leader\n        try {\n          startLeaderInitiatedRecoveryOnReplicas(coreName);\n        } catch (Exception exc) {\n          // don't want leader election to fail because of\n          // an error trying to tell others to recover\n        }\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n      }\n      \n      boolean isLeader = true;\n      try {\n        super.runLeaderProcess(weAreReplacement, 0);\n      } catch (Exception e) {\n        isLeader = false;\n        SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n        \n        try (SolrCore core = cc.getCore(coreName)) {\n          \n          if (core == null) {\n            log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n            return;\n          }\n          \n          core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n          \n          // we could not publish ourselves as leader - try and rejoin election\n          rejoinLeaderElection(core);\n        }\n      }\n      \n      if (isLeader) {\n        // check for any replicas in my shard that were set to down by the previous leader\n        try {\n          startLeaderInitiatedRecoveryOnReplicas(coreName);\n        } catch (Exception exc) {\n          // don't want leader election to fail because of\n          // an error trying to tell others to recover\n        }\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064","date":1441124018,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          super.runLeaderProcess(weAreReplacement, 0);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        cancelElection();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n      }\n      \n      boolean isLeader = true;\n      try {\n        super.runLeaderProcess(weAreReplacement, 0);\n      } catch (Exception e) {\n        isLeader = false;\n        SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n        \n        try (SolrCore core = cc.getCore(coreName)) {\n          \n          if (core == null) {\n            log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n            return;\n          }\n          \n          core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n          \n          // we could not publish ourselves as leader - try and rejoin election\n          rejoinLeaderElection(core);\n        }\n      }\n      \n      if (isLeader) {\n        // check for any replicas in my shard that were set to down by the previous leader\n        try {\n          startLeaderInitiatedRecoveryOnReplicas(coreName);\n        } catch (Exception exc) {\n          // don't want leader election to fail because of\n          // an error trying to tell others to recover\n        }\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","14d5815ecbef89580f5c48990bcd433f04f8563a","439c63ae5d22132fca810a0029a854e97d2c1a3e"],"bugIntro":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78277631929de308318c889be36ed69ce7a85048","date":1443977344,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          super.runLeaderProcess(weAreReplacement, 0);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          if (allReplicasInLine) {\n            // SOLR-8075: A bug may allow the proper leader to get marked as LIR DOWN and\n            // if we are marked as DOWN but were able to become the leader, we remove\n            // the DOWN entry here so that we don't fail publishing ACTIVE due to being in LIR.\n            // We only do this if all the replicas participated in the election just in case\n            // this was a valid LIR entry and the proper leader replica is missing.\n            try (SolrCore core = cc.getCore(coreName)) {\n              final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId,\n                  core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n              if (lirState == Replica.State.DOWN) {\n                zkController.updateLeaderInitiatedRecoveryState(collection, shardId,\n                    leaderProps.getStr(ZkStateReader.CORE_NODE_NAME_PROP), Replica.State.ACTIVE, null, true);\n              }\n            }\n            \n          }\n          \n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      if (!weAreReplacement) {\n        waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          super.runLeaderProcess(weAreReplacement, 0);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd","date":1447422052,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n        core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          super.runLeaderProcess(weAreReplacement, 0);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          if (allReplicasInLine) {\n            // SOLR-8075: A bug may allow the proper leader to get marked as LIR DOWN and\n            // if we are marked as DOWN but were able to become the leader, we remove\n            // the DOWN entry here so that we don't fail publishing ACTIVE due to being in LIR.\n            // We only do this if all the replicas participated in the election just in case\n            // this was a valid LIR entry and the proper leader replica is missing.\n            try (SolrCore core = cc.getCore(coreName)) {\n              final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId,\n                  core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n              if (lirState == Replica.State.DOWN) {\n                zkController.updateLeaderInitiatedRecoveryState(collection, shardId,\n                    leaderProps.getStr(ZkStateReader.CORE_NODE_NAME_PROP), Replica.State.ACTIVE, null, true);\n              }\n            }\n            \n          }\n          \n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["78277631929de308318c889be36ed69ce7a85048","439c63ae5d22132fca810a0029a854e97d2c1a3e"],"bugIntro":["3f50664369ffef1e236a800ed63be02c8ccc2d29"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"605f94f466b936ef47220109e97eea240dff2442","date":1447425207,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["3f50664369ffef1e236a800ed63be02c8ccc2d29"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","date":1449051812,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates();\n            try {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            } finally {\n              recentUpdates.close();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f1bee4bba8988141f8357bda2ccd9405926c4e5","date":1449703835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      log.info(\"Running the leader process for shard \" + shardId);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19498030e0adab22f604f935cae3c03dcf0952a6","date":1456558851,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4169a39455be564348e51f60d4dc9f77a80c2f9","date":1473707172,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5d615d62cd8aff3690943d765e46942551f98b6","date":1474881754,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb62cc3362417c3e5136f2f26d34a1072ad633eb","date":1475149102,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.info(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          cancelElection();\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n        \n        boolean success = false;\n        try {\n          success = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          success = false;\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway\n            log.info(\n                \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n            success = true;\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f50664369ffef1e236a800ed63be02c8ccc2d29","date":1488256890,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n            publishActiveIfRegisteredAndNotActive(core);\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["605f94f466b936ef47220109e97eea240dff2442","b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          \n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n\n          boolean onlyLeaderIndexes = zkController.getClusterState().getCollection(collection).getRealtimeReplicas() == 1;\n          if (onlyLeaderIndexes) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      try {\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      } catch (Exception e) {\n        throw new IOException(\"Overseer state update queue error\", e);\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      try {\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      } catch (Exception e) {\n        throw new IOException(\"Overseer state update queue error\", e);\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"691d1439503ec32e198724114f6cd32446c86ac6","date":1506996002,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      // clear the leader in clusterstate\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n          ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n      Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n        \n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","date":1520143025,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        String coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        if (zkController.getShardTerms(collection, shardId).registered(coreNodeName)\n            && !zkController.getShardTerms(collection, shardId).canBecomeLeader(coreNodeName)) {\n          log.info(\"Can't become leader, term of replica {} less than leader\", coreNodeName);\n          rejoinLeaderElection(core);\n          return;\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        \n        // should I be leader?\n        if (weAreReplacement && !shouldIBeLeader(leaderProps, core, weAreReplacement)) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9339df295b9162e4c81adbb4da44b5939d27c1ef","date":1520594349,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            log.info(\"Can't become leader, term of replica {} less than leader\", coreNodeName);\n            rejoinLeaderElection(core);\n            return;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (zkController.getShardTerms(collection, shardId).registered(coreNodeName)) {\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      \n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        String coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        if (zkController.getShardTerms(collection, shardId).registered(coreNodeName)\n            && !zkController.getShardTerms(collection, shardId).canBecomeLeader(coreNodeName)) {\n          log.info(\"Can't become leader, term of replica {} less than leader\", coreNodeName);\n          rejoinLeaderElection(core);\n          return;\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a516ca2094f85283226c09808a4793844564d7d1","date":1520641205,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            log.info(\"Can't become leader, term of replica {} less than leader\", coreNodeName);\n            rejoinLeaderElection(core);\n            return;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (zkController.getShardTerms(collection, shardId).registered(coreNodeName)) {\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.count(new MatchAllDocsQuery()));\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","date":1539076849,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.count(new MatchAllDocsQuery()));\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.count(new MatchAllDocsQuery()));\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          // we must check LIR before registering as leader\n          checkLIR(coreName, allReplicasInLine);\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n\n        if (isLeader) {\n          // check for any replicas in my shard that were set to down by the previous leader\n          try {\n            startLeaderInitiatedRecoveryOnReplicas(coreName);\n          } catch (Exception exc) {\n            // don't want leader election to fail because of\n            // an error trying to tell others to recover\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          return;\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.count(new MatchAllDocsQuery()));\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        if (cc.isShutDown()) {\n          return;\n        } else {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n        }\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        Overseer.getStateUpdateQueue(zkClient).offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          if (!zkController.getCoreContainer().isShutDown())  {\n            cancelElection();\n            throw new SolrException(ErrorCode.SERVER_ERROR,\n                \"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n          } else  {\n            return;\n          }\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.count(new MatchAllDocsQuery()));\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["691d1439503ec32e198724114f6cd32446c86ac6","729cb470f975115d4c60517b2cb7c42e37a7a2e1","d4169a39455be564348e51f60d4dc9f77a80c2f9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bbb0b5c5101d175049b4ced1462f4c266d32fc63","date":1559534216,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          return;\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.count(new MatchAllDocsQuery()));\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          return;\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.count(new MatchAllDocsQuery()));\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            rejoinLeaderElection(core);\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          return;\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, cc.getLoadedCoreNames());\n              }\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          return;\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              log.debug(core.getCoreContainer().getZkController().getNodeName() + \" synched \"\n                  + searcher.count(new MatchAllDocsQuery()));\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) \" +\n                \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          log.info(\"I am the new leader: \" + ZkCoreNodeProps.getCoreUrl(leaderProps) + \" \" + shardId);\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              log.debug(\"SolrCore not found:\" + coreName + \" in \" + cc.getLoadedCoreNames());\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba33781da68babcaa5828121b443d3eb5c9d8480","date":1590595589,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext#runLeaderProcess(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#runLeaderProcess(boolean,int).mjava","sourceNew":"  /*\n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n      InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n\n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n\n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n\n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later,\n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will\n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n\n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n\n        if (core == null) {\n          return;\n        }\n\n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n\n        log.info(\"I may be the new leader - try and sync\");\n\n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n\n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n\n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n\n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n\n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false)) {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n\n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n\n      }\n\n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n\n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n\n          try (SolrCore core = cc.getCore(coreName)) {\n\n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, cc.getLoadedCoreNames());\n              }\n              return;\n            }\n\n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n\n            // we could not publish ourselves as leader - try and rejoin election\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","sourceOld":"  /* \n   * weAreReplacement: has someone else been the leader already?\n   */\n  @Override\n  void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStart) throws KeeperException,\n InterruptedException, IOException {\n    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);\n    ActionThrottle lt;\n    try (SolrCore core = cc.getCore(coreName)) {\n      if (core == null ) {\n        // shutdown or removed\n        return;\n      }\n      MDCLoggingContext.setCore(core);\n      lt = core.getUpdateHandler().getSolrCoreState().getLeaderThrottle();\n    }\n\n    try {\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n      \n      \n      int leaderVoteWait = cc.getZkController().getLeaderVoteWait();\n      \n      log.debug(\"Running the leader process for shard={} and weAreReplacement={} and leaderVoteWait={}\", shardId, weAreReplacement, leaderVoteWait);\n      if (zkController.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() > 1) {\n        // Clear the leader in clusterstate. We only need to worry about this if there is actually more than one replica.\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),\n            ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);\n        zkController.getOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n      }\n\n      boolean allReplicasInLine = false;\n      if (!weAreReplacement) {\n        allReplicasInLine = waitForReplicasToComeUp(leaderVoteWait);\n      } else {\n        allReplicasInLine = areAllReplicasParticipating();\n      }\n      \n      if (isClosed) {\n        // Solr is shutting down or the ZooKeeper session expired while waiting for replicas. If the later, \n        // we cannot be sure we are still the leader, so we should bail out. The OnReconnect handler will \n        // re-register the cores and handle a new leadership election.\n        return;\n      }\n      \n      Replica.Type replicaType;\n      String coreNodeName;\n      boolean setTermToMax = false;\n      try (SolrCore core = cc.getCore(coreName)) {\n        \n        if (core == null) {\n          return;\n        }\n        \n        replicaType = core.getCoreDescriptor().getCloudDescriptor().getReplicaType();\n        coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n        // should I be leader?\n        ZkShardTerms zkShardTerms = zkController.getShardTerms(collection, shardId);\n        if (zkShardTerms.registered(coreNodeName) && !zkShardTerms.canBecomeLeader(coreNodeName)) {\n          if (!waitForEligibleBecomeLeaderAfterTimeout(zkShardTerms, coreNodeName, leaderVoteWait)) {\n            rejoinLeaderElection(core);\n            return;\n          } else {\n            // only log an error if this replica win the election\n            setTermToMax = true;\n          }\n        }\n\n        if (isClosed) {\n          return;\n        }\n        \n        log.info(\"I may be the new leader - try and sync\");\n        \n        // we are going to attempt to be the leader\n        // first cancel any current recovery\n        core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n        \n        if (weAreReplacement) {\n          // wait a moment for any floating updates to finish\n          try {\n            Thread.sleep(2500);\n          } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n          }\n        }\n\n        PeerSync.PeerSyncResult result = null;\n        boolean success = false;\n        try {\n          result = syncStrategy.sync(zkController, core, leaderProps, weAreReplacement);\n          success = result.isSuccess();\n        } catch (Exception e) {\n          SolrException.log(log, \"Exception while trying to sync\", e);\n          result = PeerSync.PeerSyncResult.failure();\n        }\n        \n        UpdateLog ulog = core.getUpdateHandler().getUpdateLog();\n        \n        if (!success) {\n          boolean hasRecentUpdates = false;\n          if (ulog != null) {\n            // TODO: we could optimize this if necessary\n            try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n              hasRecentUpdates = !recentUpdates.getVersions(1).isEmpty();\n            }\n          }\n          \n          if (!hasRecentUpdates) {\n            // we failed sync, but we have no versions - we can't sync in that case\n            // - we were active\n            // before, so become leader anyway if no one else has any versions either\n            if (result.getOtherHasVersions().orElse(false))  {\n              log.info(\"We failed sync, but we have no versions - we can't sync in that case. But others have some versions, so we should not become leader\");\n              success = false;\n            } else  {\n              log.info(\n                  \"We failed sync, but we have no versions - we can't sync in that case - we were active before, so become leader anyway\");\n              success = true;\n            }\n          }\n        }\n        \n        // solrcloud_debug\n        if (log.isDebugEnabled()) {\n          try {\n            RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n            SolrIndexSearcher searcher = searchHolder.get();\n            try {\n              if (log.isDebugEnabled()) {\n                log.debug(\"{} synched {}\", core.getCoreContainer().getZkController().getNodeName()\n                    , searcher.count(new MatchAllDocsQuery()));\n              }\n            } finally {\n              searchHolder.decref();\n            }\n          } catch (Exception e) {\n            log.error(\"Error in solrcloud_debug block\", e);\n          }\n        }\n        if (!success) {\n          rejoinLeaderElection(core);\n          return;\n        }\n        \n      }\n      \n      boolean isLeader = true;\n      if (!isClosed) {\n        try {\n          if (replicaType == Replica.Type.TLOG) {\n            // stop replicate from old leader\n            zkController.stopReplicationFromLeader(coreName);\n            if (weAreReplacement) {\n              try (SolrCore core = cc.getCore(coreName)) {\n                Future<UpdateLog.RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().recoverFromCurrentLog();\n                if (future != null) {\n                  log.info(\"Replaying tlog before become new leader\");\n                  future.get();\n                } else {\n                  log.info(\"New leader does not have old tlog to replay\");\n                }\n              }\n            }\n          }\n          // in case of leaderVoteWait timeout, a replica with lower term can win the election\n          if (setTermToMax) {\n            log.error(\"WARNING: Potential data loss -- Replica {} became leader after timeout (leaderVoteWait) {}\"\n                , \"without being up-to-date with the previous leader\", coreNodeName);\n            zkController.getShardTerms(collection, shardId).setTermEqualsToLeader(coreNodeName);\n          }\n          super.runLeaderProcess(weAreReplacement, 0);\n          try (SolrCore core = cc.getCore(coreName)) {\n            if (core != null) {\n              core.getCoreDescriptor().getCloudDescriptor().setLeader(true);\n              publishActiveIfRegisteredAndNotActive(core);\n            } else {\n              return;\n            }\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"I am the new leader: {} {}\", ZkCoreNodeProps.getCoreUrl(leaderProps), shardId);\n          }\n          \n          // we made it as leader - send any recovery requests we need to\n          syncStrategy.requestRecoveries();\n\n        } catch (SessionExpiredException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR,\n              \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n        } catch (Exception e) {\n          isLeader = false;\n          SolrException.log(log, \"There was a problem trying to register as the leader\", e);\n          \n          try (SolrCore core = cc.getCore(coreName)) {\n            \n            if (core == null) {\n              if (log.isDebugEnabled()) {\n                log.debug(\"SolrCore not found: {} in {}\", coreName, cc.getLoadedCoreNames());\n              }\n              return;\n            }\n            \n            core.getCoreDescriptor().getCloudDescriptor().setLeader(false);\n            \n            // we could not publish ourselves as leader - try and rejoin election\n            try {\n              rejoinLeaderElection(core);\n            } catch (SessionExpiredException exc) {\n              throw new SolrException(ErrorCode.SERVER_ERROR,\n                  \"ZK session expired - cancelling election for \" + collection + \" \" + shardId);\n            }\n          }\n        }\n      } else {\n        cancelElection();\n      }\n    } finally {\n      MDCLoggingContext.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["9f1bee4bba8988141f8357bda2ccd9405926c4e5","19498030e0adab22f604f935cae3c03dcf0952a6"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["605f94f466b936ef47220109e97eea240dff2442"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["84f20f331d8001864545c7021812d8c6509c7593"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"3f50664369ffef1e236a800ed63be02c8ccc2d29":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"89424def13674ea17829b41c5883c54ecc31a132":["af2638813028b254a88b418ebeafb541afb49653","d4169a39455be564348e51f60d4dc9f77a80c2f9"],"691d1439503ec32e198724114f6cd32446c86ac6":["61c45e99cf6676da48f19d7511c73712ad39402b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","61c45e99cf6676da48f19d7511c73712ad39402b"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["5455c7b3fed6c1671990a44c19071cb0488c2c25"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["9cef9edf6786c51f767f53339f5be3ccb5e1a491"],"be320990bdc77e643388fa801e75017f19289c42":["3f50664369ffef1e236a800ed63be02c8ccc2d29"],"ab68488225b6a6c357dda72ed11dedca9914a192":["3f50664369ffef1e236a800ed63be02c8ccc2d29","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"bb62cc3362417c3e5136f2f26d34a1072ad633eb":["a5d615d62cd8aff3690943d765e46942551f98b6"],"a516ca2094f85283226c09808a4793844564d7d1":["9339df295b9162e4c81adbb4da44b5939d27c1ef"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["be320990bdc77e643388fa801e75017f19289c42"],"19498030e0adab22f604f935cae3c03dcf0952a6":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"a5d615d62cd8aff3690943d765e46942551f98b6":["89424def13674ea17829b41c5883c54ecc31a132"],"78277631929de308318c889be36ed69ce7a85048":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["3f50664369ffef1e236a800ed63be02c8ccc2d29"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["b869898f50ca80263bac2e3ae0949f7700e5c977","691d1439503ec32e198724114f6cd32446c86ac6"],"ba33781da68babcaa5828121b443d3eb5c9d8480":["ad4957cde742defe6db19689abdc267c5d948066"],"b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd":["78277631929de308318c889be36ed69ce7a85048"],"9cef9edf6786c51f767f53339f5be3ccb5e1a491":["e332392bbbdd01cb69ad6a89051f483cda38e15e"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["ab68488225b6a6c357dda72ed11dedca9914a192"],"605f94f466b936ef47220109e97eea240dff2442":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"ad4957cde742defe6db19689abdc267c5d948066":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"84f20f331d8001864545c7021812d8c6509c7593":["691d1439503ec32e198724114f6cd32446c86ac6"],"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e","6c94d2661bc1c14426980ec7882e951fdcff08d0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["af2638813028b254a88b418ebeafb541afb49653","bb62cc3362417c3e5136f2f26d34a1072ad633eb"],"e332392bbbdd01cb69ad6a89051f483cda38e15e":["dedd8b6e67b7ac7a77554562fddcf90e0031a95c"],"dedd8b6e67b7ac7a77554562fddcf90e0031a95c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["a516ca2094f85283226c09808a4793844564d7d1"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"d4169a39455be564348e51f60d4dc9f77a80c2f9":["af2638813028b254a88b418ebeafb541afb49653"],"61c45e99cf6676da48f19d7511c73712ad39402b":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"9f1bee4bba8988141f8357bda2ccd9405926c4e5":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"9339df295b9162e4c81adbb4da44b5939d27c1ef":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["af2638813028b254a88b418ebeafb541afb49653","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["30c688f7052130cef7bd419c85e3c5be214f7b9e","5455c7b3fed6c1671990a44c19071cb0488c2c25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba33781da68babcaa5828121b443d3eb5c9d8480"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","d4169a39455be564348e51f60d4dc9f77a80c2f9","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["439c63ae5d22132fca810a0029a854e97d2c1a3e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["9339df295b9162e4c81adbb4da44b5939d27c1ef"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["5455c7b3fed6c1671990a44c19071cb0488c2c25","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"3f50664369ffef1e236a800ed63be02c8ccc2d29":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"89424def13674ea17829b41c5883c54ecc31a132":["a5d615d62cd8aff3690943d765e46942551f98b6"],"691d1439503ec32e198724114f6cd32446c86ac6":["6240b74b884c5587f2a4062dd27d6c32bf228889","84f20f331d8001864545c7021812d8c6509c7593"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["e8fa677b7b2405d2c2b902646dbae8f5fe34b60e"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"be320990bdc77e643388fa801e75017f19289c42":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"ab68488225b6a6c357dda72ed11dedca9914a192":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"bb62cc3362417c3e5136f2f26d34a1072ad633eb":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a516ca2094f85283226c09808a4793844564d7d1":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064":["78277631929de308318c889be36ed69ce7a85048"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["61c45e99cf6676da48f19d7511c73712ad39402b"],"19498030e0adab22f604f935cae3c03dcf0952a6":["af2638813028b254a88b418ebeafb541afb49653"],"a5d615d62cd8aff3690943d765e46942551f98b6":["bb62cc3362417c3e5136f2f26d34a1072ad633eb"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"78277631929de308318c889be36ed69ce7a85048":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"ba33781da68babcaa5828121b443d3eb5c9d8480":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd":["605f94f466b936ef47220109e97eea240dff2442"],"9cef9edf6786c51f767f53339f5be3ccb5e1a491":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"605f94f466b936ef47220109e97eea240dff2442":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"],"ad4957cde742defe6db19689abdc267c5d948066":["ba33781da68babcaa5828121b443d3eb5c9d8480"],"84f20f331d8001864545c7021812d8c6509c7593":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"e8fa677b7b2405d2c2b902646dbae8f5fe34b60e":["6c94d2661bc1c14426980ec7882e951fdcff08d0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3f50664369ffef1e236a800ed63be02c8ccc2d29","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dedd8b6e67b7ac7a77554562fddcf90e0031a95c"],"e332392bbbdd01cb69ad6a89051f483cda38e15e":["9cef9edf6786c51f767f53339f5be3ccb5e1a491"],"dedd8b6e67b7ac7a77554562fddcf90e0031a95c":["e332392bbbdd01cb69ad6a89051f483cda38e15e"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"d4169a39455be564348e51f60d4dc9f77a80c2f9":["89424def13674ea17829b41c5883c54ecc31a132"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["ad4957cde742defe6db19689abdc267c5d948066"],"61c45e99cf6676da48f19d7511c73712ad39402b":["691d1439503ec32e198724114f6cd32446c86ac6","e9017cf144952056066919f1ebc7897ff9bd71b1"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"9f1bee4bba8988141f8357bda2ccd9405926c4e5":["af2638813028b254a88b418ebeafb541afb49653","19498030e0adab22f604f935cae3c03dcf0952a6"],"9339df295b9162e4c81adbb4da44b5939d27c1ef":["a516ca2094f85283226c09808a4793844564d7d1"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0a22eafe3f72a4c2945eaad9547e6c78816978f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}