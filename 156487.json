{"path":"solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessor[PreAnalyzedUpdateProcessorFactory]#mutate(SolrInputField).mjava","commits":[{"id":"6c7ac188e4a03a976c95993dc3cd292df966faa4","date":1365151572,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessor[PreAnalyzedUpdateProcessorFactory]#mutate(SolrInputField).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected SolrInputField mutate(SolrInputField src) {\n    SchemaField sf = schema.getFieldOrNull(src.getName());\n    if (sf == null) { // remove this field\n      return null;\n    }\n    FieldType type = PreAnalyzedField.createFieldType(sf);\n    if (type == null) { // neither indexed nor stored - skip\n      return null;\n    }\n    SolrInputField res = new SolrInputField(src.getName());\n    res.setBoost(src.getBoost());\n    for (Object o : src) {\n      if (o == null) {\n        continue;\n      }\n      Field pre = (Field)parser.createField(sf, o, 1.0f);\n      if (pre != null) {\n        res.addValue(pre, 1.0f);\n      } else { // restore the original value\n        log.warn(\"Could not parse field {} - using original value as is: {}\", src.getName(), o);\n        res.addValue(o, 1.0f);\n      }\n    }\n    return res;\n  }  \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessor[PreAnalyzedUpdateProcessorFactory]#mutate(SolrInputField).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessor[PreAnalyzedUpdateProcessorFactory]#mutate(SolrInputField).mjava","sourceNew":"  @Override\n  protected SolrInputField mutate(SolrInputField src) {\n    SchemaField sf = schema.getFieldOrNull(src.getName());\n    if (sf == null) { // remove this field\n      return null;\n    }\n    FieldType type = PreAnalyzedField.createFieldType(sf);\n    if (type == null) { // neither indexed nor stored - skip\n      return null;\n    }\n    SolrInputField res = new SolrInputField(src.getName());\n    for (Object o : src) {\n      if (o == null) {\n        continue;\n      }\n      Field pre = (Field)parser.createField(sf, o);\n      if (pre != null) {\n        res.addValue(pre);\n      } else { // restore the original value\n        log.warn(\"Could not parse field {} - using original value as is: {}\", src.getName(), o);\n        res.addValue(o);\n      }\n    }\n    return res;\n  }  \n\n","sourceOld":"  @Override\n  protected SolrInputField mutate(SolrInputField src) {\n    SchemaField sf = schema.getFieldOrNull(src.getName());\n    if (sf == null) { // remove this field\n      return null;\n    }\n    FieldType type = PreAnalyzedField.createFieldType(sf);\n    if (type == null) { // neither indexed nor stored - skip\n      return null;\n    }\n    SolrInputField res = new SolrInputField(src.getName());\n    res.setBoost(src.getBoost());\n    for (Object o : src) {\n      if (o == null) {\n        continue;\n      }\n      Field pre = (Field)parser.createField(sf, o, 1.0f);\n      if (pre != null) {\n        res.addValue(pre, 1.0f);\n      } else { // restore the original value\n        log.warn(\"Could not parse field {} - using original value as is: {}\", src.getName(), o);\n        res.addValue(o, 1.0f);\n      }\n    }\n    return res;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessor[PreAnalyzedUpdateProcessorFactory]#mutate(SolrInputField).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessor[PreAnalyzedUpdateProcessorFactory]#mutate(SolrInputField).mjava","sourceNew":"  @Override\n  protected SolrInputField mutate(SolrInputField src) {\n    SchemaField sf = schema.getFieldOrNull(src.getName());\n    if (sf == null) { // remove this field\n      return null;\n    }\n    FieldType type = PreAnalyzedField.createFieldType(sf);\n    if (type == null) { // neither indexed nor stored - skip\n      return null;\n    }\n    SolrInputField res = new SolrInputField(src.getName());\n    for (Object o : src) {\n      if (o == null) {\n        continue;\n      }\n      Field pre = (Field)parser.createField(sf, o);\n      if (pre != null) {\n        res.addValue(pre);\n      } else { // restore the original value\n        if (log.isWarnEnabled()) {\n          log.warn(\"Could not parse field {} - using original value as is: {}\", src.getName(), o);\n        }\n        res.addValue(o);\n      }\n    }\n    return res;\n  }  \n\n","sourceOld":"  @Override\n  protected SolrInputField mutate(SolrInputField src) {\n    SchemaField sf = schema.getFieldOrNull(src.getName());\n    if (sf == null) { // remove this field\n      return null;\n    }\n    FieldType type = PreAnalyzedField.createFieldType(sf);\n    if (type == null) { // neither indexed nor stored - skip\n      return null;\n    }\n    SolrInputField res = new SolrInputField(src.getName());\n    for (Object o : src) {\n      if (o == null) {\n        continue;\n      }\n      Field pre = (Field)parser.createField(sf, o);\n      if (pre != null) {\n        res.addValue(pre);\n      } else { // restore the original value\n        log.warn(\"Could not parse field {} - using original value as is: {}\", src.getName(), o);\n        res.addValue(o);\n      }\n    }\n    return res;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessor[PreAnalyzedUpdateProcessorFactory]#mutate(SolrInputField).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/PreAnalyzedUpdateProcessor[PreAnalyzedUpdateProcessorFactory]#mutate(SolrInputField).mjava","sourceNew":"  @Override\n  protected SolrInputField mutate(SolrInputField src) {\n    SchemaField sf = schema.getFieldOrNull(src.getName());\n    if (sf == null) { // remove this field\n      return null;\n    }\n    FieldType type = PreAnalyzedField.createFieldType(sf);\n    if (type == null) { // neither indexed nor stored - skip\n      return null;\n    }\n    SolrInputField res = new SolrInputField(src.getName());\n    for (Object o : src) {\n      if (o == null) {\n        continue;\n      }\n      Field pre = (Field)parser.createField(sf, o);\n      if (pre != null) {\n        res.addValue(pre);\n      } else { // restore the original value\n        log.warn(\"Could not parse field {} - using original value as is: {}\", src.getName(), o);\n        res.addValue(o);\n      }\n    }\n    return res;\n  }  \n\n","sourceOld":"  @Override\n  protected SolrInputField mutate(SolrInputField src) {\n    SchemaField sf = schema.getFieldOrNull(src.getName());\n    if (sf == null) { // remove this field\n      return null;\n    }\n    FieldType type = PreAnalyzedField.createFieldType(sf);\n    if (type == null) { // neither indexed nor stored - skip\n      return null;\n    }\n    SolrInputField res = new SolrInputField(src.getName());\n    for (Object o : src) {\n      if (o == null) {\n        continue;\n      }\n      Field pre = (Field)parser.createField(sf, o);\n      if (pre != null) {\n        res.addValue(pre);\n      } else { // restore the original value\n        if (log.isWarnEnabled()) {\n          log.warn(\"Could not parse field {} - using original value as is: {}\", src.getName(), o);\n        }\n        res.addValue(o);\n      }\n    }\n    return res;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"740d649f013f07efbeb73ca854f106c60166e7c0":["acd9883560fd89e6448b2b447302fe543040cd4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"acd9883560fd89e6448b2b447302fe543040cd4f":["6c7ac188e4a03a976c95993dc3cd292df966faa4"],"6c7ac188e4a03a976c95993dc3cd292df966faa4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"740d649f013f07efbeb73ca854f106c60166e7c0":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6c7ac188e4a03a976c95993dc3cd292df966faa4"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"acd9883560fd89e6448b2b447302fe543040cd4f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"6c7ac188e4a03a976c95993dc3cd292df966faa4":["acd9883560fd89e6448b2b447302fe543040cd4f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}