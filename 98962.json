{"path":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","commits":[{"id":"2e18c86f811939bfa8cd24046c96ed026f2e9b34","date":1393893071,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<Scorer>();\n      List<Scorer> prohibited = new ArrayList<Scorer>();\n      List<Scorer> optional = new ArrayList<Scorer>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<Scorer>();\n      List<Scorer> prohibited = new ArrayList<Scorer>();\n      List<Scorer> optional = new ArrayList<Scorer>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, true, false, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      // NOTE: we could also use BooleanScorer, if we knew\n      // this BooleanQuery was embedded in another\n      // BooleanQuery that was also using BooleanScorer (ie,\n      // BooleanScorer can nest).  But this is hard to\n      // detect and we never do so today... (ie, we only\n      // return BooleanScorer for topScorer):\n\n      // Check if we can and should return a BooleanScorer\n      // TODO: (LUCENE-4872) in some cases BooleanScorer may be faster for minNrShouldMatch\n      // but the same is even true of pure conjunctions...\n      if (!scoreDocsInOrder && topScorer && required.size() == 0 && minNrShouldMatch <= 1) {\n        return new BooleanScorer(this, disableCoord, minNrShouldMatch, optional, prohibited, maxCoord);\n      }\n      \n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acf00221f44c5f08ccea014f2492b53af15ecd66","date":1394568293,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,boolean,boolean,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<Scorer>();\n      List<Scorer> prohibited = new ArrayList<Scorer>();\n      List<Scorer> optional = new ArrayList<Scorer>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder,\n        boolean topScorer, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<Scorer>();\n      List<Scorer> prohibited = new ArrayList<Scorer>();\n      List<Scorer> optional = new ArrayList<Scorer>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, true, false, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      // NOTE: we could also use BooleanScorer, if we knew\n      // this BooleanQuery was embedded in another\n      // BooleanQuery that was also using BooleanScorer (ie,\n      // BooleanScorer can nest).  But this is hard to\n      // detect and we never do so today... (ie, we only\n      // return BooleanScorer for topScorer):\n\n      // Check if we can and should return a BooleanScorer\n      // TODO: (LUCENE-4872) in some cases BooleanScorer may be faster for minNrShouldMatch\n      // but the same is even true of pure conjunctions...\n      if (!scoreDocsInOrder && topScorer && required.size() == 0 && minNrShouldMatch <= 1) {\n        return new BooleanScorer(this, disableCoord, minNrShouldMatch, optional, prohibited, maxCoord);\n      }\n      \n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<Scorer>();\n      List<Scorer> prohibited = new ArrayList<Scorer>();\n      List<Scorer> optional = new ArrayList<Scorer>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9c2895bfaa94bdbd1fd5a1b1522f6310c91d240","date":1400613895,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      // initially the user provided value,\n      // but if minNrShouldMatch == optional.size(),\n      // we will optimize and move these to required, making this 0\n      int minShouldMatch = minNrShouldMatch;\n\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n      \n      // scorer simplifications:\n      if (required.isEmpty() && optional.isEmpty()) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      } else if (optional.size() == minShouldMatch) {\n        // either we have no optional clauses, or they are all required\n        // nocommit: what if required is empty too?\n        required.addAll(optional);\n        optional.clear();\n        minShouldMatch = 0;\n      }\n      \n      // pure conjunction\n      if (optional.isEmpty()) {\n        return excl(req(required, disableCoord), prohibited);\n      }\n      \n      // pure disjunction\n      if (required.isEmpty()) {\n        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n      }\n      \n      // conjunction-disjunction mix\n      Scorer req = excl(req(required, true), prohibited);\n      Scorer opt = opt(optional, minShouldMatch, true);\n\n      // TODO: clean this up: its horrible\n      if (disableCoord) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n        } else {\n          return new ReqOptSumScorer(req, opt);          \n        }\n      } else if (optional.size() == 1) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n        } else {\n          float coordReq = coord(required.size(), maxCoord);\n          float coordBoth = coord(required.size() + 1, maxCoord);\n          return new ReqOptSumScorer.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n        }\n      } else {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n        } else {\n          return new ReqOptSumScorer.ReqMultiOptScorer(req, opt, required.size(), coords()); \n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2cdc8a177cc608482424e349819a116a88f53152","date":1400638515,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      // initially the user provided value,\n      // but if minNrShouldMatch == optional.size(),\n      // we will optimize and move these to required, making this 0\n      int minShouldMatch = minNrShouldMatch;\n\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n      \n      // scorer simplifications:\n      \n      if (optional.size() == minShouldMatch) {\n        // any optional clauses are in fact required\n        required.addAll(optional);\n        optional.clear();\n        minShouldMatch = 0;\n      }\n      \n      if (required.isEmpty() && optional.isEmpty()) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // three cases: conjunction, disjunction, or mix\n      \n      // pure conjunction\n      if (optional.isEmpty()) {\n        return excl(req(required, disableCoord), prohibited);\n      }\n      \n      // pure disjunction\n      if (required.isEmpty()) {\n        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n      }\n      \n      // conjunction-disjunction mix:\n      // we create the required and optional pieces with coord disabled, and then\n      // combine the two: if minNrShouldMatch > 0, then its a conjunction: because the\n      // optional side must match. otherwise its required + optional, factoring the\n      // number of optional terms into the coord calculation\n      \n      Scorer req = excl(req(required, true), prohibited);\n      Scorer opt = opt(optional, minShouldMatch, true);\n\n      // TODO: clean this up: its horrible\n      if (disableCoord) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n        } else {\n          return new ReqOptSumScorer(req, opt);          \n        }\n      } else if (optional.size() == 1) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n        } else {\n          float coordReq = coord(required.size(), maxCoord);\n          float coordBoth = coord(required.size() + 1, maxCoord);\n          return new ReqOptSumScorer.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n        }\n      } else {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n        } else {\n          return new ReqOptSumScorer.ReqMultiOptScorer(req, opt, required.size(), coords()); \n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      // initially the user provided value,\n      // but if minNrShouldMatch == optional.size(),\n      // we will optimize and move these to required, making this 0\n      int minShouldMatch = minNrShouldMatch;\n\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n      \n      // scorer simplifications:\n      if (required.isEmpty() && optional.isEmpty()) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      } else if (optional.size() == minShouldMatch) {\n        // either we have no optional clauses, or they are all required\n        // nocommit: what if required is empty too?\n        required.addAll(optional);\n        optional.clear();\n        minShouldMatch = 0;\n      }\n      \n      // pure conjunction\n      if (optional.isEmpty()) {\n        return excl(req(required, disableCoord), prohibited);\n      }\n      \n      // pure disjunction\n      if (required.isEmpty()) {\n        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n      }\n      \n      // conjunction-disjunction mix\n      Scorer req = excl(req(required, true), prohibited);\n      Scorer opt = opt(optional, minShouldMatch, true);\n\n      // TODO: clean this up: its horrible\n      if (disableCoord) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n        } else {\n          return new ReqOptSumScorer(req, opt);          \n        }\n      } else if (optional.size() == 1) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n        } else {\n          float coordReq = coord(required.size(), maxCoord);\n          float coordBoth = coord(required.size() + 1, maxCoord);\n          return new ReqOptSumScorer.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n        }\n      } else {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n        } else {\n          return new ReqOptSumScorer.ReqMultiOptScorer(req, opt, required.size(), coords()); \n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"060a4836b54f1e7e79ea6493cda5dc3030d3fb0e","date":1400639845,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      // initially the user provided value,\n      // but if minNrShouldMatch == optional.size(),\n      // we will optimize and move these to required, making this 0\n      int minShouldMatch = minNrShouldMatch;\n\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n      \n      // scorer simplifications:\n      \n      if (optional.size() == minShouldMatch) {\n        // any optional clauses are in fact required\n        required.addAll(optional);\n        optional.clear();\n        minShouldMatch = 0;\n      }\n      \n      if (required.isEmpty() && optional.isEmpty()) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // three cases: conjunction, disjunction, or mix\n      \n      // pure conjunction\n      if (optional.isEmpty()) {\n        return excl(req(required, disableCoord), prohibited);\n      }\n      \n      // pure disjunction\n      if (required.isEmpty()) {\n        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n      }\n      \n      // conjunction-disjunction mix:\n      // we create the required and optional pieces with coord disabled, and then\n      // combine the two: if minNrShouldMatch > 0, then its a conjunction: because the\n      // optional side must match. otherwise its required + optional, factoring the\n      // number of optional terms into the coord calculation\n      \n      Scorer req = excl(req(required, true), prohibited);\n      Scorer opt = opt(optional, minShouldMatch, true);\n\n      // TODO: clean this up: its horrible\n      if (disableCoord) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n        } else {\n          return new ReqOptSumScorer(req, opt);          \n        }\n      } else if (optional.size() == 1) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n        } else {\n          float coordReq = coord(required.size(), maxCoord);\n          float coordBoth = coord(required.size() + 1, maxCoord);\n          return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n        }\n      } else {\n        if (minShouldMatch > 0) {\n          return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n        } else {\n          return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, required.size(), coords()); \n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      // initially the user provided value,\n      // but if minNrShouldMatch == optional.size(),\n      // we will optimize and move these to required, making this 0\n      int minShouldMatch = minNrShouldMatch;\n\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n      \n      // scorer simplifications:\n      \n      if (optional.size() == minShouldMatch) {\n        // any optional clauses are in fact required\n        required.addAll(optional);\n        optional.clear();\n        minShouldMatch = 0;\n      }\n      \n      if (required.isEmpty() && optional.isEmpty()) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // three cases: conjunction, disjunction, or mix\n      \n      // pure conjunction\n      if (optional.isEmpty()) {\n        return excl(req(required, disableCoord), prohibited);\n      }\n      \n      // pure disjunction\n      if (required.isEmpty()) {\n        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n      }\n      \n      // conjunction-disjunction mix:\n      // we create the required and optional pieces with coord disabled, and then\n      // combine the two: if minNrShouldMatch > 0, then its a conjunction: because the\n      // optional side must match. otherwise its required + optional, factoring the\n      // number of optional terms into the coord calculation\n      \n      Scorer req = excl(req(required, true), prohibited);\n      Scorer opt = opt(optional, minShouldMatch, true);\n\n      // TODO: clean this up: its horrible\n      if (disableCoord) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n        } else {\n          return new ReqOptSumScorer(req, opt);          \n        }\n      } else if (optional.size() == 1) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n        } else {\n          float coordReq = coord(required.size(), maxCoord);\n          float coordBoth = coord(required.size() + 1, maxCoord);\n          return new ReqOptSumScorer.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n        }\n      } else {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n        } else {\n          return new ReqOptSumScorer.ReqMultiOptScorer(req, opt, required.size(), coords()); \n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38fa8e2c4105a7dd15d7e9260afa3b41a560d51d","date":1400696679,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      // initially the user provided value,\n      // but if minNrShouldMatch == optional.size(),\n      // we will optimize and move these to required, making this 0\n      int minShouldMatch = minNrShouldMatch;\n\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n      \n      // scorer simplifications:\n      \n      if (optional.size() == minShouldMatch) {\n        // any optional clauses are in fact required\n        required.addAll(optional);\n        optional.clear();\n        minShouldMatch = 0;\n      }\n      \n      if (required.isEmpty() && optional.isEmpty()) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // three cases: conjunction, disjunction, or mix\n      \n      // pure conjunction\n      if (optional.isEmpty()) {\n        return excl(req(required, disableCoord), prohibited);\n      }\n      \n      // pure disjunction\n      if (required.isEmpty()) {\n        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n      }\n      \n      // conjunction-disjunction mix:\n      // we create the required and optional pieces with coord disabled, and then\n      // combine the two: if minNrShouldMatch > 0, then its a conjunction: because the\n      // optional side must match. otherwise its required + optional, factoring the\n      // number of optional terms into the coord calculation\n      \n      Scorer req = excl(req(required, true), prohibited);\n      Scorer opt = opt(optional, minShouldMatch, true);\n\n      // TODO: clean this up: its horrible\n      if (disableCoord) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n        } else {\n          return new ReqOptSumScorer(req, opt);          \n        }\n      } else if (optional.size() == 1) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n        } else {\n          float coordReq = coord(required.size(), maxCoord);\n          float coordBoth = coord(required.size() + 1, maxCoord);\n          return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n        }\n      } else {\n        if (minShouldMatch > 0) {\n          return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n        } else {\n          return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, required.size(), coords()); \n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","sourceNew":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      // initially the user provided value,\n      // but if minNrShouldMatch == optional.size(),\n      // we will optimize and move these to required, making this 0\n      int minShouldMatch = minNrShouldMatch;\n\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n      \n      // scorer simplifications:\n      \n      if (optional.size() == minShouldMatch) {\n        // any optional clauses are in fact required\n        required.addAll(optional);\n        optional.clear();\n        minShouldMatch = 0;\n      }\n      \n      if (required.isEmpty() && optional.isEmpty()) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // three cases: conjunction, disjunction, or mix\n      \n      // pure conjunction\n      if (optional.isEmpty()) {\n        return excl(req(required, disableCoord), prohibited);\n      }\n      \n      // pure disjunction\n      if (required.isEmpty()) {\n        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n      }\n      \n      // conjunction-disjunction mix:\n      // we create the required and optional pieces with coord disabled, and then\n      // combine the two: if minNrShouldMatch > 0, then its a conjunction: because the\n      // optional side must match. otherwise its required + optional, factoring the\n      // number of optional terms into the coord calculation\n      \n      Scorer req = excl(req(required, true), prohibited);\n      Scorer opt = opt(optional, minShouldMatch, true);\n\n      // TODO: clean this up: its horrible\n      if (disableCoord) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n        } else {\n          return new ReqOptSumScorer(req, opt);          \n        }\n      } else if (optional.size() == 1) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n        } else {\n          float coordReq = coord(required.size(), maxCoord);\n          float coordBoth = coord(required.size() + 1, maxCoord);\n          return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n        }\n      } else {\n        if (minShouldMatch > 0) {\n          return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n        } else {\n          return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, required.size(), coords()); \n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n\n      if (required.size() == 0 && optional.size() == 0) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minNrShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // simple conjunction\n      if (optional.size() == 0 && prohibited.size() == 0) {\n        float coord = disableCoord ? 1.0f : coord(required.size(), maxCoord);\n        return new ConjunctionScorer(this, required.toArray(new Scorer[required.size()]), coord);\n      }\n      \n      // simple disjunction\n      if (required.size() == 0 && prohibited.size() == 0 && minNrShouldMatch <= 1 && optional.size() > 1) {\n        float coord[] = new float[optional.size()+1];\n        for (int i = 0; i < coord.length; i++) {\n          coord[i] = disableCoord ? 1.0f : coord(i, maxCoord);\n        }\n        return new DisjunctionSumScorer(this, optional.toArray(new Scorer[optional.size()]), coord);\n      }\n      \n      // Return a BooleanScorer2\n      return new BooleanScorer2(this, disableCoord, minNrShouldMatch, required, prohibited, optional, maxCoord);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":4,"author":"Ryan Ernst","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(AtomicReaderContext,Bits).mjava","sourceNew":null,"sourceOld":"    @Override\n    public Scorer scorer(AtomicReaderContext context, Bits acceptDocs)\n        throws IOException {\n      // initially the user provided value,\n      // but if minNrShouldMatch == optional.size(),\n      // we will optimize and move these to required, making this 0\n      int minShouldMatch = minNrShouldMatch;\n\n      List<Scorer> required = new ArrayList<>();\n      List<Scorer> prohibited = new ArrayList<>();\n      List<Scorer> optional = new ArrayList<>();\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Weight w  : weights) {\n        BooleanClause c =  cIter.next();\n        Scorer subScorer = w.scorer(context, acceptDocs);\n        if (subScorer == null) {\n          if (c.isRequired()) {\n            return null;\n          }\n        } else if (c.isRequired()) {\n          required.add(subScorer);\n        } else if (c.isProhibited()) {\n          prohibited.add(subScorer);\n        } else {\n          optional.add(subScorer);\n        }\n      }\n      \n      // scorer simplifications:\n      \n      if (optional.size() == minShouldMatch) {\n        // any optional clauses are in fact required\n        required.addAll(optional);\n        optional.clear();\n        minShouldMatch = 0;\n      }\n      \n      if (required.isEmpty() && optional.isEmpty()) {\n        // no required and optional clauses.\n        return null;\n      } else if (optional.size() < minShouldMatch) {\n        // either >1 req scorer, or there are 0 req scorers and at least 1\n        // optional scorer. Therefore if there are not enough optional scorers\n        // no documents will be matched by the query\n        return null;\n      }\n      \n      // three cases: conjunction, disjunction, or mix\n      \n      // pure conjunction\n      if (optional.isEmpty()) {\n        return excl(req(required, disableCoord), prohibited);\n      }\n      \n      // pure disjunction\n      if (required.isEmpty()) {\n        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);\n      }\n      \n      // conjunction-disjunction mix:\n      // we create the required and optional pieces with coord disabled, and then\n      // combine the two: if minNrShouldMatch > 0, then its a conjunction: because the\n      // optional side must match. otherwise its required + optional, factoring the\n      // number of optional terms into the coord calculation\n      \n      Scorer req = excl(req(required, true), prohibited);\n      Scorer opt = opt(optional, minShouldMatch, true);\n\n      // TODO: clean this up: its horrible\n      if (disableCoord) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);\n        } else {\n          return new ReqOptSumScorer(req, opt);          \n        }\n      } else if (optional.size() == 1) {\n        if (minShouldMatch > 0) {\n          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));\n        } else {\n          float coordReq = coord(required.size(), maxCoord);\n          float coordBoth = coord(required.size() + 1, maxCoord);\n          return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);\n        }\n      } else {\n        if (minShouldMatch > 0) {\n          return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);\n        } else {\n          return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, required.size(), coords()); \n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"d9c2895bfaa94bdbd1fd5a1b1522f6310c91d240":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2cdc8a177cc608482424e349819a116a88f53152":["d9c2895bfaa94bdbd1fd5a1b1522f6310c91d240"],"b7605579001505896d48b07160075a5c8b8e128e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","38fa8e2c4105a7dd15d7e9260afa3b41a560d51d"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2e18c86f811939bfa8cd24046c96ed026f2e9b34"],"060a4836b54f1e7e79ea6493cda5dc3030d3fb0e":["2cdc8a177cc608482424e349819a116a88f53152"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["38fa8e2c4105a7dd15d7e9260afa3b41a560d51d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"38fa8e2c4105a7dd15d7e9260afa3b41a560d51d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","060a4836b54f1e7e79ea6493cda5dc3030d3fb0e"]},"commit2Childs":{"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d9c2895bfaa94bdbd1fd5a1b1522f6310c91d240","b7605579001505896d48b07160075a5c8b8e128e","38fa8e2c4105a7dd15d7e9260afa3b41a560d51d"],"d9c2895bfaa94bdbd1fd5a1b1522f6310c91d240":["2cdc8a177cc608482424e349819a116a88f53152"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2e18c86f811939bfa8cd24046c96ed026f2e9b34","acf00221f44c5f08ccea014f2492b53af15ecd66"],"2cdc8a177cc608482424e349819a116a88f53152":["060a4836b54f1e7e79ea6493cda5dc3030d3fb0e"],"b7605579001505896d48b07160075a5c8b8e128e":[],"acf00221f44c5f08ccea014f2492b53af15ecd66":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"060a4836b54f1e7e79ea6493cda5dc3030d3fb0e":["38fa8e2c4105a7dd15d7e9260afa3b41a560d51d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"38fa8e2c4105a7dd15d7e9260afa3b41a560d51d":["b7605579001505896d48b07160075a5c8b8e128e","c9fb5f46e264daf5ba3860defe623a89d202dd87"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}