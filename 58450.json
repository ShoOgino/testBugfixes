{"path":"solr/core/src/java/org/apache/solr/search/PointSetQuery[GraphTermsQParserPlugin]#PointSetQuery(String,int,int,Stream).mjava","commits":[{"id":"e05158fccbb5082f97e4ae2566c5ecfb9df35b7a","date":1501604915,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/PointSetQuery[GraphTermsQParserPlugin]#PointSetQuery(String,int,int,Stream).mjava","pathOld":"/dev/null","sourceNew":"  public PointSetQuery(String field, int numDims, int bytesPerDim, Stream packedPoints) {\n    this.field = field;\n    this.bytesPerDim = bytesPerDim;\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/PointSetQuery[GraphTermsQParserPlugin]#PointSetQuery(String,int,int,Stream).mjava","pathOld":"/dev/null","sourceNew":"  public PointSetQuery(String field, int numDims, int bytesPerDim, Stream packedPoints) {\n    this.field = field;\n    this.bytesPerDim = bytesPerDim;\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a71ca10e7131e1f01868c80d228f26a855e79dd0","date":1562166223,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/PointSetQuery[GraphTermsQParserPlugin]#PointSetQuery(String,int,int,Stream).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/PointSetQuery[GraphTermsQParserPlugin]#PointSetQuery(String,int,int,Stream).mjava","sourceNew":"  public PointSetQuery(String field, int numDims, int bytesPerDim, Stream packedPoints) {\n    this.field = field;\n    this.bytesPerDim = bytesPerDim;\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n    ramBytesUsed = BASE_RAM_BYTES +\n        RamUsageEstimator.sizeOfObject(sortedPackedPoints);\n  }\n\n","sourceOld":"  public PointSetQuery(String field, int numDims, int bytesPerDim, Stream packedPoints) {\n    this.field = field;\n    this.bytesPerDim = bytesPerDim;\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e05158fccbb5082f97e4ae2566c5ecfb9df35b7a"],"e05158fccbb5082f97e4ae2566c5ecfb9df35b7a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a71ca10e7131e1f01868c80d228f26a855e79dd0":["e05158fccbb5082f97e4ae2566c5ecfb9df35b7a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a71ca10e7131e1f01868c80d228f26a855e79dd0"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"e05158fccbb5082f97e4ae2566c5ecfb9df35b7a":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","a71ca10e7131e1f01868c80d228f26a855e79dd0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","e05158fccbb5082f97e4ae2566c5ecfb9df35b7a"],"a71ca10e7131e1f01868c80d228f26a855e79dd0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}