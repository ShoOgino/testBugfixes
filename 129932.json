{"path":"src/java/org/apache/lucene/index/SegmentReader#get(boolean,Directory,SegmentInfo,int,boolean).mjava","commits":[{"id":"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1","date":1244392278,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#get(boolean,Directory,SegmentInfo,int,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#initialize(SegmentInfo,int,boolean).mjava","sourceNew":"  /**\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static SegmentReader get(boolean readOnly,\n                                  Directory dir,\n                                  SegmentInfo si,\n                                  int readBufferSize,\n                                  boolean doOpenStores)\n    throws CorruptIndexException, IOException {\n    SegmentReader instance;\n    try {\n      if (readOnly)\n        instance = (SegmentReader)READONLY_IMPL.newInstance();\n      else\n        instance = (SegmentReader)IMPL.newInstance();\n    } catch (Exception e) {\n      throw new RuntimeException(\"cannot load SegmentReader class: \" + e, e);\n    }\n    instance.directory = dir;\n    instance.readOnly = readOnly;\n    instance.segment = si.name;\n    instance.si = si;\n    instance.readBufferSize = readBufferSize;\n\n    boolean success = false;\n\n    try {\n      // Use compound file directory for some files, if it exists\n      Directory cfsDir = instance.directory();\n      if (si.getUseCompoundFile()) {\n        instance.cfsReader = new CompoundFileReader(instance.directory(), instance.segment + \".\" + IndexFileNames.COMPOUND_FILE_EXTENSION, readBufferSize);\n        cfsDir = instance.cfsReader;\n      }\n\n      instance.fieldInfos = new FieldInfos(cfsDir, instance.segment + \".fnm\");\n\n      if (doOpenStores) {\n        instance.openDocStores();\n      }\n\n      boolean anyProx = false;\n      final int numFields = instance.fieldInfos.size();\n      for(int i=0;!anyProx && i<numFields;i++)\n        if (!instance.fieldInfos.fieldInfo(i).omitTermFreqAndPositions)\n          anyProx = true;\n\n      instance.tis = new TermInfosReader(cfsDir, instance.segment, instance.fieldInfos, readBufferSize);\n\n      instance.loadDeletedDocs();\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      instance.freqStream = cfsDir.openInput(instance.segment + \".frq\", readBufferSize);\n      if (anyProx)\n        instance.proxStream = cfsDir.openInput(instance.segment + \".prx\", readBufferSize);\n      instance.openNorms(cfsDir, readBufferSize);\n\n      success = true;\n    } finally {\n\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        instance.doClose();\n      }\n    }\n    return instance;\n  }\n\n","sourceOld":"  private void initialize(SegmentInfo si, int readBufferSize, boolean doOpenStores) throws CorruptIndexException, IOException {\n    segment = si.name;\n    this.si = si;\n    this.readBufferSize = readBufferSize;\n\n    boolean success = false;\n\n    try {\n      // Use compound file directory for some files, if it exists\n      Directory cfsDir = directory();\n      if (si.getUseCompoundFile()) {\n        cfsReader = new CompoundFileReader(directory(), segment + \".\" + IndexFileNames.COMPOUND_FILE_EXTENSION, readBufferSize);\n        cfsDir = cfsReader;\n      }\n\n      fieldInfos = new FieldInfos(cfsDir, segment + \".fnm\");\n\n      if (doOpenStores) {\n        openDocStores();\n      }\n\n      boolean anyProx = false;\n      final int numFields = fieldInfos.size();\n      for(int i=0;!anyProx && i<numFields;i++)\n        if (!fieldInfos.fieldInfo(i).omitTermFreqAndPositions)\n          anyProx = true;\n\n      tis = new TermInfosReader(cfsDir, segment, fieldInfos, readBufferSize);\n      \n      loadDeletedDocs();\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      freqStream = cfsDir.openInput(segment + \".frq\", readBufferSize);\n      if (anyProx)\n        proxStream = cfsDir.openInput(segment + \".prx\", readBufferSize);\n      openNorms(cfsDir, readBufferSize);\n\n      success = true;\n    } finally {\n\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        doClose();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5e023aa3e1228b8ccacdc30d852eb88e996d1b2","date":1247229077,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#get(boolean,Directory,SegmentInfo,int,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#get(boolean,Directory,SegmentInfo,int,boolean).mjava","sourceNew":"  /**\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static SegmentReader get(boolean readOnly,\n                                  Directory dir,\n                                  SegmentInfo si,\n                                  int readBufferSize,\n                                  boolean doOpenStores)\n    throws CorruptIndexException, IOException {\n    SegmentReader instance;\n    try {\n      if (readOnly)\n        instance = (SegmentReader)READONLY_IMPL.newInstance();\n      else\n        instance = (SegmentReader)IMPL.newInstance();\n    } catch (Exception e) {\n      throw new RuntimeException(\"cannot load SegmentReader class: \" + e, e);\n    }\n    instance.directory = dir;\n    instance.readOnly = readOnly;\n    instance.segment = si.name;\n    instance.si = si;\n    instance.readBufferSize = readBufferSize;\n\n    boolean success = false;\n\n    try {\n      // Use compound file directory for some files, if it exists\n      Directory cfsDir = instance.directory();\n      if (si.getUseCompoundFile()) {\n        instance.cfsReader = new CompoundFileReader(instance.directory(), instance.segment + \".\" + IndexFileNames.COMPOUND_FILE_EXTENSION, readBufferSize);\n        cfsDir = instance.cfsReader;\n      }\n\n      instance.fieldInfos = new FieldInfos(cfsDir, instance.segment + \".fnm\");\n\n      if (doOpenStores) {\n        instance.openDocStores();\n      }\n\n      boolean anyProx = instance.fieldInfos.hasProx();\n\n      instance.tis = new TermInfosReader(cfsDir, instance.segment, instance.fieldInfos, readBufferSize);\n\n      instance.loadDeletedDocs();\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      instance.freqStream = cfsDir.openInput(instance.segment + \".frq\", readBufferSize);\n      if (anyProx)\n        instance.proxStream = cfsDir.openInput(instance.segment + \".prx\", readBufferSize);\n      instance.openNorms(cfsDir, readBufferSize);\n\n      success = true;\n    } finally {\n\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        instance.doClose();\n      }\n    }\n    return instance;\n  }\n\n","sourceOld":"  /**\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static SegmentReader get(boolean readOnly,\n                                  Directory dir,\n                                  SegmentInfo si,\n                                  int readBufferSize,\n                                  boolean doOpenStores)\n    throws CorruptIndexException, IOException {\n    SegmentReader instance;\n    try {\n      if (readOnly)\n        instance = (SegmentReader)READONLY_IMPL.newInstance();\n      else\n        instance = (SegmentReader)IMPL.newInstance();\n    } catch (Exception e) {\n      throw new RuntimeException(\"cannot load SegmentReader class: \" + e, e);\n    }\n    instance.directory = dir;\n    instance.readOnly = readOnly;\n    instance.segment = si.name;\n    instance.si = si;\n    instance.readBufferSize = readBufferSize;\n\n    boolean success = false;\n\n    try {\n      // Use compound file directory for some files, if it exists\n      Directory cfsDir = instance.directory();\n      if (si.getUseCompoundFile()) {\n        instance.cfsReader = new CompoundFileReader(instance.directory(), instance.segment + \".\" + IndexFileNames.COMPOUND_FILE_EXTENSION, readBufferSize);\n        cfsDir = instance.cfsReader;\n      }\n\n      instance.fieldInfos = new FieldInfos(cfsDir, instance.segment + \".fnm\");\n\n      if (doOpenStores) {\n        instance.openDocStores();\n      }\n\n      boolean anyProx = false;\n      final int numFields = instance.fieldInfos.size();\n      for(int i=0;!anyProx && i<numFields;i++)\n        if (!instance.fieldInfos.fieldInfo(i).omitTermFreqAndPositions)\n          anyProx = true;\n\n      instance.tis = new TermInfosReader(cfsDir, instance.segment, instance.fieldInfos, readBufferSize);\n\n      instance.loadDeletedDocs();\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      instance.freqStream = cfsDir.openInput(instance.segment + \".frq\", readBufferSize);\n      if (anyProx)\n        instance.proxStream = cfsDir.openInput(instance.segment + \".prx\", readBufferSize);\n      instance.openNorms(cfsDir, readBufferSize);\n\n      success = true;\n    } finally {\n\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        instance.doClose();\n      }\n    }\n    return instance;\n  }\n\n","bugFix":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66f3dadb253a44f4cccc81c8a21b685b18b201fb","date":1247245699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#get(boolean,Directory,SegmentInfo,int,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#get(boolean,Directory,SegmentInfo,int,boolean).mjava","sourceNew":"  /**\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static SegmentReader get(boolean readOnly,\n                                  Directory dir,\n                                  SegmentInfo si,\n                                  int readBufferSize,\n                                  boolean doOpenStores)\n    throws CorruptIndexException, IOException {\n    SegmentReader instance;\n    try {\n      if (readOnly)\n        instance = (SegmentReader)READONLY_IMPL.newInstance();\n      else\n        instance = (SegmentReader)IMPL.newInstance();\n    } catch (Exception e) {\n      throw new RuntimeException(\"cannot load SegmentReader class: \" + e, e);\n    }\n    instance.readOnly = readOnly;\n    instance.si = si;\n    instance.readBufferSize = readBufferSize;\n\n    boolean success = false;\n\n    try {\n      instance.core = new CoreReaders(dir, si, readBufferSize);\n      if (doOpenStores) {\n        instance.core.openDocStores(si);\n      }\n      instance.loadDeletedDocs();\n      instance.openNorms(instance.core.cfsDir, readBufferSize);\n      success = true;\n    } finally {\n\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        instance.doClose();\n      }\n    }\n    return instance;\n  }\n\n","sourceOld":"  /**\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static SegmentReader get(boolean readOnly,\n                                  Directory dir,\n                                  SegmentInfo si,\n                                  int readBufferSize,\n                                  boolean doOpenStores)\n    throws CorruptIndexException, IOException {\n    SegmentReader instance;\n    try {\n      if (readOnly)\n        instance = (SegmentReader)READONLY_IMPL.newInstance();\n      else\n        instance = (SegmentReader)IMPL.newInstance();\n    } catch (Exception e) {\n      throw new RuntimeException(\"cannot load SegmentReader class: \" + e, e);\n    }\n    instance.directory = dir;\n    instance.readOnly = readOnly;\n    instance.segment = si.name;\n    instance.si = si;\n    instance.readBufferSize = readBufferSize;\n\n    boolean success = false;\n\n    try {\n      // Use compound file directory for some files, if it exists\n      Directory cfsDir = instance.directory();\n      if (si.getUseCompoundFile()) {\n        instance.cfsReader = new CompoundFileReader(instance.directory(), instance.segment + \".\" + IndexFileNames.COMPOUND_FILE_EXTENSION, readBufferSize);\n        cfsDir = instance.cfsReader;\n      }\n\n      instance.fieldInfos = new FieldInfos(cfsDir, instance.segment + \".fnm\");\n\n      if (doOpenStores) {\n        instance.openDocStores();\n      }\n\n      boolean anyProx = instance.fieldInfos.hasProx();\n\n      instance.tis = new TermInfosReader(cfsDir, instance.segment, instance.fieldInfos, readBufferSize);\n\n      instance.loadDeletedDocs();\n\n      // make sure that all index files have been read or are kept open\n      // so that if an index update removes them we'll still have them\n      instance.freqStream = cfsDir.openInput(instance.segment + \".frq\", readBufferSize);\n      if (anyProx)\n        instance.proxStream = cfsDir.openInput(instance.segment + \".prx\", readBufferSize);\n      instance.openNorms(cfsDir, readBufferSize);\n\n      success = true;\n    } finally {\n\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        instance.doClose();\n      }\n    }\n    return instance;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"961159f13aece73fbb30aea720e77a2237e8bafd","date":1247258916,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#get(boolean,Directory,SegmentInfo,int,boolean,int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#get(boolean,Directory,SegmentInfo,int,boolean).mjava","sourceNew":"  /**\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static SegmentReader get(boolean readOnly,\n                                  Directory dir,\n                                  SegmentInfo si,\n                                  int readBufferSize,\n                                  boolean doOpenStores,\n                                  int termInfosIndexDivisor)\n    throws CorruptIndexException, IOException {\n    SegmentReader instance;\n    try {\n      if (readOnly)\n        instance = (SegmentReader)READONLY_IMPL.newInstance();\n      else\n        instance = (SegmentReader)IMPL.newInstance();\n    } catch (Exception e) {\n      throw new RuntimeException(\"cannot load SegmentReader class: \" + e, e);\n    }\n    instance.readOnly = readOnly;\n    instance.si = si;\n    instance.readBufferSize = readBufferSize;\n\n    boolean success = false;\n\n    try {\n      instance.core = new CoreReaders(dir, si, readBufferSize, termInfosIndexDivisor);\n      if (doOpenStores) {\n        instance.core.openDocStores(si);\n      }\n      instance.loadDeletedDocs();\n      instance.openNorms(instance.core.cfsDir, readBufferSize);\n      success = true;\n    } finally {\n\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        instance.doClose();\n      }\n    }\n    return instance;\n  }\n\n","sourceOld":"  /**\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static SegmentReader get(boolean readOnly,\n                                  Directory dir,\n                                  SegmentInfo si,\n                                  int readBufferSize,\n                                  boolean doOpenStores)\n    throws CorruptIndexException, IOException {\n    SegmentReader instance;\n    try {\n      if (readOnly)\n        instance = (SegmentReader)READONLY_IMPL.newInstance();\n      else\n        instance = (SegmentReader)IMPL.newInstance();\n    } catch (Exception e) {\n      throw new RuntimeException(\"cannot load SegmentReader class: \" + e, e);\n    }\n    instance.readOnly = readOnly;\n    instance.si = si;\n    instance.readBufferSize = readBufferSize;\n\n    boolean success = false;\n\n    try {\n      instance.core = new CoreReaders(dir, si, readBufferSize);\n      if (doOpenStores) {\n        instance.core.openDocStores(si);\n      }\n      instance.loadDeletedDocs();\n      instance.openNorms(instance.core.cfsDir, readBufferSize);\n      success = true;\n    } finally {\n\n      // With lock-less commits, it's entirely possible (and\n      // fine) to hit a FileNotFound exception above.  In\n      // this case, we want to explicitly close any subset\n      // of things that were opened so that we don't have to\n      // wait for a GC to do so.\n      if (!success) {\n        instance.doClose();\n      }\n    }\n    return instance;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"961159f13aece73fbb30aea720e77a2237e8bafd":["66f3dadb253a44f4cccc81c8a21b685b18b201fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5e023aa3e1228b8ccacdc30d852eb88e996d1b2":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["961159f13aece73fbb30aea720e77a2237e8bafd"],"66f3dadb253a44f4cccc81c8a21b685b18b201fb":["c5e023aa3e1228b8ccacdc30d852eb88e996d1b2"]},"commit2Childs":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["c5e023aa3e1228b8ccacdc30d852eb88e996d1b2"],"961159f13aece73fbb30aea720e77a2237e8bafd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"c5e023aa3e1228b8ccacdc30d852eb88e996d1b2":["66f3dadb253a44f4cccc81c8a21b685b18b201fb"],"66f3dadb253a44f4cccc81c8a21b685b18b201fb":["961159f13aece73fbb30aea720e77a2237e8bafd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}