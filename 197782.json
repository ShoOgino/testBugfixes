{"path":"lucene/test-framework/src/java/org/apache/lucene/analysis/LookaheadTokenFilter#nextToken().mjava","commits":[{"id":"914394e583f0258b2fe327df337ea44c908a0aab","date":1333904214,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/LookaheadTokenFilter#nextToken().mjava","pathOld":"/dev/null","sourceNew":"  /** Call this when you are done looking ahead; it will set\n   *  the next token to return.  Return the boolean back to\n   *  the caller. */\n  protected boolean nextToken() throws IOException {\n    //System.out.println(\"  nextToken: tokenPending=\" + tokenPending);\n    if (DEBUG) {\n      System.out.println(\"LTF.nextToken inputPos=\" + inputPos + \" outputPos=\" + outputPos + \" tokenPending=\" + tokenPending);\n    }\n\n    Position posData = positions.get(outputPos);\n\n    // While loop here in case we have to\n    // skip over a hole from the input:\n    while (true) {\n\n      //System.out.println(\"    check buffer @ outputPos=\" +\n      //outputPos + \" inputPos=\" + inputPos + \" nextRead=\" +\n      //posData.nextRead + \" vs size=\" +\n      //posData.inputTokens.size());\n\n      // See if we have a previously buffered token to\n      // return at the current position:\n      if (posData.nextRead < posData.inputTokens.size()) {\n        if (DEBUG) {\n          System.out.println(\"  return previously buffered token\");\n        }\n        // This position has buffered tokens to serve up:\n        if (tokenPending) {\n          positions.get(inputPos).add(captureState());\n          tokenPending = false;\n        }\n        restoreState(positions.get(outputPos).nextState());\n        //System.out.println(\"      return!\");\n        return true;\n      }\n\n      if (inputPos == -1 || outputPos == inputPos) {\n        // No more buffered tokens:\n        // We may still get input tokens at this position\n        //System.out.println(\"    break buffer\");\n        if (tokenPending) {\n          // Fast path: just return token we had just incr'd,\n          // without having captured/restored its state:\n          if (DEBUG) {\n            System.out.println(\"  pass-through: return pending token\");\n          }\n          tokenPending = false;\n          return true;\n        } else if (end || !peekToken()) {\n          if (DEBUG) {\n            System.out.println(\"  END\");\n          }\n          return false;\n        }\n      } else {\n        if (posData.startOffset != -1) {\n          // This position had at least one token leaving\n          if (DEBUG) {\n            System.out.println(\"  call afterPosition\");\n          }\n          afterPosition();\n          if (insertPending) {\n            // Subclass inserted a token at this same\n            // position:\n            if (DEBUG) {\n              System.out.println(\"  return inserted token\");\n            }\n            insertPending = false;\n            return true;\n          }\n        }\n\n        // Done with this position; move on:\n        outputPos++;\n        if (DEBUG) {\n          System.out.println(\"  next position: outputPos=\" + outputPos);\n        }\n        positions.freeBefore(outputPos);\n        posData = positions.get(outputPos);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fe9452de26a70442324c5bdc5a5a333e55f07db","date":1333912637,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/LookaheadTokenFilter#nextToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/LookaheadTokenFilter#nextToken().mjava","sourceNew":"  /** Call this when you are done looking ahead; it will set\n   *  the next token to return.  Return the boolean back to\n   *  the caller. */\n  protected boolean nextToken() throws IOException {\n    //System.out.println(\"  nextToken: tokenPending=\" + tokenPending);\n    if (DEBUG) {\n      System.out.println(\"LTF.nextToken inputPos=\" + inputPos + \" outputPos=\" + outputPos + \" tokenPending=\" + tokenPending);\n    }\n\n    Position posData = positions.get(outputPos);\n\n    // While loop here in case we have to\n    // skip over a hole from the input:\n    while (true) {\n\n      //System.out.println(\"    check buffer @ outputPos=\" +\n      //outputPos + \" inputPos=\" + inputPos + \" nextRead=\" +\n      //posData.nextRead + \" vs size=\" +\n      //posData.inputTokens.size());\n\n      // See if we have a previously buffered token to\n      // return at the current position:\n      if (posData.nextRead < posData.inputTokens.size()) {\n        if (DEBUG) {\n          System.out.println(\"  return previously buffered token\");\n        }\n        // This position has buffered tokens to serve up:\n        if (tokenPending) {\n          positions.get(inputPos).add(captureState());\n          tokenPending = false;\n        }\n        restoreState(positions.get(outputPos).nextState());\n        //System.out.println(\"      return!\");\n        return true;\n      }\n\n      if (inputPos == -1 || outputPos == inputPos) {\n        // No more buffered tokens:\n        // We may still get input tokens at this position\n        //System.out.println(\"    break buffer\");\n        if (tokenPending) {\n          // Fast path: just return token we had just incr'd,\n          // without having captured/restored its state:\n          if (DEBUG) {\n            System.out.println(\"  pass-through: return pending token\");\n          }\n          tokenPending = false;\n          return true;\n        } else if (end || !peekToken()) {\n          if (DEBUG) {\n            System.out.println(\"  END\");\n          }\n          return false;\n        }\n      } else {\n        if (posData.startOffset != -1) {\n          // This position had at least one token leaving\n          if (DEBUG) {\n            System.out.println(\"  call afterPosition\");\n          }\n          afterPosition();\n          if (insertPending) {\n            // Subclass inserted a token at this same\n            // position:\n            if (DEBUG) {\n              System.out.println(\"  return inserted token\");\n            }\n            assert insertedTokenConsistent();\n            insertPending = false;\n            return true;\n          }\n        }\n\n        // Done with this position; move on:\n        outputPos++;\n        if (DEBUG) {\n          System.out.println(\"  next position: outputPos=\" + outputPos);\n        }\n        positions.freeBefore(outputPos);\n        posData = positions.get(outputPos);\n      }\n    }\n  }\n\n","sourceOld":"  /** Call this when you are done looking ahead; it will set\n   *  the next token to return.  Return the boolean back to\n   *  the caller. */\n  protected boolean nextToken() throws IOException {\n    //System.out.println(\"  nextToken: tokenPending=\" + tokenPending);\n    if (DEBUG) {\n      System.out.println(\"LTF.nextToken inputPos=\" + inputPos + \" outputPos=\" + outputPos + \" tokenPending=\" + tokenPending);\n    }\n\n    Position posData = positions.get(outputPos);\n\n    // While loop here in case we have to\n    // skip over a hole from the input:\n    while (true) {\n\n      //System.out.println(\"    check buffer @ outputPos=\" +\n      //outputPos + \" inputPos=\" + inputPos + \" nextRead=\" +\n      //posData.nextRead + \" vs size=\" +\n      //posData.inputTokens.size());\n\n      // See if we have a previously buffered token to\n      // return at the current position:\n      if (posData.nextRead < posData.inputTokens.size()) {\n        if (DEBUG) {\n          System.out.println(\"  return previously buffered token\");\n        }\n        // This position has buffered tokens to serve up:\n        if (tokenPending) {\n          positions.get(inputPos).add(captureState());\n          tokenPending = false;\n        }\n        restoreState(positions.get(outputPos).nextState());\n        //System.out.println(\"      return!\");\n        return true;\n      }\n\n      if (inputPos == -1 || outputPos == inputPos) {\n        // No more buffered tokens:\n        // We may still get input tokens at this position\n        //System.out.println(\"    break buffer\");\n        if (tokenPending) {\n          // Fast path: just return token we had just incr'd,\n          // without having captured/restored its state:\n          if (DEBUG) {\n            System.out.println(\"  pass-through: return pending token\");\n          }\n          tokenPending = false;\n          return true;\n        } else if (end || !peekToken()) {\n          if (DEBUG) {\n            System.out.println(\"  END\");\n          }\n          return false;\n        }\n      } else {\n        if (posData.startOffset != -1) {\n          // This position had at least one token leaving\n          if (DEBUG) {\n            System.out.println(\"  call afterPosition\");\n          }\n          afterPosition();\n          if (insertPending) {\n            // Subclass inserted a token at this same\n            // position:\n            if (DEBUG) {\n              System.out.println(\"  return inserted token\");\n            }\n            insertPending = false;\n            return true;\n          }\n        }\n\n        // Done with this position; move on:\n        outputPos++;\n        if (DEBUG) {\n          System.out.println(\"  next position: outputPos=\" + outputPos);\n        }\n        positions.freeBefore(outputPos);\n        posData = positions.get(outputPos);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac6677ee7ef24b19d2ec432727d6957ba6110b14","date":1378744135,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/LookaheadTokenFilter#nextToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/LookaheadTokenFilter#nextToken().mjava","sourceNew":"  /** Call this when you are done looking ahead; it will set\n   *  the next token to return.  Return the boolean back to\n   *  the caller. */\n  protected boolean nextToken() throws IOException {\n    //System.out.println(\"  nextToken: tokenPending=\" + tokenPending);\n    if (DEBUG) {\n      System.out.println(\"LTF.nextToken inputPos=\" + inputPos + \" outputPos=\" + outputPos + \" tokenPending=\" + tokenPending);\n    }\n\n    Position posData = positions.get(outputPos);\n\n    // While loop here in case we have to\n    // skip over a hole from the input:\n    while (true) {\n\n      //System.out.println(\"    check buffer @ outputPos=\" +\n      //outputPos + \" inputPos=\" + inputPos + \" nextRead=\" +\n      //posData.nextRead + \" vs size=\" +\n      //posData.inputTokens.size());\n\n      // See if we have a previously buffered token to\n      // return at the current position:\n      if (posData.nextRead < posData.inputTokens.size()) {\n        if (DEBUG) {\n          System.out.println(\"  return previously buffered token\");\n        }\n        // This position has buffered tokens to serve up:\n        if (tokenPending) {\n          positions.get(inputPos).add(captureState());\n          tokenPending = false;\n        }\n        restoreState(positions.get(outputPos).nextState());\n        //System.out.println(\"      return!\");\n        return true;\n      }\n\n      if (inputPos == -1 || outputPos == inputPos) {\n        // No more buffered tokens:\n        // We may still get input tokens at this position\n        //System.out.println(\"    break buffer\");\n        if (tokenPending) {\n          // Fast path: just return token we had just incr'd,\n          // without having captured/restored its state:\n          if (DEBUG) {\n            System.out.println(\"  pass-through: return pending token\");\n          }\n          tokenPending = false;\n          return true;\n        } else if (end || !peekToken()) {\n          if (DEBUG) {\n            System.out.println(\"  END\");\n          }\n          afterPosition();\n          if (insertPending) {\n            // Subclass inserted a token at this same\n            // position:\n            if (DEBUG) {\n              System.out.println(\"  return inserted token\");\n            }\n            assert insertedTokenConsistent();\n            insertPending = false;\n            return true;\n          }\n\n          return false;\n        }\n      } else {\n        if (posData.startOffset != -1) {\n          // This position had at least one token leaving\n          if (DEBUG) {\n            System.out.println(\"  call afterPosition\");\n          }\n          afterPosition();\n          if (insertPending) {\n            // Subclass inserted a token at this same\n            // position:\n            if (DEBUG) {\n              System.out.println(\"  return inserted token\");\n            }\n            assert insertedTokenConsistent();\n            insertPending = false;\n            return true;\n          }\n        }\n\n        // Done with this position; move on:\n        outputPos++;\n        if (DEBUG) {\n          System.out.println(\"  next position: outputPos=\" + outputPos);\n        }\n        positions.freeBefore(outputPos);\n        posData = positions.get(outputPos);\n      }\n    }\n  }\n\n","sourceOld":"  /** Call this when you are done looking ahead; it will set\n   *  the next token to return.  Return the boolean back to\n   *  the caller. */\n  protected boolean nextToken() throws IOException {\n    //System.out.println(\"  nextToken: tokenPending=\" + tokenPending);\n    if (DEBUG) {\n      System.out.println(\"LTF.nextToken inputPos=\" + inputPos + \" outputPos=\" + outputPos + \" tokenPending=\" + tokenPending);\n    }\n\n    Position posData = positions.get(outputPos);\n\n    // While loop here in case we have to\n    // skip over a hole from the input:\n    while (true) {\n\n      //System.out.println(\"    check buffer @ outputPos=\" +\n      //outputPos + \" inputPos=\" + inputPos + \" nextRead=\" +\n      //posData.nextRead + \" vs size=\" +\n      //posData.inputTokens.size());\n\n      // See if we have a previously buffered token to\n      // return at the current position:\n      if (posData.nextRead < posData.inputTokens.size()) {\n        if (DEBUG) {\n          System.out.println(\"  return previously buffered token\");\n        }\n        // This position has buffered tokens to serve up:\n        if (tokenPending) {\n          positions.get(inputPos).add(captureState());\n          tokenPending = false;\n        }\n        restoreState(positions.get(outputPos).nextState());\n        //System.out.println(\"      return!\");\n        return true;\n      }\n\n      if (inputPos == -1 || outputPos == inputPos) {\n        // No more buffered tokens:\n        // We may still get input tokens at this position\n        //System.out.println(\"    break buffer\");\n        if (tokenPending) {\n          // Fast path: just return token we had just incr'd,\n          // without having captured/restored its state:\n          if (DEBUG) {\n            System.out.println(\"  pass-through: return pending token\");\n          }\n          tokenPending = false;\n          return true;\n        } else if (end || !peekToken()) {\n          if (DEBUG) {\n            System.out.println(\"  END\");\n          }\n          return false;\n        }\n      } else {\n        if (posData.startOffset != -1) {\n          // This position had at least one token leaving\n          if (DEBUG) {\n            System.out.println(\"  call afterPosition\");\n          }\n          afterPosition();\n          if (insertPending) {\n            // Subclass inserted a token at this same\n            // position:\n            if (DEBUG) {\n              System.out.println(\"  return inserted token\");\n            }\n            assert insertedTokenConsistent();\n            insertPending = false;\n            return true;\n          }\n        }\n\n        // Done with this position; move on:\n        outputPos++;\n        if (DEBUG) {\n          System.out.println(\"  next position: outputPos=\" + outputPos);\n        }\n        positions.freeBefore(outputPos);\n        posData = positions.get(outputPos);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ac6677ee7ef24b19d2ec432727d6957ba6110b14":["1fe9452de26a70442324c5bdc5a5a333e55f07db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1fe9452de26a70442324c5bdc5a5a333e55f07db":["914394e583f0258b2fe327df337ea44c908a0aab"],"914394e583f0258b2fe327df337ea44c908a0aab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ac6677ee7ef24b19d2ec432727d6957ba6110b14"]},"commit2Childs":{"ac6677ee7ef24b19d2ec432727d6957ba6110b14":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["914394e583f0258b2fe327df337ea44c908a0aab"],"1fe9452de26a70442324c5bdc5a5a333e55f07db":["ac6677ee7ef24b19d2ec432727d6957ba6110b14"],"914394e583f0258b2fe327df337ea44c908a0aab":["1fe9452de26a70442324c5bdc5a5a333e55f07db"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}