{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","commits":[{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      controllerClient.makePath(ZkStateReader.LIVE_NODES_ZKNODE, true);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      for (int i=0; i<100; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", \"2\",\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < 20000; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, ZkStateReader.RECOVERING,\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j == 99) j = 0;\n        if (k == 9) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, ZkStateReader.ACTIVE,\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","7875fce026a0a335830cfc75abc3eb009eff9a73"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"228dffa21e676b9e3ad7328cc4c6bdaa85fb43a3","date":1417451556,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      controllerClient.makePath(ZkStateReader.LIVE_NODES_ZKNODE, true);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, ZkStateReader.RECOVERING,\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, ZkStateReader.ACTIVE,\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      controllerClient.makePath(ZkStateReader.LIVE_NODES_ZKNODE, true);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      for (int i=0; i<100; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", \"2\",\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < 20000; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, ZkStateReader.RECOVERING,\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j == 99) j = 0;\n        if (k == 9) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, ZkStateReader.ACTIVE,\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7875fce026a0a335830cfc75abc3eb009eff9a73","date":1425897108,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, ZkStateReader.RECOVERING,\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, ZkStateReader.ACTIVE,\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      controllerClient.makePath(ZkStateReader.LIVE_NODES_ZKNODE, true);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, ZkStateReader.RECOVERING,\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, ZkStateReader.ACTIVE,\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, ZkStateReader.RECOVERING,\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, ZkStateReader.ACTIVE,\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      controllerClient.makePath(ZkStateReader.LIVE_NODES_ZKNODE, true);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, ZkStateReader.RECOVERING,\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, ZkStateReader.ACTIVE,\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, ZkStateReader.RECOVERING,\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, ZkStateReader.ACTIVE,\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(ZkStateReader.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(ZkStateReader.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState();\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState(true);\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19498030e0adab22f604f935cae3c03dcf0952a6","date":1456558851,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState();\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState();\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState();\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getInQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getInQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState();\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          reader.updateClusterState();\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f3e7752e8a5e963c6939aaa99c36134147a5ece","date":1479805653,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      TimerContext context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e","date":1505888025,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      DistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Overseer.Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Overseer.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Overseer.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\", overseers);\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        zkClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        reader.waitForState(\"perf_sentinel\", 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null);\n\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(reader);\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n    String zkDir = createTempDir(\"OverseerTest.testPerformance\").toFile().getAbsolutePath();\n\n    ZkTestServer server = new ZkTestServer(zkDir);\n\n    SolrZkClient controllerClient = null;\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n      server.run();\n      controllerClient = new SolrZkClient(server.getZkAddress(), TIMEOUT);\n\n      AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());\n      AbstractZkTestCase.makeSolrZkNode(server.getZkHost());\n      ZkController.createClusterZkNodes(controllerClient);\n\n      reader = new ZkStateReader(controllerClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\");\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        controllerClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = Overseer.getStateUpdateQueue(controllerClient);\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        while (true)  {\n          ClusterState state = reader.getClusterState();\n          if (state.hasCollection(\"perf_sentinel\")) {\n            break;\n          }\n          Thread.sleep(1000);\n        }\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(controllerClient);\n      close(reader);\n      server.shutdown();\n    }\n  }\n\n","bugFix":["7875fce026a0a335830cfc75abc3eb009eff9a73","24a5da2a0d397ff29f3de8f6cf451d3412c2509a","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\", overseers);\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        zkClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        reader.waitForState(\"perf_sentinel\", 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null);\n\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        if (log.isInfoEnabled()) {\n          log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        }\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(reader);\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\", overseers);\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        zkClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        reader.waitForState(\"perf_sentinel\", 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null);\n\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(reader);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\", overseers);\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        zkClient.makePath(\"/collections/perf\" + i, true);\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.SHARD_ID_PROP, \"shard1\",\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\" + \"/solr/\");\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's create a sentinel collection which we'll use to wait for overseer to complete operations\n      createCollection(\"perf_sentinel\", 1);\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      reader.waitForState(\"perf_sentinel\", 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null);\n      context.stop();\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        if (log.isInfoEnabled()) {\n          log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        }\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(reader);\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\", overseers);\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000, STATE_FORMAT = 2;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            \"stateFormat\", String.valueOf(STATE_FORMAT),\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        zkClient.makePath(\"/collections/perf\" + i, true);\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" +  \"node1\"\n            + \"/solr/\");\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's publish a sentinel collection which we'll use to wait for overseer to complete operations\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n          ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString(),\n          ZkStateReader.NODE_NAME_PROP, \"node1\",\n          ZkStateReader.CORE_NAME_PROP, \"core1\",\n          ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n          ZkStateReader.COLLECTION_PROP, \"perf_sentinel\",\n          ZkStateReader.NUM_SHARDS_PROP, \"1\",\n          ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\"\n          + \"/solr/\");\n      ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n      q.offer(Utils.toJSON(m));\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      try {\n        overseerClient = electNewOverseer(server.getZkAddress());\n        assertTrue(overseers.size() > 0);\n\n        reader.waitForState(\"perf_sentinel\", 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null);\n\n      } finally {\n        context.stop();\n      }\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        if (log.isInfoEnabled()) {\n          log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        }\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(reader);\n    }\n  }\n\n","bugFix":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","b693a83132c9e45afcd564fd65a25b60ed80388b","228dffa21e676b9e3ad7328cc4c6bdaa85fb43a3","24a5da2a0d397ff29f3de8f6cf451d3412c2509a","a219f1dcad1700e84807666bdbd2b573e8de7021"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTest#testPerformance().mjava","sourceNew":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\", overseers);\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        zkClient.makePath(\"/collections/perf\" + i, true);\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.REPLICATION_FACTOR, \"1\"\n            );\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.SHARD_ID_PROP, \"shard1\",\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\" + \"/solr/\");\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's create a sentinel collection which we'll use to wait for overseer to complete operations\n      createCollection(\"perf_sentinel\", 1);\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      reader.waitForState(\"perf_sentinel\", 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null);\n      context.stop();\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        if (log.isInfoEnabled()) {\n          log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        }\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(reader);\n    }\n  }\n\n","sourceOld":"  @Test\n  @Ignore\n  public void testPerformance() throws Exception {\n\n    SolrZkClient overseerClient = null;\n    ZkStateReader reader = null;\n    MockZKController mockController = null;\n\n    try {\n\n      ZkController.createClusterZkNodes(zkClient);\n      overseerClient = electNewOverseer(server.getZkAddress());\n\n      reader = new ZkStateReader(zkClient);\n      reader.createClusterStateWatchersAndUpdate();\n\n      mockController = new MockZKController(server.getZkAddress(), \"node1\", overseers);\n\n      final int MAX_COLLECTIONS = 10, MAX_CORES = 10, MAX_STATE_CHANGES = 20000;\n\n      for (int i=0; i<MAX_COLLECTIONS; i++)  {\n        zkClient.makePath(\"/collections/perf\" + i, true);\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),\n            \"name\", \"perf\" + i,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.REPLICATION_FACTOR, \"1\",\n            ZkStateReader.MAX_SHARDS_PER_NODE, \"1\"\n            );\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n      }\n\n      for (int i = 0, j = 0, k = 0; i < MAX_STATE_CHANGES; i++, j++, k++) {\n        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n            ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString(),\n            ZkStateReader.NODE_NAME_PROP,  \"node1\",\n            ZkStateReader.CORE_NAME_PROP, \"core\" + k,\n            ZkStateReader.SHARD_ID_PROP, \"shard1\",\n            ZkStateReader.CORE_NODE_NAME_PROP, \"node1\",\n            ZkStateReader.COLLECTION_PROP, \"perf\" + j,\n            ZkStateReader.NUM_SHARDS_PROP, \"1\",\n            ZkStateReader.BASE_URL_PROP, \"http://\" + \"node1\" + \"/solr/\");\n        ZkDistributedQueue q = overseers.get(0).getStateUpdateQueue();\n        q.offer(Utils.toJSON(m));\n        if (j >= MAX_COLLECTIONS - 1) j = 0;\n        if (k >= MAX_CORES - 1) k = 0;\n        if (i > 0 && i % 100 == 0) log.info(\"Published {} items\", i);\n      }\n\n      // let's create a sentinel collection which we'll use to wait for overseer to complete operations\n      createCollection(\"perf_sentinel\", 1);\n\n      Timer t = new Timer();\n      Timer.Context context = t.time();\n      reader.waitForState(\"perf_sentinel\", 15000, TimeUnit.MILLISECONDS, (liveNodes, collectionState) -> collectionState != null);\n      context.stop();\n\n      log.info(\"Overseer loop finished processing: \");\n      printTimingStats(t);\n\n      Overseer overseer = overseers.get(0);\n      Stats stats = overseer.getStats();\n\n      String[] interestingOps = {\"state\", \"update_state\", \"am_i_leader\", \"\"};\n      Arrays.sort(interestingOps);\n      for (Map.Entry<String, Stats.Stat> entry : stats.getStats().entrySet()) {\n        String op = entry.getKey();\n        if (Arrays.binarySearch(interestingOps, op) < 0)\n          continue;\n        Stats.Stat stat = entry.getValue();\n        if (log.isInfoEnabled()) {\n          log.info(\"op: {}, success: {}, failure: {}\", op, stat.success.get(), stat.errors.get());\n        }\n        Timer timer = stat.requestTime;\n        printTimingStats(timer);\n      }\n\n    } finally {\n      close(overseerClient);\n      close(mockController);\n      close(reader);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"228dffa21e676b9e3ad7328cc4c6bdaa85fb43a3":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"af2638813028b254a88b418ebeafb541afb49653":["102da6baafc0f534a59f31729343dbab9d3b9e9a","19498030e0adab22f604f935cae3c03dcf0952a6"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"0f3e7752e8a5e963c6939aaa99c36134147a5ece":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["af2638813028b254a88b418ebeafb541afb49653"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["7875fce026a0a335830cfc75abc3eb009eff9a73"],"19498030e0adab22f604f935cae3c03dcf0952a6":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["228dffa21e676b9e3ad7328cc4c6bdaa85fb43a3","7875fce026a0a335830cfc75abc3eb009eff9a73"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"727bb765ff2542275f6d31f67be18d7104bae148":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","0f3e7752e8a5e963c6939aaa99c36134147a5ece"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["0f3e7752e8a5e963c6939aaa99c36134147a5ece","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["0f3e7752e8a5e963c6939aaa99c36134147a5ece"],"7875fce026a0a335830cfc75abc3eb009eff9a73":["228dffa21e676b9e3ad7328cc4c6bdaa85fb43a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"228dffa21e676b9e3ad7328cc4c6bdaa85fb43a3":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","7875fce026a0a335830cfc75abc3eb009eff9a73"],"af2638813028b254a88b418ebeafb541afb49653":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"0f3e7752e8a5e963c6939aaa99c36134147a5ece":["727bb765ff2542275f6d31f67be18d7104bae148","6240b74b884c5587f2a4062dd27d6c32bf228889","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["af2638813028b254a88b418ebeafb541afb49653","19498030e0adab22f604f935cae3c03dcf0952a6"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["0f3e7752e8a5e963c6939aaa99c36134147a5ece","727bb765ff2542275f6d31f67be18d7104bae148"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"19498030e0adab22f604f935cae3c03dcf0952a6":["af2638813028b254a88b418ebeafb541afb49653"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["228dffa21e676b9e3ad7328cc4c6bdaa85fb43a3"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","6240b74b884c5587f2a4062dd27d6c32bf228889"],"7875fce026a0a335830cfc75abc3eb009eff9a73":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","727bb765ff2542275f6d31f67be18d7104bae148","6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}