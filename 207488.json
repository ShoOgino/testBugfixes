{"path":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","commits":[{"id":"1bf853f0385a540ee0fb220fd272f2c362432294","date":1311520789,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#testBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    BackupThread backupThread = new BackupThread();\n    backupThread.start();\n    \n    File dataDir = new File(master.getDataDir());\n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    int waitCnt = 0;\n    CheckStatus checkStatus = new CheckStatus();\n    while(true) {\n      checkStatus.run();\n      if(checkStatus.fail != null) {\n        fail(checkStatus.fail);\n      }\n      if(checkStatus.success) {\n        break;\n      }\n      Thread.sleep(200);\n      if(waitCnt == 10) {\n        fail(\"Backup success not detected:\" + checkStatus.response);\n      }\n      waitCnt++;\n    }\n    \n    if(backupThread.fail != null) {\n      fail(backupThread.fail);\n    }\n\n    File[] files = dataDir.listFiles(new FilenameFilter() {\n      \n      public boolean accept(File dir, String name) {\n        if(name.startsWith(\"snapshot\")) {\n          return true;\n        }\n        return false;\n      }\n    });\n    assertEquals(1, files.length);\n    File snapDir = files[0];\n    Directory dir = new SimpleFSDirectory(snapDir.getAbsoluteFile());\n    IndexSearcher searcher = new IndexSearcher(dir, true);\n    TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n\n    assertEquals(nDocs, hits.totalHits);\n    searcher.close();\n    dir.close();\n    AbstractSolrTestCase.recurseDelete(snapDir); // clean up the snap dir\n  }\n\n","sourceOld":"  @Test\n  public void testBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    BackupThread backupThread = new BackupThread();\n    backupThread.start();\n    \n    File dataDir = new File(master.getDataDir());\n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    int waitCnt = 0;\n    CheckStatus checkStatus = new CheckStatus();\n    while(true) {\n      checkStatus.run();\n      if(checkStatus.fail != null) {\n        fail(checkStatus.fail);\n      }\n      if(checkStatus.success) {\n        break;\n      }\n      Thread.sleep(200);\n      if(waitCnt == 10) {\n        fail(\"Backup success not detected:\" + checkStatus.response);\n      }\n      waitCnt++;\n    }\n    \n    if(backupThread.fail != null) {\n      fail(backupThread.fail);\n    }\n\n    File[] files = dataDir.listFiles(new FilenameFilter() {\n      \n      public boolean accept(File dir, String name) {\n        if(name.startsWith(\"snapshot\")) {\n          return true;\n        }\n        return false;\n      }\n    });\n    assertEquals(1, files.length);\n    File snapDir = files[0];\n    Directory dir = new SimpleFSDirectory(snapDir.getAbsoluteFile());\n    IndexSearcher searcher = new IndexSearcher(dir, true);\n    TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n\n    assertEquals(nDocs, hits.totalHits);\n    searcher.close();\n    dir.close();\n    AbstractSolrTestCase.recurseDelete(snapDir); // clean up the snap dir\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3a0403b45dfe384fae4a1b6e96c3265d000c498","date":1321445981,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    BackupThread backupThread = new BackupThread();\n    backupThread.start();\n    \n    File dataDir = new File(master.getDataDir());\n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    int waitCnt = 0;\n    CheckStatus checkStatus = new CheckStatus();\n    while(true) {\n      checkStatus.run();\n      if(checkStatus.fail != null) {\n        fail(checkStatus.fail);\n      }\n      if(checkStatus.success) {\n        break;\n      }\n      Thread.sleep(200);\n      if(waitCnt == 10) {\n        fail(\"Backup success not detected:\" + checkStatus.response);\n      }\n      waitCnt++;\n    }\n    \n    if(backupThread.fail != null) {\n      fail(backupThread.fail);\n    }\n\n    File[] files = dataDir.listFiles(new FilenameFilter() {\n      \n      public boolean accept(File dir, String name) {\n        if(name.startsWith(\"snapshot\")) {\n          return true;\n        }\n        return false;\n      }\n    });\n    assertEquals(1, files.length);\n    File snapDir = files[0];\n    Directory dir = new SimpleFSDirectory(snapDir.getAbsoluteFile());\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n\n    assertEquals(nDocs, hits.totalHits);\n    searcher.close();\n    reader.close();\n    dir.close();\n    AbstractSolrTestCase.recurseDelete(snapDir); // clean up the snap dir\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    BackupThread backupThread = new BackupThread();\n    backupThread.start();\n    \n    File dataDir = new File(master.getDataDir());\n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    int waitCnt = 0;\n    CheckStatus checkStatus = new CheckStatus();\n    while(true) {\n      checkStatus.run();\n      if(checkStatus.fail != null) {\n        fail(checkStatus.fail);\n      }\n      if(checkStatus.success) {\n        break;\n      }\n      Thread.sleep(200);\n      if(waitCnt == 10) {\n        fail(\"Backup success not detected:\" + checkStatus.response);\n      }\n      waitCnt++;\n    }\n    \n    if(backupThread.fail != null) {\n      fail(backupThread.fail);\n    }\n\n    File[] files = dataDir.listFiles(new FilenameFilter() {\n      \n      public boolean accept(File dir, String name) {\n        if(name.startsWith(\"snapshot\")) {\n          return true;\n        }\n        return false;\n      }\n    });\n    assertEquals(1, files.length);\n    File snapDir = files[0];\n    Directory dir = new SimpleFSDirectory(snapDir.getAbsoluteFile());\n    IndexSearcher searcher = new IndexSearcher(dir, true);\n    TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n\n    assertEquals(nDocs, hits.totalHits);\n    searcher.close();\n    dir.close();\n    AbstractSolrTestCase.recurseDelete(snapDir); // clean up the snap dir\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f11ea4f58f7fefe4a8c99ee19b3c388d7f98d60","date":1321493601,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \"&\" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \"=1\";\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread();\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      searcher.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \" was set to 1\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    BackupThread backupThread = new BackupThread();\n    backupThread.start();\n    \n    File dataDir = new File(master.getDataDir());\n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    int waitCnt = 0;\n    CheckStatus checkStatus = new CheckStatus();\n    while(true) {\n      checkStatus.run();\n      if(checkStatus.fail != null) {\n        fail(checkStatus.fail);\n      }\n      if(checkStatus.success) {\n        break;\n      }\n      Thread.sleep(200);\n      if(waitCnt == 10) {\n        fail(\"Backup success not detected:\" + checkStatus.response);\n      }\n      waitCnt++;\n    }\n    \n    if(backupThread.fail != null) {\n      fail(backupThread.fail);\n    }\n\n    File[] files = dataDir.listFiles(new FilenameFilter() {\n      \n      public boolean accept(File dir, String name) {\n        if(name.startsWith(\"snapshot\")) {\n          return true;\n        }\n        return false;\n      }\n    });\n    assertEquals(1, files.length);\n    File snapDir = files[0];\n    Directory dir = new SimpleFSDirectory(snapDir.getAbsoluteFile());\n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n\n    assertEquals(nDocs, hits.totalHits);\n    searcher.close();\n    reader.close();\n    dir.close();\n    AbstractSolrTestCase.recurseDelete(snapDir); // clean up the snap dir\n  }\n\n","bugFix":null,"bugIntro":["6be5df27d60dc5fe63f0769ec2fa9d843bf3867a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \"&\" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \"=1\";\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread();\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \" was set to 1\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \"&\" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \"=1\";\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread();\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      searcher.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \" was set to 1\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \"&\" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \"=1\";\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread();\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \" was set to 1\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \"&\" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \"=1\";\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread();\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      searcher.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \" was set to 1\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4448c35ccdaef2a8501f93c0dfe9fe79b19402cc","date":1330444231,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random.nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \"&\" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \"=1\";\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread();\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \" was set to 1\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random.nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + \"solrconfig-master1.xml\", \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \"&\" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \"=1\";\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread();\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + ReplicationHandler.NUMBER_BACKUPS_TO_KEEP + \" was set to 1\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random.nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ae05237914af33835981f3271dd3c0d753a43be","date":1335201162,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = null;\n      if(!addNumberToKeepInRequest) {\n        if(random().nextBoolean()) {\n          masterClient.commit();\n        } else {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n          backupThread.start();\n        }\n      }\n      \n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread!= null && backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1805600f3c01671239e987d431c6440245e612ca","date":1335208816,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = null;\n      if(!addNumberToKeepInRequest) {\n        if(random().nextBoolean()) {\n          masterClient.commit();\n        }\n      } else {\n        backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n        backupThread.start();\n      }\n      \n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread!= null && backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = null;\n      if(!addNumberToKeepInRequest) {\n        if(random().nextBoolean()) {\n          masterClient.commit();\n        } else {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n          backupThread.start();\n        }\n      }\n      \n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread!= null && backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":["6be5df27d60dc5fe63f0769ec2fa9d843bf3867a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c60702a3a59ccba6a09292e99bc59b2863ed5153","date":1335211565,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = null;\n      if(!addNumberToKeepInRequest) {\n        if(random().nextBoolean()) {\n          masterClient.commit();\n        } else {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n          backupThread.start();\n        }\n      } else {\n        backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n        backupThread.start();\n      }\n      \n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread!= null && backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = null;\n      if(!addNumberToKeepInRequest) {\n        if(random().nextBoolean()) {\n          masterClient.commit();\n        }\n      } else {\n        backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n        backupThread.start();\n      }\n      \n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread!= null && backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1ba16dd7ab27ab1e2a4c5b045289afe706917f8","date":1335285468,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n    boolean checkOnCommit = random().nextBoolean();\n    //Check to see if 2 commits results in only one backup. (maxBackupsToKeep=1)\n    if(!addNumberToKeepInRequest && checkOnCommit) {\n      Thread.sleep(1000); //ensure the 2 backups have a separate timestamp.\n      masterClient.commit();\n      File[] files = new File(master.getDataDir()).listFiles(new FilenameFilter() {        \n        public boolean accept(File dir, String name) {\n          if(name.startsWith(\"snapshot\")) {\n            return true;\n          }\n          return false;\n        }\n      });\n      assertEquals(1, files.length);\n      for(File f : files) {\n        AbstractSolrTestCase.recurseDelete(f); // clean up the snap dir\n      }\n    }\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    if(!checkOnCommit) {\n      File[] snapDir = new File[2];\n      String firstBackupTimestamp = null;\n      for(int i=0 ; i<2 ; i++) {\n        BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n        backupThread.start();\n        \n        File dataDir = new File(master.getDataDir());\n        \n        int waitCnt = 0;\n        CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n        while(true) {\n          checkStatus.run();\n          if(checkStatus.fail != null) {\n            fail(checkStatus.fail);\n          }\n          if(checkStatus.success) {\n            if(i==0) {\n              firstBackupTimestamp = checkStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if(waitCnt == 10) {\n            fail(\"Backup success not detected:\" + checkStatus.response);\n          }\n          waitCnt++;\n        }\n        \n        if(backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n    \n        File[] files = dataDir.listFiles(new FilenameFilter() {\n          \n            public boolean accept(File dir, String name) {\n              if(name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = IndexReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n      }\n      if(snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n      for(int i=0 ; i< snapDir.length ; i++) {\n        AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n      }\n    }    \n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = null;\n      if(!addNumberToKeepInRequest) {\n        if(random().nextBoolean()) {\n          masterClient.commit();\n        } else {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n          backupThread.start();\n        }\n      } else {\n        backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n        backupThread.start();\n      }\n      \n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread!= null && backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":["6be5df27d60dc5fe63f0769ec2fa9d843bf3867a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6be5df27d60dc5fe63f0769ec2fa9d843bf3867a","date":1335290869,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n    boolean checkOnCommit = random().nextBoolean();\n    //Check to see if 2 commits results in only one backup. (maxBackupsToKeep=1)\n    if(!addNumberToKeepInRequest && checkOnCommit) {\n      Thread.sleep(1000); //ensure the 2 backups have a separate timestamp.\n      masterClient.commit();\n      File[] files = new File(master.getDataDir()).listFiles(new FilenameFilter() {        \n        public boolean accept(File dir, String name) {\n          if(name.startsWith(\"snapshot\")) {\n            return true;\n          }\n          return false;\n        }\n      });\n      assertEquals(1, files.length);\n      for(File f : files) {\n        AbstractSolrTestCase.recurseDelete(f); // clean up the snap dir\n      }\n    }\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    if(!checkOnCommit) {\n      File[] snapDir = new File[2];\n      String firstBackupTimestamp = null;\n      for(int i=0 ; i<2 ; i++) {\n        BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n        backupThread.start();\n        \n        File dataDir = new File(master.getDataDir());\n        \n        int waitCnt = 0;\n        CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n        while(true) {\n          checkStatus.run();\n          if(checkStatus.fail != null) {\n            fail(checkStatus.fail);\n          }\n          if(checkStatus.success) {\n            if(i==0) {\n              firstBackupTimestamp = checkStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if(waitCnt == 10) {\n            fail(\"Backup success not detected:\" + checkStatus.response);\n          }\n          waitCnt++;\n        }\n        \n        if(backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n    \n        File[] files = dataDir.listFiles(new FilenameFilter() {\n          \n            public boolean accept(File dir, String name) {\n              if(name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = IndexReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n      }\n      if(snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n      for(int i=0 ; i< snapDir.length ; i++) {\n        AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n      }\n    }    \n  }\n\n","bugFix":["b1ba16dd7ab27ab1e2a4c5b045289afe706917f8","1805600f3c01671239e987d431c6440245e612ca","4f11ea4f58f7fefe4a8c99ee19b3c388d7f98d60"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f864968c86dfe89d25f9a927bc3dd26df981607f","date":1343001376,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 10) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47c952a4f0f0e9b74763a0609a3726dbb217164a","date":1347968413,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://localhost:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a59489bd57cb6434aab4e536a03b260fec1d47f3","date":1361571364,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  private void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81ec897f0eb789ef9536a8130d1cdb9337ef108a","date":1392217884,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \"http://127.0.0.1:\" + masterJetty.getLocalPort() + \"/solr/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c7856260bc28f285ae7bfefa99b28db4dca6daf","date":1395253500,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c","date":1399457549,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n    \n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    boolean namedBackup = true;\n    String[] backupNames = null;\n    if(namedBackup) {\n      backupNames = new String[2];\n    }\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if(!namedBackup) {\n        backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n      while(true) {\n        checkBackupStatus.fetchStatus();\n        if(checkBackupStatus.fail != null) {\n          fail(checkBackupStatus.fail);\n        }\n        if(checkBackupStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkBackupStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n      File[] files = null;\n      if(!namedBackup) {\n        files = dataDir.listFiles(new FilenameFilter() {\n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      } else {\n        files = dataDir.listFiles(new FilenameFilter() {\n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot.\" + backupName)) {\n              return true;\n            }\n            return false;\n          }\n        });\n      }\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n\n      if(!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n    }\n\n    for(int i=0; i<2; i++) {\n      //Test Deletion of named backup\n      BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n      deleteBackupThread.start();\n      int waitCnt = 0;\n      CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n      while(true) {\n        checkDeleteBackupStatus.fetchStatus();\n        if(checkDeleteBackupStatus.fail != null) {\n          fail(checkDeleteBackupStatus.fail);\n        }\n        if(checkDeleteBackupStatus.success) {\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n        }\n        waitCnt++;\n      }\n\n      if(deleteBackupThread.fail != null) {\n        fail(deleteBackupThread.fail);\n      }\n    }\n    \n    //nocommit - Should move this to tearDown as it fails to delete the dir in case it fails?\n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n    \n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n      }\n      @Override\n      public void run() {\n        String masterUrl = \n          buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_BACKUP + \n          (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    class CheckStatus extends Thread {\n      volatile String fail = null;\n      volatile String response = null;\n      volatile boolean success = false;\n      volatile String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n      @Override\n      public void run() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName);\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckStatus checkStatus = new CheckStatus(firstBackupTimestamp);\n      while(true) {\n        checkStatus.run();\n        if(checkStatus.fail != null) {\n          fail(checkStatus.fail);\n        }\n        if(checkStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n  \n      File[] files = dataDir.listFiles(new FilenameFilter() {\n        \n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n    }\n    if(snapDir[0].exists()) {\n      fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n    }\n    \n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c127aec2f246ace289d4dd91232cd2319547df1","date":1399562671,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    try {\n      String firstBackupTimestamp = null;\n      boolean namedBackup = true;\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n        if (!namedBackup && snapDir[0].exists()) {\n          fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n      for (int i = 0; i < 2; i++) {\n        //Test Deletion of named backup\n        BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n        deleteBackupThread.start();\n        int waitCnt = 0;\n        CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n        while (true) {\n          checkDeleteBackupStatus.fetchStatus();\n          if (checkDeleteBackupStatus.fail != null) {\n            fail(checkDeleteBackupStatus.fail);\n          }\n          if (checkDeleteBackupStatus.success) {\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (deleteBackupThread.fail != null) {\n          fail(deleteBackupThread.fail);\n        }\n      }\n    }finally {\n      for (File dir : snapDir) if(dir !=null) AbstractSolrTestCase.recurseDelete(dir);\n    }\n    \n\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile, \n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n   \n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n    \n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n      \n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);   \n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n    \n    File[] snapDir = new File[2];\n    String firstBackupTimestamp = null;\n    boolean namedBackup = true;\n    String[] backupNames = null;\n    if(namedBackup) {\n      backupNames = new String[2];\n    }\n    for(int i=0 ; i<2 ; i++) {\n      BackupThread backupThread;\n      final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n      if(!namedBackup) {\n        backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n      } else {\n        backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n        backupNames[i] = backupName;\n      }\n      backupThread.start();\n      \n      File dataDir = new File(master.getDataDir());\n      \n      int waitCnt = 0;\n      CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n      while(true) {\n        checkBackupStatus.fetchStatus();\n        if(checkBackupStatus.fail != null) {\n          fail(checkBackupStatus.fail);\n        }\n        if(checkBackupStatus.success) {\n          if(i==0) {\n            firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n            Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n          }\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Backup success not detected:\" + checkBackupStatus.response);\n        }\n        waitCnt++;\n      }\n      \n      if(backupThread.fail != null) {\n        fail(backupThread.fail);\n      }\n      File[] files = null;\n      if(!namedBackup) {\n        files = dataDir.listFiles(new FilenameFilter() {\n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot\")) {\n              return true;\n            }\n            return false;\n          }\n        });\n      } else {\n        files = dataDir.listFiles(new FilenameFilter() {\n          @Override\n          public boolean accept(File dir, String name) {\n            if(name.startsWith(\"snapshot.\" + backupName)) {\n              return true;\n            }\n            return false;\n          }\n        });\n      }\n      assertEquals(1, files.length);\n      snapDir[i] = files[0];\n      Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n      IndexReader reader = DirectoryReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n      assertEquals(nDocs, hits.totalHits);\n      reader.close();\n      dir.close();\n\n      if(!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n    }\n\n    for(int i=0; i<2; i++) {\n      //Test Deletion of named backup\n      BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n      deleteBackupThread.start();\n      int waitCnt = 0;\n      CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n      while(true) {\n        checkDeleteBackupStatus.fetchStatus();\n        if(checkDeleteBackupStatus.fail != null) {\n          fail(checkDeleteBackupStatus.fail);\n        }\n        if(checkDeleteBackupStatus.success) {\n          break;\n        }\n        Thread.sleep(200);\n        if(waitCnt == 20) {\n          fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n        }\n        waitCnt++;\n      }\n\n      if(deleteBackupThread.fail != null) {\n        fail(deleteBackupThread.fail);\n      }\n    }\n    \n    //nocommit - Should move this to tearDown as it fails to delete the dir in case it fails?\n    for(int i=0 ; i< snapDir.length ; i++) {\n      AbstractSolrTestCase.recurseDelete(snapDir[i]); // clean up the snap dir\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e85f88536da92df6654f2182f3a477355cc4aae","date":1401284092,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    try {\n      String firstBackupTimestamp = null;\n      boolean namedBackup = true;\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n        if (!namedBackup && snapDir[0].exists()) {\n          fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n      for (int i = 0; i < 2; i++) {\n        //Test Deletion of named backup\n        BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n        deleteBackupThread.start();\n        int waitCnt = 0;\n        CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n        while (true) {\n          checkDeleteBackupStatus.fetchStatus();\n          if (checkDeleteBackupStatus.fail != null) {\n            fail(checkDeleteBackupStatus.fail);\n          }\n          if (checkDeleteBackupStatus.success) {\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (deleteBackupThread.fail != null) {\n          fail(deleteBackupThread.fail);\n        }\n      }\n    } finally {\n      TestUtil.rm(snapDir);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    try {\n      String firstBackupTimestamp = null;\n      boolean namedBackup = true;\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n        if (!namedBackup && snapDir[0].exists()) {\n          fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n      for (int i = 0; i < 2; i++) {\n        //Test Deletion of named backup\n        BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n        deleteBackupThread.start();\n        int waitCnt = 0;\n        CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n        while (true) {\n          checkDeleteBackupStatus.fetchStatus();\n          if (checkDeleteBackupStatus.fail != null) {\n            fail(checkDeleteBackupStatus.fail);\n          }\n          if (checkDeleteBackupStatus.success) {\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (deleteBackupThread.fail != null) {\n          fail(deleteBackupThread.fail);\n        }\n      }\n    }finally {\n      for (File dir : snapDir) if(dir !=null) AbstractSolrTestCase.recurseDelete(dir);\n    }\n    \n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da82efcd7cb9d11f61b585aa3dd2a28c5ad9605a","date":1401342189,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    try {\n      String firstBackupTimestamp = null;\n      boolean namedBackup = true;\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n        if (!namedBackup && snapDir[0].exists()) {\n          fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n      for (int i = 0; i < 2; i++) {\n        //Test Deletion of named backup\n        BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n        deleteBackupThread.start();\n        int waitCnt = 0;\n        CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n        while (true) {\n          checkDeleteBackupStatus.fetchStatus();\n          if (checkDeleteBackupStatus.fail != null) {\n            fail(checkDeleteBackupStatus.fail);\n          }\n          if (checkDeleteBackupStatus.success) {\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (deleteBackupThread.fail != null) {\n          fail(deleteBackupThread.fail);\n        }\n      }\n    } finally {\n      // FIXME: SOLR-6119 This is a test bug in that it tries to remove snapDirs that are still open.\n      try {\n        TestUtil.rm(snapDir);\n      } catch (IOException e) {\n        // Ignore failures.\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    try {\n      String firstBackupTimestamp = null;\n      boolean namedBackup = true;\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n        if (!namedBackup && snapDir[0].exists()) {\n          fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n      for (int i = 0; i < 2; i++) {\n        //Test Deletion of named backup\n        BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n        deleteBackupThread.start();\n        int waitCnt = 0;\n        CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n        while (true) {\n          checkDeleteBackupStatus.fetchStatus();\n          if (checkDeleteBackupStatus.fail != null) {\n            fail(checkDeleteBackupStatus.fail);\n          }\n          if (checkDeleteBackupStatus.success) {\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (deleteBackupThread.fail != null) {\n          fail(deleteBackupThread.fail);\n        }\n      }\n    } finally {\n      TestUtil.rm(snapDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9bb56e767bb86815d2433c9ee32cb883e0489e5","date":1401776474,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        for (int i = 0; i < 2; i++) {\n          BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n          deleteBackupThread.start();\n          int waitCnt = 0;\n          CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n          while (true) {\n            checkDeleteBackupStatus.fetchStatus();\n            if (checkDeleteBackupStatus.fail != null) {\n              fail(checkDeleteBackupStatus.fail);\n            }\n            if (checkDeleteBackupStatus.success) {\n              break;\n            }\n            Thread.sleep(200);\n            if (waitCnt == 20) {\n              fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n            }\n            waitCnt++;\n          }\n\n          if (deleteBackupThread.fail != null) {\n            fail(deleteBackupThread.fail);\n          }\n        }\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    try {\n      String firstBackupTimestamp = null;\n      boolean namedBackup = true;\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n        if (!namedBackup && snapDir[0].exists()) {\n          fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n        }\n      }\n\n      for (int i = 0; i < 2; i++) {\n        //Test Deletion of named backup\n        BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n        deleteBackupThread.start();\n        int waitCnt = 0;\n        CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n        while (true) {\n          checkDeleteBackupStatus.fetchStatus();\n          if (checkDeleteBackupStatus.fail != null) {\n            fail(checkDeleteBackupStatus.fail);\n          }\n          if (checkDeleteBackupStatus.success) {\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (deleteBackupThread.fail != null) {\n          fail(deleteBackupThread.fail);\n        }\n      }\n    } finally {\n      // FIXME: SOLR-6119 This is a test bug in that it tries to remove snapDirs that are still open.\n      try {\n        TestUtil.rm(snapDir);\n      } catch (IOException e) {\n        // Ignore failures.\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4dbfe3d3dc9ac9bda8ee276ce539e571f3125052","date":1401862284,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandlerBackup#doTestBackup().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestReplicationHandler#doTestBackup().mjava","sourceNew":"  @Test\n  public void doTestBackup() throws Exception {\n\n    int nDocs = TestUtil.nextInt(random(), 1, 100);\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"name\", \"name = \" + i);\n      masterClient.add(doc);\n    }\n\n    masterClient.commit();\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        testDeleteNamedBackup(backupNames);\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void doTestBackup() throws Exception {\n    String configFile = \"solrconfig-master1.xml\";\n    boolean addNumberToKeepInRequest = true;\n    String backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_REQUEST_PARAM;\n    if(random().nextBoolean()) {\n      configFile = \"solrconfig-master1-keepOneBackup.xml\";\n      addNumberToKeepInRequest = false;\n      backupKeepParamName = ReplicationHandler.NUMBER_BACKUPS_TO_KEEP_INIT_PARAM;\n    }\n\n    masterJetty.stop();\n    master.copyConfigFile(CONF_DIR + configFile,\n                          \"solrconfig.xml\");\n\n    masterJetty = createJetty(master);\n    masterClient.shutdown();\n    masterClient = createNewSolrServer(masterJetty.getLocalPort());\n\n    nDocs--;\n    masterClient.deleteByQuery(\"*:*\");\n    for (int i = 0; i < nDocs; i++)\n      index(masterClient, \"id\", i, \"name\", \"name = \" + i);\n\n    masterClient.commit();\n\n    class BackupThread extends Thread {\n      volatile String fail = null;\n      final boolean addNumberToKeepInRequest;\n      String backupKeepParamName;\n      String backupName;\n      String cmd;\n      BackupThread(boolean addNumberToKeepInRequest, String backupKeepParamName, String command) {\n        this.addNumberToKeepInRequest = addNumberToKeepInRequest;\n        this.backupKeepParamName = backupKeepParamName;\n        this.cmd = command;\n      }\n      BackupThread(String backupName, String command) {\n        this.backupName = backupName;\n        addNumberToKeepInRequest = false;\n        this.cmd = command;\n      }\n      @Override\n      public void run() {\n        String masterUrl = null;\n        if(backupName != null) {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              \"&name=\" +  backupName;\n        } else {\n          masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + cmd +\n              (addNumberToKeepInRequest ? \"&\" + backupKeepParamName + \"=1\" : \"\");\n        }\n\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    class CheckDeleteBackupStatus {\n      String response = null;\n      boolean success = false;\n      String fail = null;\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            success = true;\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n      };\n    }\n\n    class CheckBackupStatus {\n      String fail = null;\n      String response = null;\n      boolean success = false;\n      String backupTimestamp = null;\n      final String lastBackupTimestamp;\n      final Pattern p = Pattern.compile(\"<str name=\\\"snapshotCompletedAt\\\">(.*?)</str>\");\n\n      CheckBackupStatus(String lastBackupTimestamp) {\n        this.lastBackupTimestamp = lastBackupTimestamp;\n      }\n\n      public void fetchStatus() {\n        String masterUrl = buildUrl(masterJetty.getLocalPort()) + \"/replication?command=\" + ReplicationHandler.CMD_DETAILS;\n        URL url;\n        InputStream stream = null;\n        try {\n          url = new URL(masterUrl);\n          stream = url.openStream();\n          response = IOUtils.toString(stream, \"UTF-8\");\n          if(response.contains(\"<str name=\\\"status\\\">success</str>\")) {\n            Matcher m = p.matcher(response);\n            if(!m.find()) {\n              fail(\"could not find the completed timestamp in response.\");\n            }\n            backupTimestamp = m.group(1);\n            if(!backupTimestamp.equals(lastBackupTimestamp)) {\n              success = true;\n            }\n          }\n          stream.close();\n        } catch (Exception e) {\n          fail = e.getMessage();\n        } finally {\n          IOUtils.closeQuietly(stream);\n        }\n\n      };\n    };\n\n    File[] snapDir = new File[2];\n    boolean namedBackup = random().nextBoolean();\n    try {\n      String firstBackupTimestamp = null;\n\n      String[] backupNames = null;\n      if (namedBackup) {\n        backupNames = new String[2];\n      }\n      for (int i = 0; i < 2; i++) {\n        BackupThread backupThread;\n        final String backupName = TestUtil.randomSimpleString(random(), 1, 20);\n        if (!namedBackup) {\n          backupThread = new BackupThread(addNumberToKeepInRequest, backupKeepParamName, ReplicationHandler.CMD_BACKUP);\n        } else {\n          backupThread = new BackupThread(backupName, ReplicationHandler.CMD_BACKUP);\n          backupNames[i] = backupName;\n        }\n        backupThread.start();\n\n        File dataDir = new File(master.getDataDir());\n\n        int waitCnt = 0;\n        CheckBackupStatus checkBackupStatus = new CheckBackupStatus(firstBackupTimestamp);\n        while (true) {\n          checkBackupStatus.fetchStatus();\n          if (checkBackupStatus.fail != null) {\n            fail(checkBackupStatus.fail);\n          }\n          if (checkBackupStatus.success) {\n            if (i == 0) {\n              firstBackupTimestamp = checkBackupStatus.backupTimestamp;\n              Thread.sleep(1000); //ensure the next backup will have a different timestamp.\n            }\n            break;\n          }\n          Thread.sleep(200);\n          if (waitCnt == 20) {\n            fail(\"Backup success not detected:\" + checkBackupStatus.response);\n          }\n          waitCnt++;\n        }\n\n        if (backupThread.fail != null) {\n          fail(backupThread.fail);\n        }\n        File[] files = null;\n        if (!namedBackup) {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.startsWith(\"snapshot\")) {\n                return true;\n              }\n              return false;\n            }\n          });\n        } else {\n          files = dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n              if (name.equals(\"snapshot.\" + backupName)) {\n                return true;\n              }\n              return false;\n            }\n          });\n        }\n        assertEquals(1, files.length);\n        snapDir[i] = files[0];\n        Directory dir = new SimpleFSDirectory(snapDir[i].getAbsoluteFile());\n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        TopDocs hits = searcher.search(new MatchAllDocsQuery(), 1);\n        assertEquals(nDocs, hits.totalHits);\n        reader.close();\n        dir.close();\n\n      }\n\n      if (!namedBackup && snapDir[0].exists()) {\n        fail(\"The first backup should have been cleaned up because \" + backupKeepParamName + \" was set to 1.\");\n      }\n\n      //Test Deletion of named backup\n      if(namedBackup) {\n        for (int i = 0; i < 2; i++) {\n          BackupThread deleteBackupThread = new BackupThread(backupNames[i], ReplicationHandler.CMD_DELETE_BACKUP);\n          deleteBackupThread.start();\n          int waitCnt = 0;\n          CheckDeleteBackupStatus checkDeleteBackupStatus = new CheckDeleteBackupStatus();\n          while (true) {\n            checkDeleteBackupStatus.fetchStatus();\n            if (checkDeleteBackupStatus.fail != null) {\n              fail(checkDeleteBackupStatus.fail);\n            }\n            if (checkDeleteBackupStatus.success) {\n              break;\n            }\n            Thread.sleep(200);\n            if (waitCnt == 20) {\n              fail(\"Delete Backup success not detected:\" + checkDeleteBackupStatus.response);\n            }\n            waitCnt++;\n          }\n\n          if (deleteBackupThread.fail != null) {\n            fail(deleteBackupThread.fail);\n          }\n        }\n      }\n\n    } finally {\n      if(!namedBackup) {\n        TestUtil.rm(snapDir);\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":["cbc3688252d4a8045d69a164236b2cf87b721f17","e48bb0af7b982aecd8dbafdbeded231282bfdee2","5b847bb03f0ad90d50073e48e452f3346df87482"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"da82efcd7cb9d11f61b585aa3dd2a28c5ad9605a":["4e85f88536da92df6654f2182f3a477355cc4aae"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["47c952a4f0f0e9b74763a0609a3726dbb217164a","7530de27b87b961b51f01bd1299b7004d46e8823"],"4e85f88536da92df6654f2182f3a477355cc4aae":["6c127aec2f246ace289d4dd91232cd2319547df1"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["0e7c2454a6a8237bfd0e953f5b940838408c9055","4448c35ccdaef2a8501f93c0dfe9fe79b19402cc"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["4f11ea4f58f7fefe4a8c99ee19b3c388d7f98d60","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"81ec897f0eb789ef9536a8130d1cdb9337ef108a":["a59489bd57cb6434aab4e536a03b260fec1d47f3"],"6be5df27d60dc5fe63f0769ec2fa9d843bf3867a":["b1ba16dd7ab27ab1e2a4c5b045289afe706917f8"],"a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"b1ba16dd7ab27ab1e2a4c5b045289afe706917f8":["c60702a3a59ccba6a09292e99bc59b2863ed5153"],"4448c35ccdaef2a8501f93c0dfe9fe79b19402cc":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"47c952a4f0f0e9b74763a0609a3726dbb217164a":["f864968c86dfe89d25f9a927bc3dd26df981607f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","f864968c86dfe89d25f9a927bc3dd26df981607f"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["6be5df27d60dc5fe63f0769ec2fa9d843bf3867a"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["4f11ea4f58f7fefe4a8c99ee19b3c388d7f98d60"],"4dbfe3d3dc9ac9bda8ee276ce539e571f3125052":["c9bb56e767bb86815d2433c9ee32cb883e0489e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4f11ea4f58f7fefe4a8c99ee19b3c388d7f98d60":["a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["1bf853f0385a540ee0fb220fd272f2c362432294"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","f864968c86dfe89d25f9a927bc3dd26df981607f"],"f864968c86dfe89d25f9a927bc3dd26df981607f":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"1bf853f0385a540ee0fb220fd272f2c362432294":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c60702a3a59ccba6a09292e99bc59b2863ed5153":["1805600f3c01671239e987d431c6440245e612ca"],"7ae05237914af33835981f3271dd3c0d753a43be":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"6c127aec2f246ace289d4dd91232cd2319547df1":["a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c"],"c9bb56e767bb86815d2433c9ee32cb883e0489e5":["da82efcd7cb9d11f61b585aa3dd2a28c5ad9605a"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["81ec897f0eb789ef9536a8130d1cdb9337ef108a"],"1805600f3c01671239e987d431c6440245e612ca":["7ae05237914af33835981f3271dd3c0d753a43be"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["4448c35ccdaef2a8501f93c0dfe9fe79b19402cc"],"7530de27b87b961b51f01bd1299b7004d46e8823":["47c952a4f0f0e9b74763a0609a3726dbb217164a"],"a59489bd57cb6434aab4e536a03b260fec1d47f3":["7530de27b87b961b51f01bd1299b7004d46e8823"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4dbfe3d3dc9ac9bda8ee276ce539e571f3125052"]},"commit2Childs":{"da82efcd7cb9d11f61b585aa3dd2a28c5ad9605a":["c9bb56e767bb86815d2433c9ee32cb883e0489e5"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"4e85f88536da92df6654f2182f3a477355cc4aae":["da82efcd7cb9d11f61b585aa3dd2a28c5ad9605a"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"81ec897f0eb789ef9536a8130d1cdb9337ef108a":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"6be5df27d60dc5fe63f0769ec2fa9d843bf3867a":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c":["6c127aec2f246ace289d4dd91232cd2319547df1"],"b1ba16dd7ab27ab1e2a4c5b045289afe706917f8":["6be5df27d60dc5fe63f0769ec2fa9d843bf3867a"],"4448c35ccdaef2a8501f93c0dfe9fe79b19402cc":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"47c952a4f0f0e9b74763a0609a3726dbb217164a":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","f864968c86dfe89d25f9a927bc3dd26df981607f"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","4448c35ccdaef2a8501f93c0dfe9fe79b19402cc"],"4dbfe3d3dc9ac9bda8ee276ce539e571f3125052":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1bf853f0385a540ee0fb220fd272f2c362432294"],"4f11ea4f58f7fefe4a8c99ee19b3c388d7f98d60":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["4f11ea4f58f7fefe4a8c99ee19b3c388d7f98d60"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"f864968c86dfe89d25f9a927bc3dd26df981607f":["47c952a4f0f0e9b74763a0609a3726dbb217164a","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"1bf853f0385a540ee0fb220fd272f2c362432294":["a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"c60702a3a59ccba6a09292e99bc59b2863ed5153":["b1ba16dd7ab27ab1e2a4c5b045289afe706917f8"],"7ae05237914af33835981f3271dd3c0d753a43be":["1805600f3c01671239e987d431c6440245e612ca"],"6c127aec2f246ace289d4dd91232cd2319547df1":["4e85f88536da92df6654f2182f3a477355cc4aae"],"c9bb56e767bb86815d2433c9ee32cb883e0489e5":["4dbfe3d3dc9ac9bda8ee276ce539e571f3125052"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["a5bb2e653b3f6992c26fe4cc0f3fbdce37b21c3c"],"1805600f3c01671239e987d431c6440245e612ca":["c60702a3a59ccba6a09292e99bc59b2863ed5153"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["7ae05237914af33835981f3271dd3c0d753a43be"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a59489bd57cb6434aab4e536a03b260fec1d47f3"],"a59489bd57cb6434aab4e536a03b260fec1d47f3":["81ec897f0eb789ef9536a8130d1cdb9337ef108a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}