{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","commits":[{"id":"e03de8487b5529b7efe527294d12d2c2afa5b6ed","date":1352486832,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"/dev/null","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          final IndexInput in = data.clone();\n          final BytesRef scratch = new BytesRef();\n          final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n          final ParsePosition pos = new ParsePosition(0);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          // nocommit\n          return null;\n        } else if (DocValues.isSortedBytes(dvType)) {\n          // nocommit\n          return null;\n        }\n        // nocommit\n        return null;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3df0b32deea7de1aa88a87ebd41a6d4679b3f66e","date":1352516698,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n        final ParsePosition pos = new ParsePosition(0);\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef bytesIn) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                byte[] bytes = new byte[len];\n                in.readBytes(bytes, 0, bytes.length);\n                // nocommit MUST i reuse the incoming\n                // arg....?  we should clarify semantics\n                return new BytesRef(bytes);\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n          // nocommit\n          return null;\n        }\n        // nocommit\n        return null;\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          final IndexInput in = data.clone();\n          final BytesRef scratch = new BytesRef();\n          final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n          final ParsePosition pos = new ParsePosition(0);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          // nocommit\n          return null;\n        } else if (DocValues.isSortedBytes(dvType)) {\n          // nocommit\n          return null;\n        }\n        // nocommit\n        return null;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a739a0e263ee8fbb9f15a2ace678e14cc7c614ec","date":1352568536,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n        final ParsePosition pos = new ParsePosition(0);\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), pos).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n        final ParsePosition pos = new ParsePosition(0);\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef bytesIn) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                byte[] bytes = new byte[len];\n                in.readBytes(bytes, 0, bytes.length);\n                // nocommit MUST i reuse the incoming\n                // arg....?  we should clarify semantics\n                return new BytesRef(bytes);\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n          // nocommit\n          return null;\n        }\n        // nocommit\n        return null;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7a8f6a0f831abdaf62496526336f43bbf7c5bbe","date":1352951976,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n        final ParsePosition pos = new ParsePosition(0);\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                System.out.println(\"trying to parse number: \" + scratch.utf8ToString());\n                // nocommit\n                long seekPos = field.dataStartFilePointer;\n                byte wholeFile[] = new byte[(int)(in.length()-seekPos)];\n                IndexInput foo = in.clone();\n                foo.seek(seekPos);\n                foo.readBytes(wholeFile, 0, wholeFile.length);\n                System.out.println(\"rest: \" + new String(wholeFile, 0, wholeFile.length, \"UTF-8\"));\n                return field.minValue + decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), pos).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n        final ParsePosition pos = new ParsePosition(0);\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), pos).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36c0f6c09668001b298edab167cfc244c906de1a","date":1352953421,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n        final ParsePosition pos = new ParsePosition(0);\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return field.minValue + decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), pos).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n        final ParsePosition pos = new ParsePosition(0);\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                System.out.println(\"trying to parse number: \" + scratch.utf8ToString());\n                // nocommit\n                long seekPos = field.dataStartFilePointer;\n                byte wholeFile[] = new byte[(int)(in.length()-seekPos)];\n                IndexInput foo = in.clone();\n                foo.seek(seekPos);\n                foo.readBytes(wholeFile, 0, wholeFile.length);\n                System.out.println(\"rest: \" + new String(wholeFile, 0, wholeFile.length, \"UTF-8\"));\n                return field.minValue + decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), pos).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a47efa78e788c0e07f09493b2dc8e027f8dc6e67","date":1352956175,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                return field.minValue + decoder.parse(scratch.utf8ToString(), new ParsePosition(0)).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), new ParsePosition(0)).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n        final ParsePosition pos = new ParsePosition(0);\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return field.minValue + decoder.parse(scratch.utf8ToString(), pos).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), pos).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13b40d7b5a40b306d198a2c868823813753fc679","date":1352958277,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          decoder.setParseBigDecimal(true);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                BigDecimal bd = (BigDecimal) decoder.parse(scratch.utf8ToString(), new ParsePosition(0));\n                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), new ParsePosition(0)).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                return field.minValue + decoder.parse(scratch.utf8ToString(), new ParsePosition(0)).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), new ParsePosition(0)).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4eaed6f1c6b9414b862b32281f53ef421918dcf","date":1353000825,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          decoder.setParseBigDecimal(true);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                //System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                BigDecimal bd = (BigDecimal) decoder.parse(scratch.utf8ToString(), new ParsePosition(0));\n                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), new ParsePosition(0)).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          decoder.setParseBigDecimal(true);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                BigDecimal bd = (BigDecimal) decoder.parse(scratch.utf8ToString(), new ParsePosition(0));\n                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), new ParsePosition(0)).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f894c4cd0d6b7910b6eac1c6025b646f98fab43","date":1353001764,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          decoder.setParseBigDecimal(true);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                //System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                BigDecimal bd;\n                try {\n                  bd = (BigDecimal) decoder.parse(scratch.utf8ToString());\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse BigDecimal value\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  // nocommit add message\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse int length\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                try {\n                  return ordDecoder.parse(scratch.utf8ToString()).intValue();\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse ord\");\n                  e.initCause(pe);\n                  throw e;\n                }\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse int length\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          decoder.setParseBigDecimal(true);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                //System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                BigDecimal bd = (BigDecimal) decoder.parse(scratch.utf8ToString(), new ParsePosition(0));\n                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                return ordDecoder.parse(scratch.utf8ToString(), new ParsePosition(0)).intValue();\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  throw new RuntimeException(pe);\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"737c1bba990ea3999c9cebd84ee765f8d95f29fc","date":1353002499,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          decoder.setParseBigDecimal(true);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                //System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                BigDecimal bd;\n                try {\n                  bd = (BigDecimal) decoder.parse(scratch.utf8ToString());\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse BigDecimal value\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  // nocommit add message\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse int length\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + docID * (1 + field.ordPattern.length()));\n                SimpleTextUtil.readLine(in, scratch);\n                try {\n                  return ordDecoder.parse(scratch.utf8ToString()).intValue();\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse ord\");\n                  e.initCause(pe);\n                  throw e;\n                }\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse int length\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          decoder.setParseBigDecimal(true);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                //System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                BigDecimal bd;\n                try {\n                  bd = (BigDecimal) decoder.parse(scratch.utf8ToString());\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse BigDecimal value\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  // nocommit add message\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse int length\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);\n                SimpleTextUtil.readLine(in, scratch);\n                try {\n                  return ordDecoder.parse(scratch.utf8ToString()).intValue();\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse ord\");\n                  e.initCause(pe);\n                  throw e;\n                }\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse int length\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cd329bd749496f6c58b586a6c0dd0dc8201206f","date":1353092226,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadDirectSource().mjava","sourceNew":null,"sourceOld":"      @Override\n      public Source loadDirectSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        final IndexInput in = data.clone();\n        final BytesRef scratch = new BytesRef();\n        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));\n\n        if (DocValues.isNumber(dvType)) {\n          decoder.setParseBigDecimal(true);\n          return new Source(dvType) {\n            @Override\n            public long getInt(int docID) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                //System.out.println(\"parsing delta: \" + scratch.utf8ToString());\n                BigDecimal bd;\n                try {\n                  bd = (BigDecimal) decoder.parse(scratch.utf8ToString());\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse BigDecimal value\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isBytes(dvType)) {\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              try {\n                // nocommit bounds check docID?  spooky\n                // because if we don't you can maybe get\n                // value from the wrong field ...\n                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  // nocommit add message\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse int length\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n          };\n        } else if (DocValues.isSortedBytes(dvType)) {\n\n          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              try {\n                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + docID * (1 + field.ordPattern.length()));\n                SimpleTextUtil.readLine(in, scratch);\n                try {\n                  return ordDecoder.parse(scratch.utf8ToString()).intValue();\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse ord\");\n                  e.initCause(pe);\n                  throw e;\n                }\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              try {\n                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));\n                SimpleTextUtil.readLine(in, scratch);\n                assert StringHelper.startsWith(scratch, LENGTH);\n                int len;\n                try {\n                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, \"UTF-8\")).intValue();\n                } catch (ParseException pe) {\n                  CorruptIndexException e = new CorruptIndexException(\"failed to parse int length\");\n                  e.initCause(pe);\n                  throw e;\n                }\n                result.bytes = new byte[len];\n                result.offset = 0;\n                result.length = len;\n                in.readBytes(result.bytes, 0, len);\n                return result;\n              } catch (IOException ioe) {\n                // nocommit should .get() just throw IOE...\n                throw new RuntimeException(ioe);\n              }\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5f894c4cd0d6b7910b6eac1c6025b646f98fab43":["e4eaed6f1c6b9414b862b32281f53ef421918dcf"],"a47efa78e788c0e07f09493b2dc8e027f8dc6e67":["36c0f6c09668001b298edab167cfc244c906de1a"],"737c1bba990ea3999c9cebd84ee765f8d95f29fc":["5f894c4cd0d6b7910b6eac1c6025b646f98fab43"],"13b40d7b5a40b306d198a2c868823813753fc679":["a47efa78e788c0e07f09493b2dc8e027f8dc6e67"],"c7a8f6a0f831abdaf62496526336f43bbf7c5bbe":["a739a0e263ee8fbb9f15a2ace678e14cc7c614ec"],"e4eaed6f1c6b9414b862b32281f53ef421918dcf":["13b40d7b5a40b306d198a2c868823813753fc679"],"a739a0e263ee8fbb9f15a2ace678e14cc7c614ec":["3df0b32deea7de1aa88a87ebd41a6d4679b3f66e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7cd329bd749496f6c58b586a6c0dd0dc8201206f":["737c1bba990ea3999c9cebd84ee765f8d95f29fc"],"36c0f6c09668001b298edab167cfc244c906de1a":["c7a8f6a0f831abdaf62496526336f43bbf7c5bbe"],"3df0b32deea7de1aa88a87ebd41a6d4679b3f66e":["e03de8487b5529b7efe527294d12d2c2afa5b6ed"],"e03de8487b5529b7efe527294d12d2c2afa5b6ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5f894c4cd0d6b7910b6eac1c6025b646f98fab43":["737c1bba990ea3999c9cebd84ee765f8d95f29fc"],"a47efa78e788c0e07f09493b2dc8e027f8dc6e67":["13b40d7b5a40b306d198a2c868823813753fc679"],"737c1bba990ea3999c9cebd84ee765f8d95f29fc":["7cd329bd749496f6c58b586a6c0dd0dc8201206f"],"13b40d7b5a40b306d198a2c868823813753fc679":["e4eaed6f1c6b9414b862b32281f53ef421918dcf"],"c7a8f6a0f831abdaf62496526336f43bbf7c5bbe":["36c0f6c09668001b298edab167cfc244c906de1a"],"e4eaed6f1c6b9414b862b32281f53ef421918dcf":["5f894c4cd0d6b7910b6eac1c6025b646f98fab43"],"a739a0e263ee8fbb9f15a2ace678e14cc7c614ec":["c7a8f6a0f831abdaf62496526336f43bbf7c5bbe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e03de8487b5529b7efe527294d12d2c2afa5b6ed","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7cd329bd749496f6c58b586a6c0dd0dc8201206f":[],"36c0f6c09668001b298edab167cfc244c906de1a":["a47efa78e788c0e07f09493b2dc8e027f8dc6e67"],"3df0b32deea7de1aa88a87ebd41a6d4679b3f66e":["a739a0e263ee8fbb9f15a2ace678e14cc7c614ec"],"e03de8487b5529b7efe527294d12d2c2afa5b6ed":["3df0b32deea7de1aa88a87ebd41a6d4679b3f66e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7cd329bd749496f6c58b586a6c0dd0dc8201206f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}