{"path":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","commits":[{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getShards().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getShards().keySet());\n      }\n      \n      String state = props.get(ZkStateReader.STATE_PROP);\n      String nodeName = props.get(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = zkStateReader.getLeaderProps(collection, slice);\n      boolean isLeader = leader.get(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName);\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getShards().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getShards().keySet());\n      }\n      \n      String state = props.get(ZkStateReader.STATE_PROP);\n      String nodeName = props.get(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = zkStateReader.getLeaderProps(collection, slice);\n      boolean isLeader = leader.get(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName);\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getShards().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getShards().keySet());\n      }\n      \n      String state = props.get(ZkStateReader.STATE_PROP);\n      String nodeName = props.get(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = zkStateReader.getLeaderProps(collection, slice);\n      boolean isLeader = leader.get(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName);\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getShards().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getShards().keySet());\n      }\n      \n      String state = props.get(ZkStateReader.STATE_PROP);\n      String nodeName = props.get(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = zkStateReader.getLeaderProps(collection, slice);\n      boolean isLeader = leader.get(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName);\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getShards().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getShards().keySet());\n      }\n      \n      String state = props.get(ZkStateReader.STATE_PROP);\n      String nodeName = props.get(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = zkStateReader.getLeaderProps(collection, slice);\n      boolean isLeader = leader.get(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName);\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = zkStateReader.getLeaderProps(collection, slice);\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName);\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getShards().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getShards().keySet());\n      }\n      \n      String state = props.get(ZkStateReader.STATE_PROP);\n      String nodeName = props.get(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = zkStateReader.getLeaderProps(collection, slice);\n      boolean isLeader = leader.get(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName);\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderProps(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = zkStateReader.getLeaderProps(collection, slice);\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName);\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","fa64435b5902ce266c23755a4a00691a3285dab8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlicesMap(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderProps(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderProps(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlicesMap(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderProps(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlices(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderProps(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56a558aa5aadd60ae850d1ab090098bc63bdfaf9","date":1355245333,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlicesMap(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlicesMap(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderProps(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlicesMap(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlicesMap(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderProps(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"880ba9508bc60f5a45941227f966e69e521ead10","date":1390432381,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n\n    int numRunning = 0;\n    int numRecovering = 0;\n    int numActive = 0;\n    \n    for (CloudJettyRunner cloudJetty : shardToJetty.get(slice)) {\n      boolean running = true;\n      \n      // get latest cloud state\n      zkStateReader.updateClusterState(true);\n      \n      Slice theShards = zkStateReader.getClusterState().getSlicesMap(collection)\n          .get(slice);\n      \n      ZkNodeProps props = theShards.getReplicasMap().get(cloudJetty.coreNodeName);\n      if (props == null) {\n        throw new RuntimeException(\"shard name \" + cloudJetty.coreNodeName + \" not found in \" + theShards.getReplicasMap().keySet());\n      }\n      \n      String state = props.getStr(ZkStateReader.STATE_PROP);\n      String nodeName = props.getStr(ZkStateReader.NODE_NAME_PROP);\n      \n      \n      if (!cloudJetty.jetty.isRunning()\n          || !state.equals(ZkStateReader.ACTIVE)\n          || !zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        running = false;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.RECOVERING)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numRecovering++;\n      }\n      \n      if (cloudJetty.jetty.isRunning()\n          && state.equals(ZkStateReader.ACTIVE)\n          && zkStateReader.getClusterState().liveNodesContain(nodeName)) {\n        numActive++;\n      }\n      \n      if (running) {\n        numRunning++;\n      }\n    }\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e332392bbbdd01cb69ad6a89051f483cda38e15e","date":1395758779,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try (SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n        if (core == null) {\n          monkeyLog(\"selected jetty not running correctly - skip\");\n          return null;\n        }\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (core == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try {\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      } finally {\n        core.close();\n      }\n      \n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1088b72b3b4cc45316b7595bd09023c859cd2327","date":1447150009,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try (SolrCore core = cjetty.jetty.getCoreContainer().getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n        if (core == null) {\n          monkeyLog(\"selected jetty not running correctly - skip\");\n          return null;\n        }\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n      \n      FilterHolder fh = cjetty.jetty.getDispatchFilter();\n      if (fh == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      SolrDispatchFilter df = ((SolrDispatchFilter) fh.getFilter());\n      if (df == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n      CoreContainer cores = df.getCores();\n      if (cores == null) {\n        monkeyLog(\"selected jetty not running correctly - skip\");\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try (SolrCore core = cores.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n        if (core == null) {\n          monkeyLog(\"selected jetty not running correctly - skip\");\n          return null;\n        }\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"536b47681314488eb94706248be6047a3f142841","date":1450372090,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      try (SolrCore core = cjetty.jetty.getCoreContainer().getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n        if (core == null) {\n          monkeyLog(\"selected jetty not running correctly - skip\");\n          return null;\n        }\n        rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":["de814b9ce0a0386c8ce277a2d4f35018bb0653a4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e373ca932bd347b9022c6fd6565e227010c6a9c","date":1458065865,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = chaosRandom.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    Random random = LuceneTestCase.random();\n    int chance = random.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = random.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    boolean canKillIndexer = canKillIndexer(slice);\n    \n    if (!canKillIndexer) {\n      monkeyLog(\"Number of indexer nodes (nrt or tlog replicas) is not enough to kill one of them, Will only choose a pull replica to kill\");\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty = null;\n    if (chance <= 5 && aggressivelyKillLeaders && canKillIndexer) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      // get random node\n      int attempt = 0;\n      while (true) {\n        attempt++;\n        int index = chaosRandom.nextInt(jetties.size());\n        cjetty = jetties.get(index);\n        if (canKillIndexer || getTypeForJetty(slice, cjetty) == Replica.Type.PULL) {\n          break;\n        } else if (attempt > 20) {\n          monkeyLog(\"Can't kill indexer nodes (nrt or tlog replicas) and couldn't find a random pull node after 20 attempts - monkey cannot kill :(\");\n          return null;\n        }\n      }\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(cjetty.nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = chaosRandom.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    boolean canKillIndexer = canKillIndexer(slice);\n    \n    if (!canKillIndexer) {\n      monkeyLog(\"Number of indexer nodes (nrt or tlog replicas) is not enough to kill one of them, Will only choose a pull replica to kill\");\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty = null;\n    if (chance <= 5 && aggressivelyKillLeaders && canKillIndexer) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      // get random node\n      int attempt = 0;\n      while (true) {\n        attempt++;\n        int index = chaosRandom.nextInt(jetties.size());\n        cjetty = jetties.get(index);\n        if (canKillIndexer || getTypeForJetty(slice, cjetty) == Replica.Type.PULL) {\n          break;\n        } else if (attempt > 20) {\n          monkeyLog(\"Can't kill indexer nodes (nrt or tlog replicas) and couldn't find a random pull node after 20 attempts - monkey cannot kill :(\");\n          return null;\n        }\n      }\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(cjetty.nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty;\n    if (chance <= 5 && aggressivelyKillLeaders) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      // get random shard\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      int index = chaosRandom.nextInt(jetties.size());\n      cjetty = jetties.get(index);\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(jetties.get(index).nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de814b9ce0a0386c8ce277a2d4f35018bb0653a4","date":1515567502,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    boolean canKillIndexer = canKillIndexer(slice);\n    \n    if (!canKillIndexer) {\n      monkeyLog(\"Number of indexer nodes (nrt or tlog replicas) is not enough to kill one of them, Will only choose a pull replica to kill\");\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty = null;\n    if (chance <= 5 && aggressivelyKillLeaders && canKillIndexer) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      // get random node\n      int attempt = 0;\n      while (true) {\n        attempt++;\n        int index = chaosRandom.nextInt(jetties.size());\n        cjetty = jetties.get(index);\n        if (canKillIndexer || getTypeForJetty(slice, cjetty) == Replica.Type.PULL) {\n          break;\n        } else if (attempt > 20) {\n          monkeyLog(\"Can't kill indexer nodes (nrt or tlog replicas) and couldn't find a random pull node after 20 attempts - monkey cannot kill :(\");\n          return null;\n        }\n      }\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          rtIsLeader = core != null && core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(cjetty.nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    boolean canKillIndexer = canKillIndexer(slice);\n    \n    if (!canKillIndexer) {\n      monkeyLog(\"Number of indexer nodes (nrt or tlog replicas) is not enough to kill one of them, Will only choose a pull replica to kill\");\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty = null;\n    if (chance <= 5 && aggressivelyKillLeaders && canKillIndexer) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      // get random node\n      int attempt = 0;\n      while (true) {\n        attempt++;\n        int index = chaosRandom.nextInt(jetties.size());\n        cjetty = jetties.get(index);\n        if (canKillIndexer || getTypeForJetty(slice, cjetty) == Replica.Type.PULL) {\n          break;\n        } else if (attempt > 20) {\n          monkeyLog(\"Can't kill indexer nodes (nrt or tlog replicas) and couldn't find a random pull node after 20 attempts - monkey cannot kill :(\");\n          return null;\n        }\n      }\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(cjetty.nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":["536b47681314488eb94706248be6047a3f142841"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    boolean canKillIndexer = canKillIndexer(slice);\n    \n    if (!canKillIndexer) {\n      monkeyLog(\"Number of indexer nodes (nrt or tlog replicas) is not enough to kill one of them, Will only choose a pull replica to kill\");\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty = null;\n    if (chance <= 5 && aggressivelyKillLeaders && canKillIndexer) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      // get random node\n      int attempt = 0;\n      while (true) {\n        attempt++;\n        int index = chaosRandom.nextInt(jetties.size());\n        cjetty = jetties.get(index);\n        if (canKillIndexer || getTypeForJetty(slice, cjetty) == Replica.Type.PULL) {\n          break;\n        } else if (attempt > 20) {\n          monkeyLog(\"Can't kill indexer nodes (nrt or tlog replicas) and couldn't find a random pull node after 20 attempts - monkey cannot kill :(\");\n          return null;\n        }\n      }\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          rtIsLeader = core != null && core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(cjetty.nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    boolean canKillIndexer = canKillIndexer(slice);\n    \n    if (!canKillIndexer) {\n      monkeyLog(\"Number of indexer nodes (nrt or tlog replicas) is not enough to kill one of them, Will only choose a pull replica to kill\");\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty = null;\n    if (chance <= 5 && aggressivelyKillLeaders && canKillIndexer) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      // get random node\n      int attempt = 0;\n      while (true) {\n        attempt++;\n        int index = chaosRandom.nextInt(jetties.size());\n        cjetty = jetties.get(index);\n        if (canKillIndexer || getTypeForJetty(slice, cjetty) == Replica.Type.PULL) {\n          break;\n        } else if (attempt > 20) {\n          monkeyLog(\"Can't kill indexer nodes (nrt or tlog replicas) and couldn't find a random pull node after 20 attempts - monkey cannot kill :(\");\n          return null;\n        }\n      }\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          if (core == null) {\n            monkeyLog(\"selected jetty not running correctly - skip\");\n            return null;\n          }\n          rtIsLeader = core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(cjetty.nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#getRandomJetty(String,boolean).mjava","sourceNew":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = getNumRunning(slice);\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    if (numActive == 2) {\n      // we are careful\n      Thread.sleep(1000);\n      \n      numActive = checkIfKillIsLegal(slice, numActive);\n      \n      if (numActive < 2) {\n        // we cannot kill anyone\n        monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n        return null;\n      }\n      \n      numRunning = getNumRunning(slice);\n      \n      if (numRunning < 2) {\n        // we cannot kill anyone\n        monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n        return null;\n      }\n    }\n    \n    boolean canKillIndexer = canKillIndexer(slice);\n    \n    if (!canKillIndexer) {\n      monkeyLog(\"Number of indexer nodes (nrt or tlog replicas) is not enough to kill one of them, Will only choose a pull replica to kill\");\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty = null;\n    if (chance <= 5 && aggressivelyKillLeaders && canKillIndexer) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      // get random node\n      int attempt = 0;\n      while (true) {\n        attempt++;\n        int index = chaosRandom.nextInt(jetties.size());\n        cjetty = jetties.get(index);\n        if (canKillIndexer || getTypeForJetty(slice, cjetty) == Replica.Type.PULL) {\n          break;\n        } else if (attempt > 20) {\n          monkeyLog(\"Can't kill indexer nodes (nrt or tlog replicas) and couldn't find a random pull node after 20 attempts - monkey cannot kill :(\");\n          return null;\n        }\n      }\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          rtIsLeader = core != null && core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(cjetty.nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","sourceOld":"  public CloudJettyRunner getRandomJetty(String slice, boolean aggressivelyKillLeaders) throws KeeperException, InterruptedException {\n    \n    int numActive = 0;\n    \n    numActive = checkIfKillIsLegal(slice, numActive);\n    \n    // TODO: stale state makes this a tough call\n    if (numActive < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    // let's check the deadpool count\n    int numRunning = 0;\n    for (CloudJettyRunner cjetty : shardToJetty.get(slice)) {\n      if (!deadPool.contains(cjetty)) {\n        numRunning++;\n      }\n    }\n    \n    if (numRunning < 2) {\n      // we cannot kill anyone\n      monkeyLog(\"only one active node in shard - monkey cannot kill :(\");\n      return null;\n    }\n    \n    boolean canKillIndexer = canKillIndexer(slice);\n    \n    if (!canKillIndexer) {\n      monkeyLog(\"Number of indexer nodes (nrt or tlog replicas) is not enough to kill one of them, Will only choose a pull replica to kill\");\n    }\n    \n    int chance = chaosRandom.nextInt(10);\n    CloudJettyRunner cjetty = null;\n    if (chance <= 5 && aggressivelyKillLeaders && canKillIndexer) {\n      // if killLeader, really aggressively go after leaders\n      cjetty = shardToLeaderJetty.get(slice);\n    } else {\n      List<CloudJettyRunner> jetties = shardToJetty.get(slice);\n      // get random node\n      int attempt = 0;\n      while (true) {\n        attempt++;\n        int index = chaosRandom.nextInt(jetties.size());\n        cjetty = jetties.get(index);\n        if (canKillIndexer || getTypeForJetty(slice, cjetty) == Replica.Type.PULL) {\n          break;\n        } else if (attempt > 20) {\n          monkeyLog(\"Can't kill indexer nodes (nrt or tlog replicas) and couldn't find a random pull node after 20 attempts - monkey cannot kill :(\");\n          return null;\n        }\n      }\n      \n      ZkNodeProps leader = null;\n      try {\n        leader = zkStateReader.getLeaderRetry(collection, slice);\n      } catch (Throwable t) {\n        log.error(\"Could not get leader\", t);\n        return null;\n      }\n\n      // cluster state can be stale - also go by our 'near real-time' is leader prop\n      boolean rtIsLeader;\n      CoreContainer cc = cjetty.jetty.getCoreContainer();\n      if (cc != null) {\n        try (SolrCore core = cc.getCore(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          rtIsLeader = core != null && core.getCoreDescriptor().getCloudDescriptor().isLeader();\n        }\n      } else {\n        return null;\n      }\n\n      boolean isLeader = leader.getStr(ZkStateReader.NODE_NAME_PROP).equals(cjetty.nodeName)\n          || rtIsLeader;\n      if (!aggressivelyKillLeaders && isLeader) {\n        // we don't kill leaders...\n        monkeyLog(\"abort! I don't kill leaders\");\n        return null;\n      } \n    }\n\n    if (cjetty.jetty.getLocalPort() == -1) {\n      // we can't kill the dead\n      monkeyLog(\"abort! This guy is already dead\");\n      return null;\n    }\n    \n    //System.out.println(\"num active:\" + numActive + \" for \" + slice + \" sac:\" + jetty.getLocalPort());\n    monkeyLog(\"chose a victim! \" + cjetty.jetty.getLocalPort());\n  \n    return cjetty;\n  }\n\n","bugFix":["880ba9508bc60f5a45941227f966e69e521ead10"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","56a558aa5aadd60ae850d1ab090098bc63bdfaf9"],"b94236357aaa22b76c10629851fe4e376e0cea82":["61c45e99cf6676da48f19d7511c73712ad39402b","de814b9ce0a0386c8ce277a2d4f35018bb0653a4"],"61c45e99cf6676da48f19d7511c73712ad39402b":["6e373ca932bd347b9022c6fd6565e227010c6a9c"],"536b47681314488eb94706248be6047a3f142841":["1088b72b3b4cc45316b7595bd09023c859cd2327"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b94236357aaa22b76c10629851fe4e376e0cea82"],"6e373ca932bd347b9022c6fd6565e227010c6a9c":["536b47681314488eb94706248be6047a3f142841"],"fa64435b5902ce266c23755a4a00691a3285dab8":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a6378064655e76cd7b908b1cab4ce425b384b508","c5a558d54519c651068ddb202f03befefb1514a7"],"880ba9508bc60f5a45941227f966e69e521ead10":["56a558aa5aadd60ae850d1ab090098bc63bdfaf9"],"de814b9ce0a0386c8ce277a2d4f35018bb0653a4":["61c45e99cf6676da48f19d7511c73712ad39402b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["6e373ca932bd347b9022c6fd6565e227010c6a9c","61c45e99cf6676da48f19d7511c73712ad39402b"],"a6378064655e76cd7b908b1cab4ce425b384b508":["fa64435b5902ce266c23755a4a00691a3285dab8"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"1088b72b3b4cc45316b7595bd09023c859cd2327":["e332392bbbdd01cb69ad6a89051f483cda38e15e"],"c5a558d54519c651068ddb202f03befefb1514a7":["a6378064655e76cd7b908b1cab4ce425b384b508"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"e332392bbbdd01cb69ad6a89051f483cda38e15e":["880ba9508bc60f5a45941227f966e69e521ead10"],"56a558aa5aadd60ae850d1ab090098bc63bdfaf9":["c5a558d54519c651068ddb202f03befefb1514a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"b94236357aaa22b76c10629851fe4e376e0cea82":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"61c45e99cf6676da48f19d7511c73712ad39402b":["b94236357aaa22b76c10629851fe4e376e0cea82","de814b9ce0a0386c8ce277a2d4f35018bb0653a4","e9017cf144952056066919f1ebc7897ff9bd71b1"],"536b47681314488eb94706248be6047a3f142841":["6e373ca932bd347b9022c6fd6565e227010c6a9c"],"6e373ca932bd347b9022c6fd6565e227010c6a9c":["61c45e99cf6676da48f19d7511c73712ad39402b","e9017cf144952056066919f1ebc7897ff9bd71b1"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fa64435b5902ce266c23755a4a00691a3285dab8":["a6378064655e76cd7b908b1cab4ce425b384b508"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"880ba9508bc60f5a45941227f966e69e521ead10":["e332392bbbdd01cb69ad6a89051f483cda38e15e"],"de814b9ce0a0386c8ce277a2d4f35018bb0653a4":["b94236357aaa22b76c10629851fe4e376e0cea82"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a6378064655e76cd7b908b1cab4ce425b384b508":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"1088b72b3b4cc45316b7595bd09023c859cd2327":["536b47681314488eb94706248be6047a3f142841"],"c5a558d54519c651068ddb202f03befefb1514a7":["407687e67faf6e1f02a211ca078d8e3eed631027","56a558aa5aadd60ae850d1ab090098bc63bdfaf9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","2c30e4c1cee08b3b229a77991882594fe7250b66"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"e332392bbbdd01cb69ad6a89051f483cda38e15e":["1088b72b3b4cc45316b7595bd09023c859cd2327"],"56a558aa5aadd60ae850d1ab090098bc63bdfaf9":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","880ba9508bc60f5a45941227f966e69e521ead10"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["fa64435b5902ce266c23755a4a00691a3285dab8","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","e9017cf144952056066919f1ebc7897ff9bd71b1","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}