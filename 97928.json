{"path":"solr/core/src/test/org/apache/solr/cloud/RollingRestartTest#waitUntilOverseerDesignateIsLeader(SolrZkClient,List[String],long).mjava","commits":[{"id":"6e48507d567e98bb5eb2343b1a17f7d27435807f","date":1406016099,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RollingRestartTest#waitUntilOverseerDesignateIsLeader(SolrZkClient,List[String],long).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RollingRestartTest#waitUntilOverseerDesignateIsLeader(SolrZkClient,List[String],int).mjava","sourceNew":"  static boolean waitUntilOverseerDesignateIsLeader(SolrZkClient testZkClient, List<String> overseerDesignates, long timeoutInNanos) throws KeeperException, InterruptedException {\n    long now = System.nanoTime();\n    long maxTimeout = now + timeoutInNanos; // the maximum amount of time we're willing to wait to see the designate as leader\n    long timeout = now + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n    boolean firstTime = true;\n    int stableCheckTimeout = 2000;\n    String oldleader = null;\n    while (System.nanoTime() < timeout && System.nanoTime() < maxTimeout) {\n      String newLeader = OverseerCollectionProcessor.getLeaderNode(testZkClient);\n      if (newLeader != null && !newLeader.equals(oldleader)) {\n        // the leaders have changed, let's move the timeout further\n        timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n        log.info(\"oldLeader={} newLeader={} - Advancing timeout to: {}\", oldleader, newLeader, timeout);\n        oldleader = newLeader;\n      }\n      if (!overseerDesignates.contains(newLeader)) {\n        Thread.sleep(500);\n      } else {\n        if (firstTime) {\n          firstTime = false;\n          Thread.sleep(stableCheckTimeout);\n        } else {\n          return true;\n        }\n      }\n    }\n    if (System.nanoTime() < maxTimeout) {\n      log.error(\"Max wait time exceeded\");\n    }\n    return false;\n  }\n\n","sourceOld":"  static boolean waitUntilOverseerDesignateIsLeader(SolrZkClient testZkClient, List<String> overseerDesignates, int timeoutInSeconds) throws KeeperException, InterruptedException {\n    long now = System.nanoTime();\n    long timeout = now + TimeUnit.NANOSECONDS.convert(timeoutInSeconds, TimeUnit.SECONDS);\n    boolean firstTime = true;\n    int stableCheckTimeout = 2000;\n    while (System.nanoTime() < timeout) {\n      String newLeader = OverseerCollectionProcessor.getLeaderNode(testZkClient);\n      if (!overseerDesignates.contains(newLeader)) {\n        Thread.sleep(500);\n      } else {\n        if (firstTime)  {\n          firstTime = false;\n          Thread.sleep(stableCheckTimeout);\n        } else  {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2209af2c265d2258ec4b29c8cc78622d36994a15","date":1440641916,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/RollingRestartTest#waitUntilOverseerDesignateIsLeader(SolrZkClient,List[String],long).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/RollingRestartTest#waitUntilOverseerDesignateIsLeader(SolrZkClient,List[String],long).mjava","sourceNew":"  static boolean waitUntilOverseerDesignateIsLeader(SolrZkClient testZkClient, List<String> overseerDesignates, long timeoutInNanos) throws KeeperException, InterruptedException {\n    long now = System.nanoTime();\n    long maxTimeout = now + timeoutInNanos; // the maximum amount of time we're willing to wait to see the designate as leader\n    long timeout = now + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n    boolean firstTime = true;\n    int stableCheckTimeout = 2000;\n    String oldleader = null;\n    while (System.nanoTime() < timeout && System.nanoTime() < maxTimeout) {\n      String newLeader = OverseerCollectionConfigSetProcessor.getLeaderNode(testZkClient);\n      if (newLeader != null && !newLeader.equals(oldleader)) {\n        // the leaders have changed, let's move the timeout further\n        timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n        log.info(\"oldLeader={} newLeader={} - Advancing timeout to: {}\", oldleader, newLeader, timeout);\n        oldleader = newLeader;\n      }\n      if (!overseerDesignates.contains(newLeader)) {\n        Thread.sleep(500);\n      } else {\n        if (firstTime) {\n          firstTime = false;\n          Thread.sleep(stableCheckTimeout);\n        } else {\n          return true;\n        }\n      }\n    }\n    if (System.nanoTime() < maxTimeout) {\n      log.error(\"Max wait time exceeded\");\n    }\n    return false;\n  }\n\n","sourceOld":"  static boolean waitUntilOverseerDesignateIsLeader(SolrZkClient testZkClient, List<String> overseerDesignates, long timeoutInNanos) throws KeeperException, InterruptedException {\n    long now = System.nanoTime();\n    long maxTimeout = now + timeoutInNanos; // the maximum amount of time we're willing to wait to see the designate as leader\n    long timeout = now + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n    boolean firstTime = true;\n    int stableCheckTimeout = 2000;\n    String oldleader = null;\n    while (System.nanoTime() < timeout && System.nanoTime() < maxTimeout) {\n      String newLeader = OverseerCollectionProcessor.getLeaderNode(testZkClient);\n      if (newLeader != null && !newLeader.equals(oldleader)) {\n        // the leaders have changed, let's move the timeout further\n        timeout = System.nanoTime() + TimeUnit.NANOSECONDS.convert(60, TimeUnit.SECONDS);\n        log.info(\"oldLeader={} newLeader={} - Advancing timeout to: {}\", oldleader, newLeader, timeout);\n        oldleader = newLeader;\n      }\n      if (!overseerDesignates.contains(newLeader)) {\n        Thread.sleep(500);\n      } else {\n        if (firstTime) {\n          firstTime = false;\n          Thread.sleep(stableCheckTimeout);\n        } else {\n          return true;\n        }\n      }\n    }\n    if (System.nanoTime() < maxTimeout) {\n      log.error(\"Max wait time exceeded\");\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6e48507d567e98bb5eb2343b1a17f7d27435807f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["6e48507d567e98bb5eb2343b1a17f7d27435807f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2209af2c265d2258ec4b29c8cc78622d36994a15"]},"commit2Childs":{"6e48507d567e98bb5eb2343b1a17f7d27435807f":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e48507d567e98bb5eb2343b1a17f7d27435807f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}