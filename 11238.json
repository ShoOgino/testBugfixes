{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","commits":[{"id":"851e4197476b684154a7b65f996f535522e67400","date":1428926498,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","pathOld":"/dev/null","sourceNew":"    /** Accumulate bounds information for this plane, intersected with the unit sphere.\n    * Updates both latitude and longitude information, using max/min points found\n    * within the specified bounds.\n    *@param boundsInfo is the info to update with additional bounding information.\n    *@param bounds are the surfaces delineating what's inside the shape.\n    */\n    public void recordBounds(Bounds boundsInfo, Membership... bounds) {\n        // For clarity, load local variables with good names\n        double A = this.x;\n        double B = this.y;\n        double C = this.z;\n\n        // Now compute latitude min/max points\n        if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n            if ((Math.abs(A) >= 1e-10 || Math.abs(B) >= 1e-10)) {\n                //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n                // sin (phi) = z\n                // cos (theta - phi) = D\n                // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n                // Q: what is z?\n                //\n                // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n                if (Math.abs(C) < 1.0e-10) {\n                    // Special case: circle is vertical.\n                    //System.out.println(\"Degenerate case; it's vertical circle\");\n                    // cos(phi) = D, and we want sin(phi) = z\n                    // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n                    // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n                    \n                    double z;\n                    double x;\n                    double y;\n\n                    double denom = 1.0 / (A*A + B*B);\n\n                    z = Math.sqrt(1.0 - D*D);\n                    y = -B * D * denom;\n                    x = -A * D * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                    z = -z;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                } else {\n                    // We might be able to identify a specific new latitude maximum or minimum.\n                    //\n                    // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n                    //\n                    // This is tricky.  If cos(phi) = something, and we want to figure out\n                    // what sin(phi) is, in order to capture all solutions we need to recognize\n                    // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n                    // whatever solution we find we have to mirror it across the x-y plane,\n                    // and include both +z and -z solutions.\n                    //\n                    // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n                    // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n                    //\n                    // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n                    // Substitute:\n                    // D = sqrt(1-C^2) * sqrt(1-z^2) + C * z\n                    // Solve for z...\n                    // D-Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n                    // Square both sides.\n                    // (D-Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz  = 1 - C^2 - z^2\n                    // 0 = z^2 - 2DCz + (C^2 +D^2-1) = 0\n                    //\n                    // z = (2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n                    // z  = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n                    //    = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n\n                    double z;\n                    double x;\n                    double y;\n                    \n                    double sqrtValue = D*D*C*C + 1.0 - C*C - D*D;\n                    if (sqrtValue >= 0.0) {\n                        // y = -B[D+Cz] / [A^2 + B^2]\n                        // x = -A[D+Cz] / [A^2 + B^2]\n                        double denom = 1.0 / (A*A + B*B);\n                        if (sqrtValue == 0.0) {\n                            //System.out.println(\"Zero sqrt term\");\n                            z = D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        } else {\n                            double sqrtResult = Math.sqrt(sqrtValue);\n                            z = D*C + sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = D*C - sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C + sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C - sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Horizontal circle.\n                // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n                // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n                // to check Membership objects.\n                boundsInfo.addHorizontalCircle(-D * C);\n            }\n        }\n        \n        // First, figure out our longitude bounds, unless we no longer need to consider that\n        if (!boundsInfo.checkNoLongitudeBound()) {\n            \n            //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n            // Compute longitude bounds\n            \n            double a;\n            double b;\n            double c;\n            \n            if (Math.abs(C) < 1e-10) {\n                // Degenerate; the equation describes a line\n                //System.out.println(\"It's a zero-width ellipse\");\n                // Ax + By + D = 0\n                if (Math.abs(D) >= 1e-10) {\n                    if (Math.abs(A) > Math.abs(B)) {\n                        // Use equation suitable for A != 0\n                        // We need to find the endpoints of the zero-width ellipse.\n                        // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n                        // of that line.  But luckily, we know some things: specifically, since it is a\n                        // degenerate situation in projection, the C value had to have been 0.  That\n                        // means that our line's endpoints will coincide with the unit circle.  All we\n                        // need to do then is to find the intersection of the unit circle and the line\n                        // equation:\n                        //\n                        // A x + B y + D = 0\n                        // \n                        // Since A != 0:\n                        // x = (-By - D)/A\n                        // \n                        // The unit circle:\n                        // x^2 + y^2 - 1 = 0\n                        // Substitute:\n                        // [(-By-D)/A]^2 + y^2 -1 = 0\n                        // Multiply through by A^2:\n                        // [-By - D]^2 + A^2*y^2 - A^2 = 0\n                        // Multiply out:\n                        // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n                        // Group:\n                        // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n                        \n                        a = B * B + A * A;\n                        b = 2.0 * B * D;\n                        c = D * D - A * A;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n                            \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-D - B * y0) / A;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / A;\n                                \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n\n                                double x0a = (-D - B * y0a) * Hdenom;\n                                double x0b = (-D - B * y0b) * Hdenom;\n                                \n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n\n                    } else {\n                        // Use equation suitable for B != 0\n                        // Since I != 0, we rewrite:\n                        // y = (-Ax - D)/B\n                        a = B * B + A * A;\n                        b = 2.0 * A * D;\n                        c = D * D - B * B;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n\n                        if (sqrtClause >= 0.0) {\n\n                            if (sqrtClause == 0.0) {\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (- D - A * x0) / B;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / B;\n                                \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (- D - A * x0a) * Idenom;\n                                double y0b = (- D - A * x0b) * Idenom;\n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n                \n            } else {\n\n                // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n                // From plane:\n                // z = (-Ax - By - D) / C\n                // From unit sphere:\n                // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n                // Simplify/expand:\n                // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n                // \n                // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n                // Group:\n                // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n                // For convenience, introduce post-projection coefficient variables to make life easier.\n                // E x^2 + F y^2 + G xy + H x + I y + J = 0\n                double E = A * A + C * C;\n                double F = B * B + C * C;\n                double G = 2.0 * A * B;\n                double H = 2.0 * A * D;\n                double I = 2.0 * B * D;\n                double J = D * D - C * C;\n\n                //System.out.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n                \n                // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n                if (J > 0.0) {\n                    // The derivative of the curve above is:\n                    // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n                    // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n                    // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n                    //\n                    // The equation of a line going through the origin with the slope dy/dx is:\n                    // y = dy/dx x\n                    // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n                    // Rearrange:\n                    // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n                    // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n                    // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                    //\n                    // Multiply the original equation by 2:\n                    // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n                    // Subtract one from the other, to remove the high-order terms:\n                    // Hx + Iy + 2J = 0\n                    // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n                    // But we will need to base this on which coefficient is non-zero\n                    \n                    if (Math.abs(H) > Math.abs(I)) {\n                        //System.out.println(\"Using the y quadratic\");\n                        // x = (-2J - Iy)/H\n                        \n                        // Plug into the original equation:\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n                        // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n                        \n                        // Plug into derivative equation:\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n                        // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n                        // Multiply by H^2 to make manipulation easier\n                        // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n                        // Do the square\n                        // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n                        // Multiply it out\n                        // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n                        // Group:\n                        // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * E * I * J - 2.0 * G * H * J;\n                        c = 4.0 * E * J * J - J * H * H;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-2.0 * J - I * y0) / H;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / H;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n                                double x0a = (-2.0 * J - I * y0a) * Hdenom;\n                                double x0b = (-2.0 * J - I * y0b) * Hdenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }                        \n\n                    } else {\n                        //System.out.println(\"Using the x quadratic\");\n                        // y = (-2J - Hx)/I\n                        \n                        // Plug into the original equation:\n                        // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n                        // Multiply by I^2 to make manipulation easier\n                        // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n                        // Do the square\n                        // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n                        // Multiply it out\n                        // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n                        // Group:\n                        // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * F * H * J - 2.0 * G * I * J;\n                        c = 4.0 * F * J * J - J * I * I;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            \n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (-2.0 * J - H * x0) / I;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / I;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (-2.0 * J - H * x0a) * Idenom;\n                                double y0b = (-2.0 * J - H * x0b) * Idenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fb9dbed1415914caa27460f8abb7afadaa61451","date":1429504289,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","sourceNew":"    /** Accumulate bounds information for this plane, intersected with the unit sphere.\n    * Updates both latitude and longitude information, using max/min points found\n    * within the specified bounds.\n    *@param boundsInfo is the info to update with additional bounding information.\n    *@param bounds are the surfaces delineating what's inside the shape.\n    */\n    public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n        // For clarity, load local variables with good names\n        double A = this.x;\n        double B = this.y;\n        double C = this.z;\n\n        // Now compute latitude min/max points\n        if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n            if ((Math.abs(A) >= 1e-10 || Math.abs(B) >= 1e-10)) {\n                //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n                // sin (phi) = z\n                // cos (theta - phi) = D\n                // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n                // Q: what is z?\n                //\n                // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n                if (Math.abs(C) < 1.0e-10) {\n                    // Special case: circle is vertical.\n                    //System.out.println(\"Degenerate case; it's vertical circle\");\n                    // cos(phi) = D, and we want sin(phi) = z\n                    // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n                    // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n                    \n                    double z;\n                    double x;\n                    double y;\n\n                    double denom = 1.0 / (A*A + B*B);\n\n                    z = Math.sqrt(1.0 - D*D);\n                    y = -B * D * denom;\n                    x = -A * D * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                    z = -z;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                } else {\n                    // We might be able to identify a specific new latitude maximum or minimum.\n                    //\n                    // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n                    //\n                    // This is tricky.  If cos(phi) = something, and we want to figure out\n                    // what sin(phi) is, in order to capture all solutions we need to recognize\n                    // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n                    // whatever solution we find we have to mirror it across the x-y plane,\n                    // and include both +z and -z solutions.\n                    //\n                    // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n                    // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n                    //\n                    // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n                    // Substitute:\n                    // D = sqrt(1-C^2) * sqrt(1-z^2) + C * z\n                    // Solve for z...\n                    // D-Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n                    // Square both sides.\n                    // (D-Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz  = 1 - C^2 - z^2\n                    // 0 = z^2 - 2DCz + (C^2 +D^2-1) = 0\n                    //\n                    // z = (2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n                    // z  = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n                    //    = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n\n                    double z;\n                    double x;\n                    double y;\n                    \n                    double sqrtValue = D*D*C*C + 1.0 - C*C - D*D;\n                    if (sqrtValue >= 0.0) {\n                        // y = -B[D+Cz] / [A^2 + B^2]\n                        // x = -A[D+Cz] / [A^2 + B^2]\n                        double denom = 1.0 / (A*A + B*B);\n                        if (sqrtValue == 0.0) {\n                            //System.out.println(\"Zero sqrt term\");\n                            z = D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        } else {\n                            double sqrtResult = Math.sqrt(sqrtValue);\n                            z = D*C + sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = D*C - sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C + sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C - sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Horizontal circle.\n                // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n                // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n                // to check Membership objects.\n                boundsInfo.addHorizontalCircle(-D * C);\n            }\n        }\n        \n        // First, figure out our longitude bounds, unless we no longer need to consider that\n        if (!boundsInfo.checkNoLongitudeBound()) {\n            \n            //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n            // Compute longitude bounds\n            \n            double a;\n            double b;\n            double c;\n            \n            if (Math.abs(C) < 1e-10) {\n                // Degenerate; the equation describes a line\n                //System.out.println(\"It's a zero-width ellipse\");\n                // Ax + By + D = 0\n                if (Math.abs(D) >= 1e-10) {\n                    if (Math.abs(A) > Math.abs(B)) {\n                        // Use equation suitable for A != 0\n                        // We need to find the endpoints of the zero-width ellipse.\n                        // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n                        // of that line.  But luckily, we know some things: specifically, since it is a\n                        // degenerate situation in projection, the C value had to have been 0.  That\n                        // means that our line's endpoints will coincide with the unit circle.  All we\n                        // need to do then is to find the intersection of the unit circle and the line\n                        // equation:\n                        //\n                        // A x + B y + D = 0\n                        // \n                        // Since A != 0:\n                        // x = (-By - D)/A\n                        // \n                        // The unit circle:\n                        // x^2 + y^2 - 1 = 0\n                        // Substitute:\n                        // [(-By-D)/A]^2 + y^2 -1 = 0\n                        // Multiply through by A^2:\n                        // [-By - D]^2 + A^2*y^2 - A^2 = 0\n                        // Multiply out:\n                        // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n                        // Group:\n                        // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n                        \n                        a = B * B + A * A;\n                        b = 2.0 * B * D;\n                        c = D * D - A * A;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n                            \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-D - B * y0) / A;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / A;\n                                \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n\n                                double x0a = (-D - B * y0a) * Hdenom;\n                                double x0b = (-D - B * y0b) * Hdenom;\n                                \n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n\n                    } else {\n                        // Use equation suitable for B != 0\n                        // Since I != 0, we rewrite:\n                        // y = (-Ax - D)/B\n                        a = B * B + A * A;\n                        b = 2.0 * A * D;\n                        c = D * D - B * B;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n\n                        if (sqrtClause >= 0.0) {\n\n                            if (sqrtClause == 0.0) {\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (- D - A * x0) / B;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / B;\n                                \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (- D - A * x0a) * Idenom;\n                                double y0b = (- D - A * x0b) * Idenom;\n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n                \n            } else {\n\n                // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n                // From plane:\n                // z = (-Ax - By - D) / C\n                // From unit sphere:\n                // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n                // Simplify/expand:\n                // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n                // \n                // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n                // Group:\n                // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n                // For convenience, introduce post-projection coefficient variables to make life easier.\n                // E x^2 + F y^2 + G xy + H x + I y + J = 0\n                double E = A * A + C * C;\n                double F = B * B + C * C;\n                double G = 2.0 * A * B;\n                double H = 2.0 * A * D;\n                double I = 2.0 * B * D;\n                double J = D * D - C * C;\n\n                //System.out.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n                \n                // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n                if (J > 0.0) {\n                    // The derivative of the curve above is:\n                    // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n                    // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n                    // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n                    //\n                    // The equation of a line going through the origin with the slope dy/dx is:\n                    // y = dy/dx x\n                    // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n                    // Rearrange:\n                    // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n                    // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n                    // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                    //\n                    // Multiply the original equation by 2:\n                    // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n                    // Subtract one from the other, to remove the high-order terms:\n                    // Hx + Iy + 2J = 0\n                    // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n                    // But we will need to base this on which coefficient is non-zero\n                    \n                    if (Math.abs(H) > Math.abs(I)) {\n                        //System.out.println(\"Using the y quadratic\");\n                        // x = (-2J - Iy)/H\n                        \n                        // Plug into the original equation:\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n                        // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n                        \n                        // Plug into derivative equation:\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n                        // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n                        // Multiply by H^2 to make manipulation easier\n                        // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n                        // Do the square\n                        // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n                        // Multiply it out\n                        // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n                        // Group:\n                        // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * E * I * J - 2.0 * G * H * J;\n                        c = 4.0 * E * J * J - J * H * H;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-2.0 * J - I * y0) / H;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / H;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n                                double x0a = (-2.0 * J - I * y0a) * Hdenom;\n                                double x0b = (-2.0 * J - I * y0b) * Hdenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }                        \n\n                    } else {\n                        //System.out.println(\"Using the x quadratic\");\n                        // y = (-2J - Hx)/I\n                        \n                        // Plug into the original equation:\n                        // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n                        // Multiply by I^2 to make manipulation easier\n                        // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n                        // Do the square\n                        // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n                        // Multiply it out\n                        // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n                        // Group:\n                        // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * F * H * J - 2.0 * G * I * J;\n                        c = 4.0 * F * J * J - J * I * I;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            \n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (-2.0 * J - H * x0) / I;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / I;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (-2.0 * J - H * x0a) * Idenom;\n                                double y0b = (-2.0 * J - H * x0b) * Idenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n","sourceOld":"    /** Accumulate bounds information for this plane, intersected with the unit sphere.\n    * Updates both latitude and longitude information, using max/min points found\n    * within the specified bounds.\n    *@param boundsInfo is the info to update with additional bounding information.\n    *@param bounds are the surfaces delineating what's inside the shape.\n    */\n    public void recordBounds(Bounds boundsInfo, Membership... bounds) {\n        // For clarity, load local variables with good names\n        double A = this.x;\n        double B = this.y;\n        double C = this.z;\n\n        // Now compute latitude min/max points\n        if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n            if ((Math.abs(A) >= 1e-10 || Math.abs(B) >= 1e-10)) {\n                //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n                // sin (phi) = z\n                // cos (theta - phi) = D\n                // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n                // Q: what is z?\n                //\n                // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n                if (Math.abs(C) < 1.0e-10) {\n                    // Special case: circle is vertical.\n                    //System.out.println(\"Degenerate case; it's vertical circle\");\n                    // cos(phi) = D, and we want sin(phi) = z\n                    // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n                    // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n                    \n                    double z;\n                    double x;\n                    double y;\n\n                    double denom = 1.0 / (A*A + B*B);\n\n                    z = Math.sqrt(1.0 - D*D);\n                    y = -B * D * denom;\n                    x = -A * D * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                    z = -z;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                } else {\n                    // We might be able to identify a specific new latitude maximum or minimum.\n                    //\n                    // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n                    //\n                    // This is tricky.  If cos(phi) = something, and we want to figure out\n                    // what sin(phi) is, in order to capture all solutions we need to recognize\n                    // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n                    // whatever solution we find we have to mirror it across the x-y plane,\n                    // and include both +z and -z solutions.\n                    //\n                    // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n                    // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n                    //\n                    // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n                    // Substitute:\n                    // D = sqrt(1-C^2) * sqrt(1-z^2) + C * z\n                    // Solve for z...\n                    // D-Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n                    // Square both sides.\n                    // (D-Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz  = 1 - C^2 - z^2\n                    // 0 = z^2 - 2DCz + (C^2 +D^2-1) = 0\n                    //\n                    // z = (2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n                    // z  = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n                    //    = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n\n                    double z;\n                    double x;\n                    double y;\n                    \n                    double sqrtValue = D*D*C*C + 1.0 - C*C - D*D;\n                    if (sqrtValue >= 0.0) {\n                        // y = -B[D+Cz] / [A^2 + B^2]\n                        // x = -A[D+Cz] / [A^2 + B^2]\n                        double denom = 1.0 / (A*A + B*B);\n                        if (sqrtValue == 0.0) {\n                            //System.out.println(\"Zero sqrt term\");\n                            z = D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        } else {\n                            double sqrtResult = Math.sqrt(sqrtValue);\n                            z = D*C + sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = D*C - sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C + sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C - sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Horizontal circle.\n                // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n                // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n                // to check Membership objects.\n                boundsInfo.addHorizontalCircle(-D * C);\n            }\n        }\n        \n        // First, figure out our longitude bounds, unless we no longer need to consider that\n        if (!boundsInfo.checkNoLongitudeBound()) {\n            \n            //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n            // Compute longitude bounds\n            \n            double a;\n            double b;\n            double c;\n            \n            if (Math.abs(C) < 1e-10) {\n                // Degenerate; the equation describes a line\n                //System.out.println(\"It's a zero-width ellipse\");\n                // Ax + By + D = 0\n                if (Math.abs(D) >= 1e-10) {\n                    if (Math.abs(A) > Math.abs(B)) {\n                        // Use equation suitable for A != 0\n                        // We need to find the endpoints of the zero-width ellipse.\n                        // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n                        // of that line.  But luckily, we know some things: specifically, since it is a\n                        // degenerate situation in projection, the C value had to have been 0.  That\n                        // means that our line's endpoints will coincide with the unit circle.  All we\n                        // need to do then is to find the intersection of the unit circle and the line\n                        // equation:\n                        //\n                        // A x + B y + D = 0\n                        // \n                        // Since A != 0:\n                        // x = (-By - D)/A\n                        // \n                        // The unit circle:\n                        // x^2 + y^2 - 1 = 0\n                        // Substitute:\n                        // [(-By-D)/A]^2 + y^2 -1 = 0\n                        // Multiply through by A^2:\n                        // [-By - D]^2 + A^2*y^2 - A^2 = 0\n                        // Multiply out:\n                        // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n                        // Group:\n                        // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n                        \n                        a = B * B + A * A;\n                        b = 2.0 * B * D;\n                        c = D * D - A * A;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n                            \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-D - B * y0) / A;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / A;\n                                \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n\n                                double x0a = (-D - B * y0a) * Hdenom;\n                                double x0b = (-D - B * y0b) * Hdenom;\n                                \n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n\n                    } else {\n                        // Use equation suitable for B != 0\n                        // Since I != 0, we rewrite:\n                        // y = (-Ax - D)/B\n                        a = B * B + A * A;\n                        b = 2.0 * A * D;\n                        c = D * D - B * B;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n\n                        if (sqrtClause >= 0.0) {\n\n                            if (sqrtClause == 0.0) {\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (- D - A * x0) / B;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / B;\n                                \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (- D - A * x0a) * Idenom;\n                                double y0b = (- D - A * x0b) * Idenom;\n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n                \n            } else {\n\n                // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n                // From plane:\n                // z = (-Ax - By - D) / C\n                // From unit sphere:\n                // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n                // Simplify/expand:\n                // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n                // \n                // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n                // Group:\n                // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n                // For convenience, introduce post-projection coefficient variables to make life easier.\n                // E x^2 + F y^2 + G xy + H x + I y + J = 0\n                double E = A * A + C * C;\n                double F = B * B + C * C;\n                double G = 2.0 * A * B;\n                double H = 2.0 * A * D;\n                double I = 2.0 * B * D;\n                double J = D * D - C * C;\n\n                //System.out.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n                \n                // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n                if (J > 0.0) {\n                    // The derivative of the curve above is:\n                    // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n                    // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n                    // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n                    //\n                    // The equation of a line going through the origin with the slope dy/dx is:\n                    // y = dy/dx x\n                    // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n                    // Rearrange:\n                    // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n                    // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n                    // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                    //\n                    // Multiply the original equation by 2:\n                    // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n                    // Subtract one from the other, to remove the high-order terms:\n                    // Hx + Iy + 2J = 0\n                    // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n                    // But we will need to base this on which coefficient is non-zero\n                    \n                    if (Math.abs(H) > Math.abs(I)) {\n                        //System.out.println(\"Using the y quadratic\");\n                        // x = (-2J - Iy)/H\n                        \n                        // Plug into the original equation:\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n                        // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n                        \n                        // Plug into derivative equation:\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n                        // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n                        // Multiply by H^2 to make manipulation easier\n                        // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n                        // Do the square\n                        // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n                        // Multiply it out\n                        // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n                        // Group:\n                        // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * E * I * J - 2.0 * G * H * J;\n                        c = 4.0 * E * J * J - J * H * H;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-2.0 * J - I * y0) / H;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / H;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n                                double x0a = (-2.0 * J - I * y0a) * Hdenom;\n                                double x0b = (-2.0 * J - I * y0b) * Hdenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }                        \n\n                    } else {\n                        //System.out.println(\"Using the x quadratic\");\n                        // y = (-2J - Hx)/I\n                        \n                        // Plug into the original equation:\n                        // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n                        // Multiply by I^2 to make manipulation easier\n                        // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n                        // Do the square\n                        // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n                        // Multiply it out\n                        // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n                        // Group:\n                        // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * F * H * J - 2.0 * G * I * J;\n                        c = 4.0 * F * J * J - J * I * I;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            \n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (-2.0 * J - H * x0) / I;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / I;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (-2.0 * J - H * x0a) * Idenom;\n                                double y0b = (-2.0 * J - H * x0b) * Idenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7aca5c321bc9760dbfc9cefcc9d648e946b4615e","date":1429714020,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","sourceNew":"    /** Accumulate bounds information for this plane, intersected with the unit sphere.\n    * Updates both latitude and longitude information, using max/min points found\n    * within the specified bounds.\n    *@param boundsInfo is the info to update with additional bounding information.\n    *@param bounds are the surfaces delineating what's inside the shape.\n    */\n    public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n        // For clarity, load local variables with good names\n        double A = this.x;\n        double B = this.y;\n        double C = this.z;\n\n        // Now compute latitude min/max points\n        if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n            if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n                //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n                // sin (phi) = z\n                // cos (theta - phi) = D\n                // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n                // Q: what is z?\n                //\n                // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n                if (Math.abs(C) < 1.0e-10) {\n                    // Special case: circle is vertical.\n                    //System.out.println(\"Degenerate case; it's vertical circle\");\n                    // cos(phi) = D, and we want sin(phi) = z\n                    // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n                    // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n                    \n                    double z;\n                    double x;\n                    double y;\n\n                    double denom = 1.0 / (A*A + B*B);\n\n                    z = Math.sqrt(1.0 - D*D);\n                    y = -B * D * denom;\n                    x = -A * D * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                    z = -z;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                } else {\n                    // We might be able to identify a specific new latitude maximum or minimum.\n                    //\n                    // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n                    //\n                    // This is tricky.  If cos(phi) = something, and we want to figure out\n                    // what sin(phi) is, in order to capture all solutions we need to recognize\n                    // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n                    // whatever solution we find we have to mirror it across the x-y plane,\n                    // and include both +z and -z solutions.\n                    //\n                    // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n                    // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n                    //\n                    // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n                    // Substitute:\n                    // D = sqrt(1-C^2) * sqrt(1-z^2) + C * z\n                    // Solve for z...\n                    // D-Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n                    // Square both sides.\n                    // (D-Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz  = 1 - C^2 - z^2\n                    // 0 = z^2 - 2DCz + (C^2 +D^2-1) = 0\n                    //\n                    // z = (2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n                    // z  = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n                    //    = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n\n                    double z;\n                    double x;\n                    double y;\n                    \n                    double sqrtValue = D*D*C*C + 1.0 - C*C - D*D;\n                    if (sqrtValue >= 0.0) {\n                        // y = -B[D+Cz] / [A^2 + B^2]\n                        // x = -A[D+Cz] / [A^2 + B^2]\n                        double denom = 1.0 / (A*A + B*B);\n                        if (sqrtValue == 0.0) {\n                            //System.out.println(\"Zero sqrt term\");\n                            z = D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        } else {\n                            double sqrtResult = Math.sqrt(sqrtValue);\n                            z = D*C + sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = D*C - sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C + sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C - sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Horizontal circle.\n                // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n                // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n                // to check Membership objects.\n                boundsInfo.addHorizontalCircle(-D * C);\n            }\n        }\n        \n        // First, figure out our longitude bounds, unless we no longer need to consider that\n        if (!boundsInfo.checkNoLongitudeBound()) {\n            \n            //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n            // Compute longitude bounds\n            \n            double a;\n            double b;\n            double c;\n            \n            if (Math.abs(C) < MINIMUM_RESOLUTION) {\n                // Degenerate; the equation describes a line\n                //System.out.println(\"It's a zero-width ellipse\");\n                // Ax + By + D = 0\n                if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n                    if (Math.abs(A) > Math.abs(B)) {\n                        // Use equation suitable for A != 0\n                        // We need to find the endpoints of the zero-width ellipse.\n                        // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n                        // of that line.  But luckily, we know some things: specifically, since it is a\n                        // degenerate situation in projection, the C value had to have been 0.  That\n                        // means that our line's endpoints will coincide with the unit circle.  All we\n                        // need to do then is to find the intersection of the unit circle and the line\n                        // equation:\n                        //\n                        // A x + B y + D = 0\n                        // \n                        // Since A != 0:\n                        // x = (-By - D)/A\n                        // \n                        // The unit circle:\n                        // x^2 + y^2 - 1 = 0\n                        // Substitute:\n                        // [(-By-D)/A]^2 + y^2 -1 = 0\n                        // Multiply through by A^2:\n                        // [-By - D]^2 + A^2*y^2 - A^2 = 0\n                        // Multiply out:\n                        // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n                        // Group:\n                        // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n                        \n                        a = B * B + A * A;\n                        b = 2.0 * B * D;\n                        c = D * D - A * A;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n                            \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-D - B * y0) / A;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / A;\n                                \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n\n                                double x0a = (-D - B * y0a) * Hdenom;\n                                double x0b = (-D - B * y0b) * Hdenom;\n                                \n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n\n                    } else {\n                        // Use equation suitable for B != 0\n                        // Since I != 0, we rewrite:\n                        // y = (-Ax - D)/B\n                        a = B * B + A * A;\n                        b = 2.0 * A * D;\n                        c = D * D - B * B;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n\n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (- D - A * x0) / B;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / B;\n                                \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (- D - A * x0a) * Idenom;\n                                double y0b = (- D - A * x0b) * Idenom;\n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n                \n            } else {\n\n                // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n                // From plane:\n                // z = (-Ax - By - D) / C\n                // From unit sphere:\n                // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n                // Simplify/expand:\n                // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n                // \n                // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n                // Group:\n                // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n                // For convenience, introduce post-projection coefficient variables to make life easier.\n                // E x^2 + F y^2 + G xy + H x + I y + J = 0\n                double E = A * A + C * C;\n                double F = B * B + C * C;\n                double G = 2.0 * A * B;\n                double H = 2.0 * A * D;\n                double I = 2.0 * B * D;\n                double J = D * D - C * C;\n\n                //System.out.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n                \n                // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n                if (J > 0.0) {\n                    // The derivative of the curve above is:\n                    // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n                    // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n                    // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n                    //\n                    // The equation of a line going through the origin with the slope dy/dx is:\n                    // y = dy/dx x\n                    // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n                    // Rearrange:\n                    // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n                    // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n                    // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                    //\n                    // Multiply the original equation by 2:\n                    // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n                    // Subtract one from the other, to remove the high-order terms:\n                    // Hx + Iy + 2J = 0\n                    // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n                    // But we will need to base this on which coefficient is non-zero\n                    \n                    if (Math.abs(H) > Math.abs(I)) {\n                        //System.out.println(\"Using the y quadratic\");\n                        // x = (-2J - Iy)/H\n                        \n                        // Plug into the original equation:\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n                        // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n                        \n                        // Plug into derivative equation:\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n                        // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n                        // Multiply by H^2 to make manipulation easier\n                        // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n                        // Do the square\n                        // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n                        // Multiply it out\n                        // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n                        // Group:\n                        // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * E * I * J - 2.0 * G * H * J;\n                        c = 4.0 * E * J * J - J * H * H;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-2.0 * J - I * y0) / H;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / H;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n                                double x0a = (-2.0 * J - I * y0a) * Hdenom;\n                                double x0b = (-2.0 * J - I * y0b) * Hdenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n\n                    } else {\n                        //System.out.println(\"Using the x quadratic\");\n                        // y = (-2J - Hx)/I\n                        \n                        // Plug into the original equation:\n                        // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n                        // Multiply by I^2 to make manipulation easier\n                        // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n                        // Do the square\n                        // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n                        // Multiply it out\n                        // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n                        // Group:\n                        // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * F * H * J - 2.0 * G * I * J;\n                        c = 4.0 * F * J * J - J * I * I;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (-2.0 * J - H * x0) / I;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / I;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (-2.0 * J - H * x0a) * Idenom;\n                                double y0b = (-2.0 * J - H * x0b) * Idenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n","sourceOld":"    /** Accumulate bounds information for this plane, intersected with the unit sphere.\n    * Updates both latitude and longitude information, using max/min points found\n    * within the specified bounds.\n    *@param boundsInfo is the info to update with additional bounding information.\n    *@param bounds are the surfaces delineating what's inside the shape.\n    */\n    public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n        // For clarity, load local variables with good names\n        double A = this.x;\n        double B = this.y;\n        double C = this.z;\n\n        // Now compute latitude min/max points\n        if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n            if ((Math.abs(A) >= 1e-10 || Math.abs(B) >= 1e-10)) {\n                //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n                // sin (phi) = z\n                // cos (theta - phi) = D\n                // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n                // Q: what is z?\n                //\n                // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n                if (Math.abs(C) < 1.0e-10) {\n                    // Special case: circle is vertical.\n                    //System.out.println(\"Degenerate case; it's vertical circle\");\n                    // cos(phi) = D, and we want sin(phi) = z\n                    // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n                    // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n                    \n                    double z;\n                    double x;\n                    double y;\n\n                    double denom = 1.0 / (A*A + B*B);\n\n                    z = Math.sqrt(1.0 - D*D);\n                    y = -B * D * denom;\n                    x = -A * D * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                    z = -z;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                } else {\n                    // We might be able to identify a specific new latitude maximum or minimum.\n                    //\n                    // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n                    //\n                    // This is tricky.  If cos(phi) = something, and we want to figure out\n                    // what sin(phi) is, in order to capture all solutions we need to recognize\n                    // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n                    // whatever solution we find we have to mirror it across the x-y plane,\n                    // and include both +z and -z solutions.\n                    //\n                    // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n                    // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n                    //\n                    // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n                    // Substitute:\n                    // D = sqrt(1-C^2) * sqrt(1-z^2) + C * z\n                    // Solve for z...\n                    // D-Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n                    // Square both sides.\n                    // (D-Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz  = 1 - C^2 - z^2\n                    // 0 = z^2 - 2DCz + (C^2 +D^2-1) = 0\n                    //\n                    // z = (2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n                    // z  = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n                    //    = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n\n                    double z;\n                    double x;\n                    double y;\n                    \n                    double sqrtValue = D*D*C*C + 1.0 - C*C - D*D;\n                    if (sqrtValue >= 0.0) {\n                        // y = -B[D+Cz] / [A^2 + B^2]\n                        // x = -A[D+Cz] / [A^2 + B^2]\n                        double denom = 1.0 / (A*A + B*B);\n                        if (sqrtValue == 0.0) {\n                            //System.out.println(\"Zero sqrt term\");\n                            z = D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        } else {\n                            double sqrtResult = Math.sqrt(sqrtValue);\n                            z = D*C + sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = D*C - sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C + sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C - sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Horizontal circle.\n                // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n                // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n                // to check Membership objects.\n                boundsInfo.addHorizontalCircle(-D * C);\n            }\n        }\n        \n        // First, figure out our longitude bounds, unless we no longer need to consider that\n        if (!boundsInfo.checkNoLongitudeBound()) {\n            \n            //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n            // Compute longitude bounds\n            \n            double a;\n            double b;\n            double c;\n            \n            if (Math.abs(C) < 1e-10) {\n                // Degenerate; the equation describes a line\n                //System.out.println(\"It's a zero-width ellipse\");\n                // Ax + By + D = 0\n                if (Math.abs(D) >= 1e-10) {\n                    if (Math.abs(A) > Math.abs(B)) {\n                        // Use equation suitable for A != 0\n                        // We need to find the endpoints of the zero-width ellipse.\n                        // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n                        // of that line.  But luckily, we know some things: specifically, since it is a\n                        // degenerate situation in projection, the C value had to have been 0.  That\n                        // means that our line's endpoints will coincide with the unit circle.  All we\n                        // need to do then is to find the intersection of the unit circle and the line\n                        // equation:\n                        //\n                        // A x + B y + D = 0\n                        // \n                        // Since A != 0:\n                        // x = (-By - D)/A\n                        // \n                        // The unit circle:\n                        // x^2 + y^2 - 1 = 0\n                        // Substitute:\n                        // [(-By-D)/A]^2 + y^2 -1 = 0\n                        // Multiply through by A^2:\n                        // [-By - D]^2 + A^2*y^2 - A^2 = 0\n                        // Multiply out:\n                        // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n                        // Group:\n                        // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n                        \n                        a = B * B + A * A;\n                        b = 2.0 * B * D;\n                        c = D * D - A * A;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n                            \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-D - B * y0) / A;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / A;\n                                \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n\n                                double x0a = (-D - B * y0a) * Hdenom;\n                                double x0b = (-D - B * y0b) * Hdenom;\n                                \n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n\n                    } else {\n                        // Use equation suitable for B != 0\n                        // Since I != 0, we rewrite:\n                        // y = (-Ax - D)/B\n                        a = B * B + A * A;\n                        b = 2.0 * A * D;\n                        c = D * D - B * B;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n\n                        if (sqrtClause >= 0.0) {\n\n                            if (sqrtClause == 0.0) {\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (- D - A * x0) / B;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / B;\n                                \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (- D - A * x0a) * Idenom;\n                                double y0b = (- D - A * x0b) * Idenom;\n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n                \n            } else {\n\n                // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n                // From plane:\n                // z = (-Ax - By - D) / C\n                // From unit sphere:\n                // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n                // Simplify/expand:\n                // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n                // \n                // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n                // Group:\n                // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n                // For convenience, introduce post-projection coefficient variables to make life easier.\n                // E x^2 + F y^2 + G xy + H x + I y + J = 0\n                double E = A * A + C * C;\n                double F = B * B + C * C;\n                double G = 2.0 * A * B;\n                double H = 2.0 * A * D;\n                double I = 2.0 * B * D;\n                double J = D * D - C * C;\n\n                //System.out.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n                \n                // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n                if (J > 0.0) {\n                    // The derivative of the curve above is:\n                    // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n                    // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n                    // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n                    //\n                    // The equation of a line going through the origin with the slope dy/dx is:\n                    // y = dy/dx x\n                    // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n                    // Rearrange:\n                    // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n                    // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n                    // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                    //\n                    // Multiply the original equation by 2:\n                    // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n                    // Subtract one from the other, to remove the high-order terms:\n                    // Hx + Iy + 2J = 0\n                    // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n                    // But we will need to base this on which coefficient is non-zero\n                    \n                    if (Math.abs(H) > Math.abs(I)) {\n                        //System.out.println(\"Using the y quadratic\");\n                        // x = (-2J - Iy)/H\n                        \n                        // Plug into the original equation:\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n                        // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n                        \n                        // Plug into derivative equation:\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n                        // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n                        // Multiply by H^2 to make manipulation easier\n                        // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n                        // Do the square\n                        // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n                        // Multiply it out\n                        // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n                        // Group:\n                        // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * E * I * J - 2.0 * G * H * J;\n                        c = 4.0 * E * J * J - J * H * H;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-2.0 * J - I * y0) / H;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / H;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n                                double x0a = (-2.0 * J - I * y0a) * Hdenom;\n                                double x0b = (-2.0 * J - I * y0b) * Hdenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }                        \n\n                    } else {\n                        //System.out.println(\"Using the x quadratic\");\n                        // y = (-2J - Hx)/I\n                        \n                        // Plug into the original equation:\n                        // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n                        // Multiply by I^2 to make manipulation easier\n                        // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n                        // Do the square\n                        // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n                        // Multiply it out\n                        // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n                        // Group:\n                        // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * F * H * J - 2.0 * G * I * J;\n                        c = 4.0 * F * J * J - J * I * I;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            \n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (-2.0 * J - H * x0) / I;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / I;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (-2.0 * J - H * x0a) * Idenom;\n                                double y0b = (-2.0 * J - H * x0b) * Idenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4762743d2f10f32ae47dc222ef92e0807ffe2ab8","date":1429841956,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","sourceNew":"    /** Accumulate bounds information for this plane, intersected with the unit sphere.\n    * Updates both latitude and longitude information, using max/min points found\n    * within the specified bounds.\n    *@param boundsInfo is the info to update with additional bounding information.\n    *@param bounds are the surfaces delineating what's inside the shape.\n    */\n    public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n        // For clarity, load local variables with good names\n        final double A = this.x;\n        final double B = this.y;\n        final double C = this.z;\n\n        // Now compute latitude min/max points\n        if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n            //System.err.println(\"Looking at latitude for plane \"+this);\n            if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n                //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n                // sin (phi) = z\n                // cos (theta - phi) = D\n                // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n                // Q: what is z?\n                //\n                // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n                if (Math.abs(C) < MINIMUM_RESOLUTION) {\n                    // Special case: circle is vertical.\n                    //System.err.println(\" Degenerate case; it's vertical circle\");\n                    // cos(phi) = D, and we want sin(phi) = z\n                    // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n                    // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n                    \n                    double z;\n                    double x;\n                    double y;\n\n                    final double denom = 1.0 / (A*A + B*B);\n\n                    z = Math.sqrt(1.0 - D*D);\n                    y = -B * D * denom;\n                    x = -A * D * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                    z = -z;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                } else if (Math.abs(D) < MINIMUM_RESOLUTION) {\n                    //System.err.println(\" Plane through origin case\");\n                    // The general case is degenerate when the plane goes through the origin.\n                    // Luckily there's a pretty good way to figure out the max and min for that case though.\n                    // We find the two z values by computing the angle of the plane's inclination with the normal.\n                    // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.\n                    // Also if this.z == -1, then z value is 0 again.\n                    // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).\n                    //\n                    // The only tricky part is computing x and y.\n                    double z;\n                    double x;\n                    double y;\n                    \n                    final double denom = 1.0 / (A*A + B*B);\n                    \n                    z = Math.sqrt((A * A + B * B)/(A*A+B*B+C*C));\n                    y = -B * (C*z) * denom;\n                    x = -A * (C*z) * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                    \n                    z = -z;\n                    y = -B * (C*z) * denom;\n                    x = -A * (C*z) * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                } else {\n                    //System.err.println(\" General latitude case\");\n                    // We might be able to identify a specific new latitude maximum or minimum.\n                    //\n                    // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n                    //\n                    // This is tricky.  If cos(phi) = something, and we want to figure out\n                    // what sin(phi) is, in order to capture all solutions we need to recognize\n                    // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n                    // whatever solution we find we have to mirror it across the x-y plane,\n                    // and include both +z and -z solutions.\n                    //\n                    // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n                    // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n                    //\n                    // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n                    // Substitute:\n                    // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z\n                    // Solve for z...\n                    // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n                    // Square both sides.\n                    // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 +/- 2DCz  = 1 - C^2 - z^2\n                    // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0\n                    //\n                    // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n                    // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n                    //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n                    //\n                    // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to\n                    // code a different solution for that case!\n                    \n                    // To get x and y, we need to plug z into the equations, as follows:\n                    //\n                    // Ax + By = -Cz - D\n                    // x^2 + y^2 = 1 - z^2\n                    //\n                    // x = (-Cz -D -By) /A\n                    // y = (-Cz -D -Ax) /B\n                    //\n                    // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2\n                    // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2\n                    // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0\n                    // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0\n                    //\n                    // \n                    // Use quadratic formula, where:\n                    // a = [A^2 + B^2]\n                    // b = [2BD + 2CBz]\n                    // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]\n                    //\n                    // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])\n                    // Take out a 2:\n                    // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]\n                    //\n                    // The sqrt term simplifies:\n                    //\n                    // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?\n                    // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n                    //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n                    // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n                    //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n                    // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n                    //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n                    // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n                    //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?\n                    // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2\n                    //                  - B^2 + B^2 * z^2] =?\n                    // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?\n                    // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?\n                    //\n                    // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n                    //\n                    // correspondingly:\n                    // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n                    //\n                    // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If\n                    // it is NOT zero, then we aren't looking at the right z value.\n                    \n                    double z;\n                    double x;\n                    double y;\n                    \n                    double sqrtValue = D*D*C*C + 1.0 - C*C - D*D;\n                    double denom = 1.0 / (A*A + B*B);\n                    if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {\n                        //System.err.println(\" One latitude solution\");\n                        double insideValue;\n                        double sqrtTerm;\n                            \n                        z = D*C;\n                        // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                        // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                        // Check the solution on the other side of the x-y plane\n                        z = -z;\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    } else if (sqrtValue > 0.0) {\n                        //System.err.println(\" Two latitude solutions\");\n                        double sqrtResult = Math.sqrt(sqrtValue);\n                            \n                        double insideValue;\n                        double sqrtTerm;\n                            \n                        z = D*C + sqrtResult;\n                        //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                        // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                        // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                        // Check the solution on the other side of the x-y plane\n                        z = -z;\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                        z = D*C - sqrtResult;\n                        //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                        // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                        // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                        // Check the solution on the other side of the x-y plane\n                        z = -z;\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Horizontal circle.\n                // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n                // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n                // to check Membership objects.\n                boundsInfo.addHorizontalCircle(-D * C);\n            }\n            //System.err.println(\"Done latitude bounds\");\n        }\n        \n        // First, figure out our longitude bounds, unless we no longer need to consider that\n        if (!boundsInfo.checkNoLongitudeBound()) {\n            //System.err.println(\"Computing longitude bounds for \"+this);\n            //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n            // Compute longitude bounds\n            \n            double a;\n            double b;\n            double c;\n            \n            if (Math.abs(C) < MINIMUM_RESOLUTION) {\n                // Degenerate; the equation describes a line\n                //System.out.println(\"It's a zero-width ellipse\");\n                // Ax + By + D = 0\n                if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n                    if (Math.abs(A) > Math.abs(B)) {\n                        // Use equation suitable for A != 0\n                        // We need to find the endpoints of the zero-width ellipse.\n                        // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n                        // of that line.  But luckily, we know some things: specifically, since it is a\n                        // degenerate situation in projection, the C value had to have been 0.  That\n                        // means that our line's endpoints will coincide with the unit circle.  All we\n                        // need to do then is to find the intersection of the unit circle and the line\n                        // equation:\n                        //\n                        // A x + B y + D = 0\n                        // \n                        // Since A != 0:\n                        // x = (-By - D)/A\n                        // \n                        // The unit circle:\n                        // x^2 + y^2 - 1 = 0\n                        // Substitute:\n                        // [(-By-D)/A]^2 + y^2 -1 = 0\n                        // Multiply through by A^2:\n                        // [-By - D]^2 + A^2*y^2 - A^2 = 0\n                        // Multiply out:\n                        // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n                        // Group:\n                        // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n                        \n                        a = B * B + A * A;\n                        b = 2.0 * B * D;\n                        c = D * D - A * A;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n                            \n                        if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n                            double y0 = -b / (2.0 * a);\n                            double x0 = (-D - B * y0) / A;\n                            double z0 = 0.0;\n                            addPoint(boundsInfo, bounds, x0, y0, z0);\n                        } else if (sqrtClause > 0.0) {\n                            double sqrtResult = Math.sqrt(sqrtClause);\n                            double denom = 1.0 / (2.0 * a);\n                            double Hdenom = 1.0 / A;\n                                \n                            double y0a = (-b + sqrtResult ) * denom;\n                            double y0b = (-b - sqrtResult ) * denom;\n\n                            double x0a = (-D - B * y0a) * Hdenom;\n                            double x0b = (-D - B * y0b) * Hdenom;\n                                \n                            double z0a = 0.0;\n                            double z0b = 0.0;\n\n                            addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                            addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                        }\n\n                    } else {\n                        // Use equation suitable for B != 0\n                        // Since I != 0, we rewrite:\n                        // y = (-Ax - D)/B\n                        a = B * B + A * A;\n                        b = 2.0 * A * D;\n                        c = D * D - B * B;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n\n                        if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n                            double x0 = -b / (2.0 * a);\n                            double y0 = (- D - A * x0) / B;\n                            double z0 = 0.0;\n                            addPoint(boundsInfo, bounds, x0, y0, z0);\n                        } else if (sqrtClause > 0.0) {\n                            double sqrtResult = Math.sqrt(sqrtClause);\n                            double denom = 1.0 / (2.0 * a);\n                            double Idenom = 1.0 / B;\n                                \n                            double x0a = (-b + sqrtResult ) * denom;\n                            double x0b = (-b - sqrtResult ) * denom;\n                            double y0a = (- D - A * x0a) * Idenom;\n                            double y0b = (- D - A * x0b) * Idenom;\n                            double z0a = 0.0;\n                            double z0b = 0.0;\n\n                            addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                            addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                        }\n                    }\n                }\n                \n            } else {\n                //System.err.println(\"General longitude bounds...\");\n                \n                // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n                // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n                // and z for latitude, and that's all the values are good for.\n                \n                // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n                // From plane:\n                // z = (-Ax - By - D) / C\n                // From unit sphere:\n                // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n                // Simplify/expand:\n                // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n                // \n                // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n                // Group:\n                // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n                // For convenience, introduce post-projection coefficient variables to make life easier.\n                // E x^2 + F y^2 + G xy + H x + I y + J = 0\n                double E = A * A + C * C;\n                double F = B * B + C * C;\n                double G = 2.0 * A * B;\n                double H = 2.0 * A * D;\n                double I = 2.0 * B * D;\n                double J = D * D - C * C;\n\n                //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n                \n                double trialX = 2.0;\n                double trialY = 2.0;\n                \n                //System.err.println(\"Trial point evaluates to: \"+(E*trialX*trialX + F*trialY*trialY + G*trialX*trialY + H*trialX + I*trialY + J));\n                \n                // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n                if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n                    // The derivative of the curve above is:\n                    // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n                    // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n                    // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n                    //\n                    // The equation of a line going through the origin with the slope dy/dx is:\n                    // y = dy/dx x\n                    // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n                    // Rearrange:\n                    // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n                    // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n                    // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                    //\n                    // Multiply the original equation by 2:\n                    // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n                    // Subtract one from the other, to remove the high-order terms:\n                    // Hx + Iy + 2J = 0\n                    // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n                    // But we will need to base this on which coefficient is non-zero\n                    \n                    if (Math.abs(H) > Math.abs(I)) {\n                        //System.err.println(\" Using the y quadratic\");\n                        // x = (-2J - Iy)/H\n                        \n                        // Plug into the original equation:\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n                        // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n                        \n                        // Plug into derivative equation:\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n                        // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n                        // Multiply by H^2 to make manipulation easier\n                        // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n                        // Do the square\n                        // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n                        // Multiply it out\n                        // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n                        // Group:\n                        // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * E * I * J - 2.0 * G * H * J;\n                        c = 4.0 * E * J * J - J * H * H;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n                            //System.err.println(\" One solution\");\n                            double y0 = -b / (2.0 * a);\n                            double x0 = (-2.0 * J - I * y0) / H;\n                            double z0 = (-A*x0 - B*y0 - D)/C;\n\n                            addPoint(boundsInfo, bounds, x0, y0, z0);\n                        } else if (sqrtClause > 0.0) {\n                            //System.err.println(\" Two solutions\");\n                            double sqrtResult = Math.sqrt(sqrtClause);\n                            double denom = 1.0 / (2.0 * a);\n                            double Hdenom = 1.0 / H;\n                            double Cdenom = 1.0 / C;\n                                    \n                            double y0a = (-b + sqrtResult ) * denom;\n                            double y0b = (-b - sqrtResult ) * denom;\n                            double x0a = (-2.0 * J - I * y0a) * Hdenom;\n                            double x0b = (-2.0 * J - I * y0b) * Hdenom;\n                            double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                            double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                            addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                            addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                        }\n\n                    } else {\n                        //System.err.println(\" Using the x quadratic\");\n                        // y = (-2J - Hx)/I\n                        \n                        // Plug into the original equation:\n                        // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n                        // Multiply by I^2 to make manipulation easier\n                        // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n                        // Do the square\n                        // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n                        // Multiply it out\n                        // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n                        // Group:\n                        // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n                        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * F * H * J - 2.0 * G * I * J;\n                        c = 4.0 * F * J * J - J * I * I;\n\n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n                            //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n                            double x0 = -b / (2.0 * a);\n                            double y0 = (-2.0 * J - H * x0) / I;\n                            double z0 = (-A*x0 - B*y0 - D)/C;\n                            // Verify that x&y fulfill the equation\n                            // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                            addPoint(boundsInfo, bounds, x0, y0, z0);\n                        } else if (sqrtClause > 0.0) {\n                            //System.err.println(\" Two solutions\");\n                            double sqrtResult = Math.sqrt(sqrtClause);\n                            double denom = 1.0 / (2.0 * a);\n                            double Idenom = 1.0 / I;\n                            double Cdenom = 1.0 / C;\n                                    \n                            double x0a = (-b + sqrtResult ) * denom;\n                            double x0b = (-b - sqrtResult ) * denom;\n                            double y0a = (-2.0 * J - H * x0a) * Idenom;\n                            double y0b = (-2.0 * J - H * x0b) * Idenom;\n                            double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                            double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                            addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                            addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n","sourceOld":"    /** Accumulate bounds information for this plane, intersected with the unit sphere.\n    * Updates both latitude and longitude information, using max/min points found\n    * within the specified bounds.\n    *@param boundsInfo is the info to update with additional bounding information.\n    *@param bounds are the surfaces delineating what's inside the shape.\n    */\n    public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n        // For clarity, load local variables with good names\n        double A = this.x;\n        double B = this.y;\n        double C = this.z;\n\n        // Now compute latitude min/max points\n        if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n            if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n                //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n                // sin (phi) = z\n                // cos (theta - phi) = D\n                // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n                // Q: what is z?\n                //\n                // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n                if (Math.abs(C) < 1.0e-10) {\n                    // Special case: circle is vertical.\n                    //System.out.println(\"Degenerate case; it's vertical circle\");\n                    // cos(phi) = D, and we want sin(phi) = z\n                    // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n                    // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n                    \n                    double z;\n                    double x;\n                    double y;\n\n                    double denom = 1.0 / (A*A + B*B);\n\n                    z = Math.sqrt(1.0 - D*D);\n                    y = -B * D * denom;\n                    x = -A * D * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                    z = -z;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                } else {\n                    // We might be able to identify a specific new latitude maximum or minimum.\n                    //\n                    // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n                    //\n                    // This is tricky.  If cos(phi) = something, and we want to figure out\n                    // what sin(phi) is, in order to capture all solutions we need to recognize\n                    // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n                    // whatever solution we find we have to mirror it across the x-y plane,\n                    // and include both +z and -z solutions.\n                    //\n                    // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n                    // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n                    //\n                    // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n                    // Substitute:\n                    // D = sqrt(1-C^2) * sqrt(1-z^2) + C * z\n                    // Solve for z...\n                    // D-Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n                    // Square both sides.\n                    // (D-Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 - 2DCz  = 1 - C^2 - z^2\n                    // 0 = z^2 - 2DCz + (C^2 +D^2-1) = 0\n                    //\n                    // z = (2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n                    // z  = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n                    //    = DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n\n                    double z;\n                    double x;\n                    double y;\n                    \n                    double sqrtValue = D*D*C*C + 1.0 - C*C - D*D;\n                    if (sqrtValue >= 0.0) {\n                        // y = -B[D+Cz] / [A^2 + B^2]\n                        // x = -A[D+Cz] / [A^2 + B^2]\n                        double denom = 1.0 / (A*A + B*B);\n                        if (sqrtValue == 0.0) {\n                            //System.out.println(\"Zero sqrt term\");\n                            z = D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -D*C;\n                            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        } else {\n                            double sqrtResult = Math.sqrt(sqrtValue);\n                            z = D*C + sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = D*C - sqrtResult;\n                            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D-C*z - Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C + sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1.0 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z = \"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                            z = -(D*C - sqrtResult);\n                            //System.out.println(\"z= \"+z+\" D+C*z = \" + (D+C*z) + \" -Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(-Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                            if (Math.abs(D+C*z + Math.sqrt(1 - z*z - C*C + z*z*C*C)) < 1.0e-10) {\n                                //System.out.println(\"found a point; z=\"+z);\n                                y = -B * (D + C*z) * denom;\n                                x = -A * (D + C*z) * denom;\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Horizontal circle.\n                // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n                // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n                // to check Membership objects.\n                boundsInfo.addHorizontalCircle(-D * C);\n            }\n        }\n        \n        // First, figure out our longitude bounds, unless we no longer need to consider that\n        if (!boundsInfo.checkNoLongitudeBound()) {\n            \n            //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n            // Compute longitude bounds\n            \n            double a;\n            double b;\n            double c;\n            \n            if (Math.abs(C) < MINIMUM_RESOLUTION) {\n                // Degenerate; the equation describes a line\n                //System.out.println(\"It's a zero-width ellipse\");\n                // Ax + By + D = 0\n                if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n                    if (Math.abs(A) > Math.abs(B)) {\n                        // Use equation suitable for A != 0\n                        // We need to find the endpoints of the zero-width ellipse.\n                        // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n                        // of that line.  But luckily, we know some things: specifically, since it is a\n                        // degenerate situation in projection, the C value had to have been 0.  That\n                        // means that our line's endpoints will coincide with the unit circle.  All we\n                        // need to do then is to find the intersection of the unit circle and the line\n                        // equation:\n                        //\n                        // A x + B y + D = 0\n                        // \n                        // Since A != 0:\n                        // x = (-By - D)/A\n                        // \n                        // The unit circle:\n                        // x^2 + y^2 - 1 = 0\n                        // Substitute:\n                        // [(-By-D)/A]^2 + y^2 -1 = 0\n                        // Multiply through by A^2:\n                        // [-By - D]^2 + A^2*y^2 - A^2 = 0\n                        // Multiply out:\n                        // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n                        // Group:\n                        // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n                        \n                        a = B * B + A * A;\n                        b = 2.0 * B * D;\n                        c = D * D - A * A;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n                            \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-D - B * y0) / A;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / A;\n                                \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n\n                                double x0a = (-D - B * y0a) * Hdenom;\n                                double x0b = (-D - B * y0b) * Hdenom;\n                                \n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n\n                    } else {\n                        // Use equation suitable for B != 0\n                        // Since I != 0, we rewrite:\n                        // y = (-Ax - D)/B\n                        a = B * B + A * A;\n                        b = 2.0 * A * D;\n                        c = D * D - B * B;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n\n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (- D - A * x0) / B;\n                                double z0 = 0.0;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / B;\n                                \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (- D - A * x0a) * Idenom;\n                                double y0b = (- D - A * x0b) * Idenom;\n                                double z0a = 0.0;\n                                double z0b = 0.0;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n                \n            } else {\n\n                // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n                // From plane:\n                // z = (-Ax - By - D) / C\n                // From unit sphere:\n                // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n                // Simplify/expand:\n                // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n                // \n                // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n                // Group:\n                // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n                // For convenience, introduce post-projection coefficient variables to make life easier.\n                // E x^2 + F y^2 + G xy + H x + I y + J = 0\n                double E = A * A + C * C;\n                double F = B * B + C * C;\n                double G = 2.0 * A * B;\n                double H = 2.0 * A * D;\n                double I = 2.0 * B * D;\n                double J = D * D - C * C;\n\n                //System.out.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n                \n                // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n                if (J > 0.0) {\n                    // The derivative of the curve above is:\n                    // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n                    // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n                    // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n                    //\n                    // The equation of a line going through the origin with the slope dy/dx is:\n                    // y = dy/dx x\n                    // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n                    // Rearrange:\n                    // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n                    // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n                    // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                    //\n                    // Multiply the original equation by 2:\n                    // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n                    // Subtract one from the other, to remove the high-order terms:\n                    // Hx + Iy + 2J = 0\n                    // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n                    // But we will need to base this on which coefficient is non-zero\n                    \n                    if (Math.abs(H) > Math.abs(I)) {\n                        //System.out.println(\"Using the y quadratic\");\n                        // x = (-2J - Iy)/H\n                        \n                        // Plug into the original equation:\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n                        // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n                        \n                        // Plug into derivative equation:\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n                        // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n                        // Multiply by H^2 to make manipulation easier\n                        // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n                        // Do the square\n                        // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n                        // Multiply it out\n                        // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n                        // Group:\n                        // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * E * I * J - 2.0 * G * H * J;\n                        c = 4.0 * E * J * J - J * H * H;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double y0 = -b / (2.0 * a);\n                                double x0 = (-2.0 * J - I * y0) / H;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Hdenom = 1.0 / H;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double y0a = (-b + sqrtResult ) * denom;\n                                double y0b = (-b - sqrtResult ) * denom;\n                                double x0a = (-2.0 * J - I * y0a) * Hdenom;\n                                double x0b = (-2.0 * J - I * y0b) * Hdenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n\n                    } else {\n                        //System.out.println(\"Using the x quadratic\");\n                        // y = (-2J - Hx)/I\n                        \n                        // Plug into the original equation:\n                        // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n                        // Multiply by I^2 to make manipulation easier\n                        // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n                        // Do the square\n                        // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n                        // Multiply it out\n                        // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n                        // Group:\n                        // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * F * H * J - 2.0 * G * I * J;\n                        c = 4.0 * F * J * J - J * I * I;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (sqrtClause >= 0.0) {\n                            if (sqrtClause == 0.0) {\n                                //System.out.println(\"One solution\");\n                                double x0 = -b / (2.0 * a);\n                                double y0 = (-2.0 * J - H * x0) / I;\n                                double z0 = (-A*x0 - B*y0 - D)/C;\n                                addPoint(boundsInfo, bounds, x0, y0, z0);\n                            } else {\n                                //System.out.println(\"Two solutions\");\n                                double sqrtResult = Math.sqrt(sqrtClause);\n                                double denom = 1.0 / (2.0 * a);\n                                double Idenom = 1.0 / I;\n                                double Cdenom = 1.0 / C;\n                                    \n                                double x0a = (-b + sqrtResult ) * denom;\n                                double x0b = (-b - sqrtResult ) * denom;\n                                double y0a = (-2.0 * J - H * x0a) * Idenom;\n                                double y0b = (-2.0 * J - H * x0b) * Idenom;\n                                double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                                double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                                addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                                addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2997acf74723385bd84aff1ea0b12af4aefde77","date":1430745542,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n        // sin (phi) = z\n        // cos (theta - phi) = D\n        // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n        // Q: what is z?\n        //\n        // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n        if (Math.abs(C) < MINIMUM_RESOLUTION) {\n          // Special case: circle is vertical.\n          //System.err.println(\" Degenerate case; it's vertical circle\");\n          // cos(phi) = D, and we want sin(phi) = z\n          // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n          // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt(1.0 - D * D);\n          y = -B * D * denom;\n          x = -A * D * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          addPoint(boundsInfo, bounds, x, y, z);\n        } else if (Math.abs(D) < MINIMUM_RESOLUTION) {\n          //System.err.println(\" Plane through origin case\");\n          // The general case is degenerate when the plane goes through the origin.\n          // Luckily there's a pretty good way to figure out the max and min for that case though.\n          // We find the two z values by computing the angle of the plane's inclination with the normal.\n          // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.\n          // Also if this.z == -1, then z value is 0 again.\n          // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).\n          //\n          // The only tricky part is computing x and y.\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt((A * A + B * B) / (A * A + B * B + C * C));\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n        } else {\n          //System.err.println(\" General latitude case\");\n          // We might be able to identify a specific new latitude maximum or minimum.\n          //\n          // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n          //\n          // This is tricky.  If cos(phi) = something, and we want to figure out\n          // what sin(phi) is, in order to capture all solutions we need to recognize\n          // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n          // whatever solution we find we have to mirror it across the x-y plane,\n          // and include both +z and -z solutions.\n          //\n          // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n          // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n          //\n          // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n          // Substitute:\n          // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z\n          // Solve for z...\n          // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n          // Square both sides.\n          // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz  = 1 - C^2 - z^2\n          // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0\n          //\n          // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n          // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n          //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n          //\n          // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to\n          // code a different solution for that case!\n\n          // To get x and y, we need to plug z into the equations, as follows:\n          //\n          // Ax + By = -Cz - D\n          // x^2 + y^2 = 1 - z^2\n          //\n          // x = (-Cz -D -By) /A\n          // y = (-Cz -D -Ax) /B\n          //\n          // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2\n          // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2\n          // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0\n          // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0\n          //\n          //\n          // Use quadratic formula, where:\n          // a = [A^2 + B^2]\n          // b = [2BD + 2CBz]\n          // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]\n          //\n          // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])\n          // Take out a 2:\n          // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]\n          //\n          // The sqrt term simplifies:\n          //\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2\n          //                  - B^2 + B^2 * z^2] =?\n          // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?\n          // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?\n          //\n          // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // correspondingly:\n          // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If\n          // it is NOT zero, then we aren't looking at the right z value.\n\n          double z;\n          double x;\n          double y;\n\n          double sqrtValue = D * D * C * C + 1.0 - C * C - D * D;\n          double denom = 1.0 / (A * A + B * B);\n          if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {\n            //System.err.println(\" One latitude solution\");\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C;\n            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          } else if (sqrtValue > 0.0) {\n            //System.err.println(\" Two latitude solutions\");\n            double sqrtResult = Math.sqrt(sqrtValue);\n\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C + sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            z = D * C - sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          }\n        }\n      } else {\n        // Horizontal circle.\n        // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n        // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n        // to check Membership objects.\n        boundsInfo.addHorizontalCircle(-D * C);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the unit circle.  All we\n            // need to do then is to find the intersection of the unit circle and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The unit circle:\n            // x^2 + y^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2 + y^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2 + A^2*y^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n\n            a = B * B + A * A;\n            b = 2.0 * B * D;\n            c = D * D - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B + A * A;\n            b = 2.0 * A * D;\n            c = D * D - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From unit sphere:\n        // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n        // Simplify/expand:\n        // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n        //\n        // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n        // Group:\n        // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A + C * C;\n        double F = B * B + C * C;\n        double G = 2.0 * A * B;\n        double H = 2.0 * A * D;\n        double I = 2.0 * B * D;\n        double J = D * D - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        double trialX = 2.0;\n        double trialY = 2.0;\n\n        //System.err.println(\"Trial point evaluates to: \"+(E*trialX*trialX + F*trialY*trialY + G*trialX*trialY + H*trialX + I*trialY + J));\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"    /** Accumulate bounds information for this plane, intersected with the unit sphere.\n    * Updates both latitude and longitude information, using max/min points found\n    * within the specified bounds.\n    *@param boundsInfo is the info to update with additional bounding information.\n    *@param bounds are the surfaces delineating what's inside the shape.\n    */\n    public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n        // For clarity, load local variables with good names\n        final double A = this.x;\n        final double B = this.y;\n        final double C = this.z;\n\n        // Now compute latitude min/max points\n        if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n            //System.err.println(\"Looking at latitude for plane \"+this);\n            if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n                //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n                // sin (phi) = z\n                // cos (theta - phi) = D\n                // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n                // Q: what is z?\n                //\n                // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n                if (Math.abs(C) < MINIMUM_RESOLUTION) {\n                    // Special case: circle is vertical.\n                    //System.err.println(\" Degenerate case; it's vertical circle\");\n                    // cos(phi) = D, and we want sin(phi) = z\n                    // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n                    // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n                    \n                    double z;\n                    double x;\n                    double y;\n\n                    final double denom = 1.0 / (A*A + B*B);\n\n                    z = Math.sqrt(1.0 - D*D);\n                    y = -B * D * denom;\n                    x = -A * D * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                    z = -z;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                } else if (Math.abs(D) < MINIMUM_RESOLUTION) {\n                    //System.err.println(\" Plane through origin case\");\n                    // The general case is degenerate when the plane goes through the origin.\n                    // Luckily there's a pretty good way to figure out the max and min for that case though.\n                    // We find the two z values by computing the angle of the plane's inclination with the normal.\n                    // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.\n                    // Also if this.z == -1, then z value is 0 again.\n                    // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).\n                    //\n                    // The only tricky part is computing x and y.\n                    double z;\n                    double x;\n                    double y;\n                    \n                    final double denom = 1.0 / (A*A + B*B);\n                    \n                    z = Math.sqrt((A * A + B * B)/(A*A+B*B+C*C));\n                    y = -B * (C*z) * denom;\n                    x = -A * (C*z) * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n                    \n                    z = -z;\n                    y = -B * (C*z) * denom;\n                    x = -A * (C*z) * denom;\n                    addPoint(boundsInfo, bounds, x, y, z);\n\n                } else {\n                    //System.err.println(\" General latitude case\");\n                    // We might be able to identify a specific new latitude maximum or minimum.\n                    //\n                    // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n                    //\n                    // This is tricky.  If cos(phi) = something, and we want to figure out\n                    // what sin(phi) is, in order to capture all solutions we need to recognize\n                    // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n                    // whatever solution we find we have to mirror it across the x-y plane,\n                    // and include both +z and -z solutions.\n                    //\n                    // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n                    // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n                    //\n                    // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n                    // Substitute:\n                    // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z\n                    // Solve for z...\n                    // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n                    // Square both sides.\n                    // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n                    // D^2 +/- 2DCz  = 1 - C^2 - z^2\n                    // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0\n                    //\n                    // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n                    // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n                    //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n                    //\n                    // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to\n                    // code a different solution for that case!\n                    \n                    // To get x and y, we need to plug z into the equations, as follows:\n                    //\n                    // Ax + By = -Cz - D\n                    // x^2 + y^2 = 1 - z^2\n                    //\n                    // x = (-Cz -D -By) /A\n                    // y = (-Cz -D -Ax) /B\n                    //\n                    // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2\n                    // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2\n                    // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0\n                    // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0\n                    //\n                    // \n                    // Use quadratic formula, where:\n                    // a = [A^2 + B^2]\n                    // b = [2BD + 2CBz]\n                    // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]\n                    //\n                    // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])\n                    // Take out a 2:\n                    // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]\n                    //\n                    // The sqrt term simplifies:\n                    //\n                    // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?\n                    // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n                    //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n                    // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n                    //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n                    // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n                    //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n                    // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n                    //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?\n                    // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2\n                    //                  - B^2 + B^2 * z^2] =?\n                    // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?\n                    // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?\n                    //\n                    // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n                    //\n                    // correspondingly:\n                    // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n                    //\n                    // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If\n                    // it is NOT zero, then we aren't looking at the right z value.\n                    \n                    double z;\n                    double x;\n                    double y;\n                    \n                    double sqrtValue = D*D*C*C + 1.0 - C*C - D*D;\n                    double denom = 1.0 / (A*A + B*B);\n                    if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {\n                        //System.err.println(\" One latitude solution\");\n                        double insideValue;\n                        double sqrtTerm;\n                            \n                        z = D*C;\n                        // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n                        // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                        // Check the solution on the other side of the x-y plane\n                        z = -z;\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    } else if (sqrtValue > 0.0) {\n                        //System.err.println(\" Two latitude solutions\");\n                        double sqrtResult = Math.sqrt(sqrtValue);\n                            \n                        double insideValue;\n                        double sqrtTerm;\n                            \n                        z = D*C + sqrtResult;\n                        //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                        // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                        // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                        // Check the solution on the other side of the x-y plane\n                        z = -z;\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                        z = D*C - sqrtResult;\n                        //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n                        // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n                        // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                        // Check the solution on the other side of the x-y plane\n                        z = -z;\n                        insideValue = A * A + B * B - D * D - z*z - 2.0 * C * D * z;\n                        //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n                        if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n                            y = -B * (D + C*z) * denom;\n                            x = -A * (D + C*z) * denom;\n                            if (evaluateIsZero(x,y,z)) {\n                                addPoint(boundsInfo, bounds, x, y, z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                // Horizontal circle.\n                // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n                // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n                // to check Membership objects.\n                boundsInfo.addHorizontalCircle(-D * C);\n            }\n            //System.err.println(\"Done latitude bounds\");\n        }\n        \n        // First, figure out our longitude bounds, unless we no longer need to consider that\n        if (!boundsInfo.checkNoLongitudeBound()) {\n            //System.err.println(\"Computing longitude bounds for \"+this);\n            //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n            // Compute longitude bounds\n            \n            double a;\n            double b;\n            double c;\n            \n            if (Math.abs(C) < MINIMUM_RESOLUTION) {\n                // Degenerate; the equation describes a line\n                //System.out.println(\"It's a zero-width ellipse\");\n                // Ax + By + D = 0\n                if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n                    if (Math.abs(A) > Math.abs(B)) {\n                        // Use equation suitable for A != 0\n                        // We need to find the endpoints of the zero-width ellipse.\n                        // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n                        // of that line.  But luckily, we know some things: specifically, since it is a\n                        // degenerate situation in projection, the C value had to have been 0.  That\n                        // means that our line's endpoints will coincide with the unit circle.  All we\n                        // need to do then is to find the intersection of the unit circle and the line\n                        // equation:\n                        //\n                        // A x + B y + D = 0\n                        // \n                        // Since A != 0:\n                        // x = (-By - D)/A\n                        // \n                        // The unit circle:\n                        // x^2 + y^2 - 1 = 0\n                        // Substitute:\n                        // [(-By-D)/A]^2 + y^2 -1 = 0\n                        // Multiply through by A^2:\n                        // [-By - D]^2 + A^2*y^2 - A^2 = 0\n                        // Multiply out:\n                        // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n                        // Group:\n                        // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n                        \n                        a = B * B + A * A;\n                        b = 2.0 * B * D;\n                        c = D * D - A * A;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n                            \n                        if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n                            double y0 = -b / (2.0 * a);\n                            double x0 = (-D - B * y0) / A;\n                            double z0 = 0.0;\n                            addPoint(boundsInfo, bounds, x0, y0, z0);\n                        } else if (sqrtClause > 0.0) {\n                            double sqrtResult = Math.sqrt(sqrtClause);\n                            double denom = 1.0 / (2.0 * a);\n                            double Hdenom = 1.0 / A;\n                                \n                            double y0a = (-b + sqrtResult ) * denom;\n                            double y0b = (-b - sqrtResult ) * denom;\n\n                            double x0a = (-D - B * y0a) * Hdenom;\n                            double x0b = (-D - B * y0b) * Hdenom;\n                                \n                            double z0a = 0.0;\n                            double z0b = 0.0;\n\n                            addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                            addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                        }\n\n                    } else {\n                        // Use equation suitable for B != 0\n                        // Since I != 0, we rewrite:\n                        // y = (-Ax - D)/B\n                        a = B * B + A * A;\n                        b = 2.0 * A * D;\n                        c = D * D - B * B;\n                        \n                        double sqrtClause = b * b - 4.0 * a * c;\n\n                        if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n                            double x0 = -b / (2.0 * a);\n                            double y0 = (- D - A * x0) / B;\n                            double z0 = 0.0;\n                            addPoint(boundsInfo, bounds, x0, y0, z0);\n                        } else if (sqrtClause > 0.0) {\n                            double sqrtResult = Math.sqrt(sqrtClause);\n                            double denom = 1.0 / (2.0 * a);\n                            double Idenom = 1.0 / B;\n                                \n                            double x0a = (-b + sqrtResult ) * denom;\n                            double x0b = (-b - sqrtResult ) * denom;\n                            double y0a = (- D - A * x0a) * Idenom;\n                            double y0b = (- D - A * x0b) * Idenom;\n                            double z0a = 0.0;\n                            double z0b = 0.0;\n\n                            addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                            addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                        }\n                    }\n                }\n                \n            } else {\n                //System.err.println(\"General longitude bounds...\");\n                \n                // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n                // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n                // and z for latitude, and that's all the values are good for.\n                \n                // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n                // From plane:\n                // z = (-Ax - By - D) / C\n                // From unit sphere:\n                // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n                // Simplify/expand:\n                // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n                // \n                // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n                // Group:\n                // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n                // For convenience, introduce post-projection coefficient variables to make life easier.\n                // E x^2 + F y^2 + G xy + H x + I y + J = 0\n                double E = A * A + C * C;\n                double F = B * B + C * C;\n                double G = 2.0 * A * B;\n                double H = 2.0 * A * D;\n                double I = 2.0 * B * D;\n                double J = D * D - C * C;\n\n                //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n                \n                double trialX = 2.0;\n                double trialY = 2.0;\n                \n                //System.err.println(\"Trial point evaluates to: \"+(E*trialX*trialX + F*trialY*trialY + G*trialX*trialY + H*trialX + I*trialY + J));\n                \n                // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n                if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n                    // The derivative of the curve above is:\n                    // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n                    // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n                    // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n                    //\n                    // The equation of a line going through the origin with the slope dy/dx is:\n                    // y = dy/dx x\n                    // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n                    // Rearrange:\n                    // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n                    // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n                    // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                    //\n                    // Multiply the original equation by 2:\n                    // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n                    // Subtract one from the other, to remove the high-order terms:\n                    // Hx + Iy + 2J = 0\n                    // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n                    // But we will need to base this on which coefficient is non-zero\n                    \n                    if (Math.abs(H) > Math.abs(I)) {\n                        //System.err.println(\" Using the y quadratic\");\n                        // x = (-2J - Iy)/H\n                        \n                        // Plug into the original equation:\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n                        // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n                        // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n                        \n                        // Plug into derivative equation:\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n                        // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n                        // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n                        // Multiply by H^2 to make manipulation easier\n                        // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n                        // Do the square\n                        // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n                        // Multiply it out\n                        // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n                        // Group:\n                        // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * E * I * J - 2.0 * G * H * J;\n                        c = 4.0 * E * J * J - J * H * H;\n                        \n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        \n                        if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n                            //System.err.println(\" One solution\");\n                            double y0 = -b / (2.0 * a);\n                            double x0 = (-2.0 * J - I * y0) / H;\n                            double z0 = (-A*x0 - B*y0 - D)/C;\n\n                            addPoint(boundsInfo, bounds, x0, y0, z0);\n                        } else if (sqrtClause > 0.0) {\n                            //System.err.println(\" Two solutions\");\n                            double sqrtResult = Math.sqrt(sqrtClause);\n                            double denom = 1.0 / (2.0 * a);\n                            double Hdenom = 1.0 / H;\n                            double Cdenom = 1.0 / C;\n                                    \n                            double y0a = (-b + sqrtResult ) * denom;\n                            double y0b = (-b - sqrtResult ) * denom;\n                            double x0a = (-2.0 * J - I * y0a) * Hdenom;\n                            double x0b = (-2.0 * J - I * y0b) * Hdenom;\n                            double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                            double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                            addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                            addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                        }\n\n                    } else {\n                        //System.err.println(\" Using the x quadratic\");\n                        // y = (-2J - Hx)/I\n                        \n                        // Plug into the original equation:\n                        // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n                        // Multiply by I^2 to make manipulation easier\n                        // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n                        // Do the square\n                        // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n                        // Multiply it out\n                        // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n                        // Group:\n                        // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n                        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n                        a = E * I * I - G * H * I + F*H*H;\n                        b = 4.0 * F * H * J - 2.0 * G * I * J;\n                        c = 4.0 * F * J * J - J * I * I;\n\n                        //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n                        double sqrtClause = b * b - 4.0 * a * c;\n                        //System.out.println(\"sqrtClause=\"+sqrtClause);\n                        if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n                            //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n                            double x0 = -b / (2.0 * a);\n                            double y0 = (-2.0 * J - H * x0) / I;\n                            double z0 = (-A*x0 - B*y0 - D)/C;\n                            // Verify that x&y fulfill the equation\n                            // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n                            addPoint(boundsInfo, bounds, x0, y0, z0);\n                        } else if (sqrtClause > 0.0) {\n                            //System.err.println(\" Two solutions\");\n                            double sqrtResult = Math.sqrt(sqrtClause);\n                            double denom = 1.0 / (2.0 * a);\n                            double Idenom = 1.0 / I;\n                            double Cdenom = 1.0 / C;\n                                    \n                            double x0a = (-b + sqrtResult ) * denom;\n                            double x0b = (-b - sqrtResult ) * denom;\n                            double y0a = (-2.0 * J - H * x0a) * Idenom;\n                            double y0b = (-2.0 * J - H * x0b) * Idenom;\n                            double z0a = (-A*x0a - B*y0a - D) * Cdenom;\n                            double z0b = (-A*x0b - B*y0b - D) * Cdenom;\n\n                            addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n                            addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n","bugFix":null,"bugIntro":["aafaf65c7159614a90c78005b3e21b3043b46024"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c921d81476f94b6686d3f216daa1f6b076b4a6c0","date":1430922284,"type":0,"author":"David Wayne Smiley","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n        // sin (phi) = z\n        // cos (theta - phi) = D\n        // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n        // Q: what is z?\n        //\n        // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n        if (Math.abs(C) < MINIMUM_RESOLUTION) {\n          // Special case: circle is vertical.\n          //System.err.println(\" Degenerate case; it's vertical circle\");\n          // cos(phi) = D, and we want sin(phi) = z\n          // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n          // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt(1.0 - D * D);\n          y = -B * D * denom;\n          x = -A * D * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          addPoint(boundsInfo, bounds, x, y, z);\n        } else if (Math.abs(D) < MINIMUM_RESOLUTION) {\n          //System.err.println(\" Plane through origin case\");\n          // The general case is degenerate when the plane goes through the origin.\n          // Luckily there's a pretty good way to figure out the max and min for that case though.\n          // We find the two z values by computing the angle of the plane's inclination with the normal.\n          // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.\n          // Also if this.z == -1, then z value is 0 again.\n          // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).\n          //\n          // The only tricky part is computing x and y.\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt((A * A + B * B) / (A * A + B * B + C * C));\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n        } else {\n          //System.err.println(\" General latitude case\");\n          // We might be able to identify a specific new latitude maximum or minimum.\n          //\n          // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n          //\n          // This is tricky.  If cos(phi) = something, and we want to figure out\n          // what sin(phi) is, in order to capture all solutions we need to recognize\n          // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n          // whatever solution we find we have to mirror it across the x-y plane,\n          // and include both +z and -z solutions.\n          //\n          // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n          // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n          //\n          // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n          // Substitute:\n          // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z\n          // Solve for z...\n          // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n          // Square both sides.\n          // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz  = 1 - C^2 - z^2\n          // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0\n          //\n          // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n          // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n          //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n          //\n          // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to\n          // code a different solution for that case!\n\n          // To get x and y, we need to plug z into the equations, as follows:\n          //\n          // Ax + By = -Cz - D\n          // x^2 + y^2 = 1 - z^2\n          //\n          // x = (-Cz -D -By) /A\n          // y = (-Cz -D -Ax) /B\n          //\n          // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2\n          // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2\n          // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0\n          // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0\n          //\n          //\n          // Use quadratic formula, where:\n          // a = [A^2 + B^2]\n          // b = [2BD + 2CBz]\n          // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]\n          //\n          // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])\n          // Take out a 2:\n          // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]\n          //\n          // The sqrt term simplifies:\n          //\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2\n          //                  - B^2 + B^2 * z^2] =?\n          // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?\n          // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?\n          //\n          // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // correspondingly:\n          // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If\n          // it is NOT zero, then we aren't looking at the right z value.\n\n          double z;\n          double x;\n          double y;\n\n          double sqrtValue = D * D * C * C + 1.0 - C * C - D * D;\n          double denom = 1.0 / (A * A + B * B);\n          if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {\n            //System.err.println(\" One latitude solution\");\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C;\n            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          } else if (sqrtValue > 0.0) {\n            //System.err.println(\" Two latitude solutions\");\n            double sqrtResult = Math.sqrt(sqrtValue);\n\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C + sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            z = D * C - sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          }\n        }\n      } else {\n        // Horizontal circle.\n        // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n        // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n        // to check Membership objects.\n        boundsInfo.addHorizontalCircle(-D * C);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the unit circle.  All we\n            // need to do then is to find the intersection of the unit circle and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The unit circle:\n            // x^2 + y^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2 + y^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2 + A^2*y^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n\n            a = B * B + A * A;\n            b = 2.0 * B * D;\n            c = D * D - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B + A * A;\n            b = 2.0 * A * D;\n            c = D * D - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From unit sphere:\n        // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n        // Simplify/expand:\n        // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n        //\n        // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n        // Group:\n        // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A + C * C;\n        double F = B * B + C * C;\n        double G = 2.0 * A * B;\n        double H = 2.0 * A * D;\n        double I = 2.0 * B * D;\n        double J = D * D - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        double trialX = 2.0;\n        double trialY = 2.0;\n\n        //System.err.println(\"Trial point evaluates to: \"+(E*trialX*trialX + F*trialY*trialY + G*trialX*trialY + H*trialX + I*trialY + J));\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aafaf65c7159614a90c78005b3e21b3043b46024","date":1431404499,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n        // sin (phi) = z\n        // cos (theta - phi) = D\n        // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n        // Q: what is z?\n        //\n        // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n        if (Math.abs(C) < MINIMUM_RESOLUTION) {\n          // Special case: circle is vertical.\n          //System.err.println(\" Degenerate case; it's vertical circle\");\n          // cos(phi) = D, and we want sin(phi) = z\n          // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n          // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt(1.0 - D * D);\n          y = -B * D * denom;\n          x = -A * D * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          addPoint(boundsInfo, bounds, x, y, z);\n        } else if (Math.abs(D) < MINIMUM_RESOLUTION) {\n          //System.err.println(\" Plane through origin case\");\n          // The general case is degenerate when the plane goes through the origin.\n          // Luckily there's a pretty good way to figure out the max and min for that case though.\n          // We find the two z values by computing the angle of the plane's inclination with the normal.\n          // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.\n          // Also if this.z == -1, then z value is 0 again.\n          // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).\n          //\n          // The only tricky part is computing x and y.\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt((A * A + B * B) / (A * A + B * B + C * C));\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n        } else {\n          //System.err.println(\" General latitude case\");\n          // We might be able to identify a specific new latitude maximum or minimum.\n          //\n          // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n          //\n          // This is tricky.  If cos(phi) = something, and we want to figure out\n          // what sin(phi) is, in order to capture all solutions we need to recognize\n          // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n          // whatever solution we find we have to mirror it across the x-y plane,\n          // and include both +z and -z solutions.\n          //\n          // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n          // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n          //\n          // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n          // Substitute:\n          // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z\n          // Solve for z...\n          // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n          // Square both sides.\n          // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz  = 1 - C^2 - z^2\n          // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0\n          //\n          // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n          // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n          //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n          //\n          // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to\n          // code a different solution for that case!\n\n          // To get x and y, we need to plug z into the equations, as follows:\n          //\n          // Ax + By = -Cz - D\n          // x^2 + y^2 = 1 - z^2\n          //\n          // x = (-Cz -D -By) /A\n          // y = (-Cz -D -Ax) /B\n          //\n          // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2\n          // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2\n          // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0\n          // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0\n          //\n          //\n          // Use quadratic formula, where:\n          // a = [A^2 + B^2]\n          // b = [2BD + 2CBz]\n          // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]\n          //\n          // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])\n          // Take out a 2:\n          // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]\n          //\n          // The sqrt term simplifies:\n          //\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2\n          //                  - B^2 + B^2 * z^2] =?\n          // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?\n          // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?\n          //\n          // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // correspondingly:\n          // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If\n          // it is NOT zero, then we aren't looking at the right z value.\n\n          double z;\n          double x;\n          double y;\n\n          double sqrtValue = D * D * C * C + 1.0 - C * C - D * D;\n          double denom = 1.0 / (A * A + B * B);\n          if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {\n            //System.err.println(\" One latitude solution\");\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C;\n            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          } else if (sqrtValue > 0.0) {\n            //System.err.println(\" Two latitude solutions\");\n            double sqrtResult = Math.sqrt(sqrtValue);\n\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C + sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            z = D * C - sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          }\n        }\n      } else {\n        // Horizontal circle.\n        // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n        // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n        // to check Membership objects.\n        boundsInfo.addHorizontalCircle(-D * C);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the unit circle.  All we\n            // need to do then is to find the intersection of the unit circle and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The unit circle:\n            // x^2 + y^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2 + y^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2 + A^2*y^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n\n            a = B * B + A * A;\n            b = 2.0 * B * D;\n            c = D * D - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B + A * A;\n            b = 2.0 * A * D;\n            c = D * D - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From unit sphere:\n        // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n        // Simplify/expand:\n        // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n        //\n        // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n        // Group:\n        // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A + C * C;\n        double F = B * B + C * C;\n        double G = 2.0 * A * B;\n        double H = 2.0 * A * D;\n        double I = 2.0 * B * D;\n        double J = D * D - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n        // sin (phi) = z\n        // cos (theta - phi) = D\n        // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n        // Q: what is z?\n        //\n        // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n        if (Math.abs(C) < MINIMUM_RESOLUTION) {\n          // Special case: circle is vertical.\n          //System.err.println(\" Degenerate case; it's vertical circle\");\n          // cos(phi) = D, and we want sin(phi) = z\n          // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n          // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt(1.0 - D * D);\n          y = -B * D * denom;\n          x = -A * D * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          addPoint(boundsInfo, bounds, x, y, z);\n        } else if (Math.abs(D) < MINIMUM_RESOLUTION) {\n          //System.err.println(\" Plane through origin case\");\n          // The general case is degenerate when the plane goes through the origin.\n          // Luckily there's a pretty good way to figure out the max and min for that case though.\n          // We find the two z values by computing the angle of the plane's inclination with the normal.\n          // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.\n          // Also if this.z == -1, then z value is 0 again.\n          // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).\n          //\n          // The only tricky part is computing x and y.\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt((A * A + B * B) / (A * A + B * B + C * C));\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n        } else {\n          //System.err.println(\" General latitude case\");\n          // We might be able to identify a specific new latitude maximum or minimum.\n          //\n          // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n          //\n          // This is tricky.  If cos(phi) = something, and we want to figure out\n          // what sin(phi) is, in order to capture all solutions we need to recognize\n          // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n          // whatever solution we find we have to mirror it across the x-y plane,\n          // and include both +z and -z solutions.\n          //\n          // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n          // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n          //\n          // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n          // Substitute:\n          // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z\n          // Solve for z...\n          // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n          // Square both sides.\n          // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz  = 1 - C^2 - z^2\n          // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0\n          //\n          // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n          // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n          //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n          //\n          // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to\n          // code a different solution for that case!\n\n          // To get x and y, we need to plug z into the equations, as follows:\n          //\n          // Ax + By = -Cz - D\n          // x^2 + y^2 = 1 - z^2\n          //\n          // x = (-Cz -D -By) /A\n          // y = (-Cz -D -Ax) /B\n          //\n          // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2\n          // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2\n          // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0\n          // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0\n          //\n          //\n          // Use quadratic formula, where:\n          // a = [A^2 + B^2]\n          // b = [2BD + 2CBz]\n          // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]\n          //\n          // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])\n          // Take out a 2:\n          // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]\n          //\n          // The sqrt term simplifies:\n          //\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2\n          //                  - B^2 + B^2 * z^2] =?\n          // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?\n          // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?\n          //\n          // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // correspondingly:\n          // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If\n          // it is NOT zero, then we aren't looking at the right z value.\n\n          double z;\n          double x;\n          double y;\n\n          double sqrtValue = D * D * C * C + 1.0 - C * C - D * D;\n          double denom = 1.0 / (A * A + B * B);\n          if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {\n            //System.err.println(\" One latitude solution\");\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C;\n            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          } else if (sqrtValue > 0.0) {\n            //System.err.println(\" Two latitude solutions\");\n            double sqrtResult = Math.sqrt(sqrtValue);\n\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C + sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            z = D * C - sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          }\n        }\n      } else {\n        // Horizontal circle.\n        // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n        // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n        // to check Membership objects.\n        boundsInfo.addHorizontalCircle(-D * C);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the unit circle.  All we\n            // need to do then is to find the intersection of the unit circle and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The unit circle:\n            // x^2 + y^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2 + y^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2 + A^2*y^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n\n            a = B * B + A * A;\n            b = 2.0 * B * D;\n            c = D * D - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B + A * A;\n            b = 2.0 * A * D;\n            c = D * D - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From unit sphere:\n        // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n        // Simplify/expand:\n        // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n        //\n        // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n        // Group:\n        // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A + C * C;\n        double F = B * B + C * C;\n        double G = 2.0 * A * B;\n        double H = 2.0 * A * D;\n        double I = 2.0 * B * D;\n        double J = D * D - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        double trialX = 2.0;\n        double trialY = 2.0;\n\n        //System.err.println(\"Trial point evaluates to: \"+(E*trialX*trialX + F*trialY*trialY + G*trialX*trialY + H*trialX + I*trialY + J));\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","bugFix":["e2997acf74723385bd84aff1ea0b12af4aefde77"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9f97ca977ad649f14b4f60a888adef2edd7a64e","date":1432702490,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(PlanetModel,Bounds,Membership...).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a horizontal circle!\n        //System.err.println(\" Not a horizontal circle\");\n        final Plane verticalPlane = constructNormalizedVerticalPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, NO_BOUNDS, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          addPoint(boundsInfo, bounds, point.x, point.y, point.z);\n        }\n      } else {\n        // Horizontal circle.  Since a==b, one vertical plane suffices.\n        final Plane verticalPlane = new Plane(1.0,0.0);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, NO_BOUNDS, NO_BOUNDS);\n        // There will always be two points; we only need one.\n        final GeoPoint point = points[0];\n        boundsInfo.addHorizontalCircle(point.z/Math.sqrt(point.x * point.x + point.y * point.y + point.z * point.z));\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the projected ellipse.  All we\n            // need to do then is to find the intersection of the projected ellipse and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The projected ellipse:\n            // x^2/a^2 + y^2/b^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2/a^2 + y^2/b^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2/a^2 + 2BDy/a^2 + D^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2/a^2 + A^2/b^2] + y [2BD/a^2] + [D^2/a^2-A^2] = 0\n\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * B * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * A * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the ellipsoid, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From ellipsoid:\n        // x^2/a^2 + y^2/b^2 + [(-Ax - By - D) / C]^2/c^2 = 1\n        // Simplify/expand:\n        // C^2*x^2/a^2 + C^2*y^2/b^2 + (-Ax - By - D)^2/c^2 = C^2\n        //\n        // x^2 * C^2/a^2 + y^2 * C^2/b^2 + x^2 * A^2/c^2 + ABxy/c^2 + ADx/c^2 + ABxy/c^2 + y^2 * B^2/c^2 + BDy/c^2 + ADx/c^2 + BDy/c^2 + D^2/c^2 = C^2\n        // Group:\n        // [A^2/c^2 + C^2/a^2] x^2 + [B^2/c^2 + C^2/b^2] y^2 + [2AB/c^2]xy + [2AD/c^2]x + [2BD/c^2]y + [D^2/c^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double F = B * B * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double G = 2.0 * A * B * planetModel.inverseCSquared;\n        double H = 2.0 * A * D * planetModel.inverseCSquared;\n        double I = 2.0 * B * D * planetModel.inverseCSquared;\n        double J = D * D * planetModel.inverseCSquared - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n        // sin (phi) = z\n        // cos (theta - phi) = D\n        // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n        // Q: what is z?\n        //\n        // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n        if (Math.abs(C) < MINIMUM_RESOLUTION) {\n          // Special case: circle is vertical.\n          //System.err.println(\" Degenerate case; it's vertical circle\");\n          // cos(phi) = D, and we want sin(phi) = z\n          // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n          // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt(1.0 - D * D);\n          y = -B * D * denom;\n          x = -A * D * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          addPoint(boundsInfo, bounds, x, y, z);\n        } else if (Math.abs(D) < MINIMUM_RESOLUTION) {\n          //System.err.println(\" Plane through origin case\");\n          // The general case is degenerate when the plane goes through the origin.\n          // Luckily there's a pretty good way to figure out the max and min for that case though.\n          // We find the two z values by computing the angle of the plane's inclination with the normal.\n          // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.\n          // Also if this.z == -1, then z value is 0 again.\n          // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).\n          //\n          // The only tricky part is computing x and y.\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt((A * A + B * B) / (A * A + B * B + C * C));\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n        } else {\n          //System.err.println(\" General latitude case\");\n          // We might be able to identify a specific new latitude maximum or minimum.\n          //\n          // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n          //\n          // This is tricky.  If cos(phi) = something, and we want to figure out\n          // what sin(phi) is, in order to capture all solutions we need to recognize\n          // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n          // whatever solution we find we have to mirror it across the x-y plane,\n          // and include both +z and -z solutions.\n          //\n          // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n          // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n          //\n          // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n          // Substitute:\n          // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z\n          // Solve for z...\n          // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n          // Square both sides.\n          // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz  = 1 - C^2 - z^2\n          // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0\n          //\n          // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n          // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n          //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n          //\n          // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to\n          // code a different solution for that case!\n\n          // To get x and y, we need to plug z into the equations, as follows:\n          //\n          // Ax + By = -Cz - D\n          // x^2 + y^2 = 1 - z^2\n          //\n          // x = (-Cz -D -By) /A\n          // y = (-Cz -D -Ax) /B\n          //\n          // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2\n          // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2\n          // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0\n          // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0\n          //\n          //\n          // Use quadratic formula, where:\n          // a = [A^2 + B^2]\n          // b = [2BD + 2CBz]\n          // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]\n          //\n          // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])\n          // Take out a 2:\n          // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]\n          //\n          // The sqrt term simplifies:\n          //\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2\n          //                  - B^2 + B^2 * z^2] =?\n          // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?\n          // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?\n          //\n          // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // correspondingly:\n          // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If\n          // it is NOT zero, then we aren't looking at the right z value.\n\n          double z;\n          double x;\n          double y;\n\n          double sqrtValue = D * D * C * C + 1.0 - C * C - D * D;\n          double denom = 1.0 / (A * A + B * B);\n          if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {\n            //System.err.println(\" One latitude solution\");\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C;\n            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          } else if (sqrtValue > 0.0) {\n            //System.err.println(\" Two latitude solutions\");\n            double sqrtResult = Math.sqrt(sqrtValue);\n\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C + sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            z = D * C - sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          }\n        }\n      } else {\n        // Horizontal circle.\n        // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n        // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n        // to check Membership objects.\n        boundsInfo.addHorizontalCircle(-D * C);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the unit circle.  All we\n            // need to do then is to find the intersection of the unit circle and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The unit circle:\n            // x^2 + y^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2 + y^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2 + A^2*y^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n\n            a = B * B + A * A;\n            b = 2.0 * B * D;\n            c = D * D - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B + A * A;\n            b = 2.0 * A * D;\n            c = D * D - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From unit sphere:\n        // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n        // Simplify/expand:\n        // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n        //\n        // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n        // Group:\n        // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A + C * C;\n        double F = B * B + C * C;\n        double G = 2.0 * A * B;\n        double H = 2.0 * A * D;\n        double I = 2.0 * B * D;\n        double J = D * D - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fec06d6753751ae302c7d35866763e6cb414112d","date":1433250698,"type":5,"author":"David Wayne Smiley","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(PlanetModel,Bounds,Membership...).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane#recordBounds(Bounds,Membership...).mjava","sourceNew":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param planetModel is the planet model to use in determining bounds.\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final PlanetModel planetModel, final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      // With ellipsoids, we really have only one viable way to do this computation.\n      // Specifically, we compute an appropriate vertical plane, based on the current plane's x-y orientation, and\n      // then intersect it with this one and with the ellipsoid.  This gives us zero, one, or two points to use\n      // as bounds.\n      // There is one special case: horizontal circles.  These require TWO vertical planes: one for the x, and one for\n      // the y, and we use all four resulting points in the bounds computation.\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        // NOT a horizontal circle!\n        //System.err.println(\" Not a horizontal circle\");\n        final Plane verticalPlane = constructNormalizedVerticalPlane(A,B);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, NO_BOUNDS, NO_BOUNDS);\n        for (final GeoPoint point : points) {\n          addPoint(boundsInfo, bounds, point.x, point.y, point.z);\n        }\n      } else {\n        // Horizontal circle.  Since a==b, one vertical plane suffices.\n        final Plane verticalPlane = new Plane(1.0,0.0);\n        final GeoPoint[] points = findIntersections(planetModel, verticalPlane, NO_BOUNDS, NO_BOUNDS);\n        // There will always be two points; we only need one.\n        final GeoPoint point = points[0];\n        boundsInfo.addHorizontalCircle(point.z/Math.sqrt(point.x * point.x + point.y * point.y + point.z * point.z));\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the projected ellipse.  All we\n            // need to do then is to find the intersection of the projected ellipse and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The projected ellipse:\n            // x^2/a^2 + y^2/b^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2/a^2 + y^2/b^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2/a^2 + 2BDy/a^2 + D^2/a^2 + A^2*y^2/b^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2/a^2 + A^2/b^2] + y [2BD/a^2] + [D^2/a^2-A^2] = 0\n\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * B * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;\n            b = 2.0 * A * D * planetModel.inverseAbSquared;\n            c = D * D * planetModel.inverseAbSquared - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the ellipsoid, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From ellipsoid:\n        // x^2/a^2 + y^2/b^2 + [(-Ax - By - D) / C]^2/c^2 = 1\n        // Simplify/expand:\n        // C^2*x^2/a^2 + C^2*y^2/b^2 + (-Ax - By - D)^2/c^2 = C^2\n        //\n        // x^2 * C^2/a^2 + y^2 * C^2/b^2 + x^2 * A^2/c^2 + ABxy/c^2 + ADx/c^2 + ABxy/c^2 + y^2 * B^2/c^2 + BDy/c^2 + ADx/c^2 + BDy/c^2 + D^2/c^2 = C^2\n        // Group:\n        // [A^2/c^2 + C^2/a^2] x^2 + [B^2/c^2 + C^2/b^2] y^2 + [2AB/c^2]xy + [2AD/c^2]x + [2BD/c^2]y + [D^2/c^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double F = B * B * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;\n        double G = 2.0 * A * B * planetModel.inverseCSquared;\n        double H = 2.0 * A * D * planetModel.inverseCSquared;\n        double I = 2.0 * B * D * planetModel.inverseCSquared;\n        double J = D * D * planetModel.inverseCSquared - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Accumulate bounds information for this plane, intersected with the unit sphere.\n   * Updates both latitude and longitude information, using max/min points found\n   * within the specified bounds.\n   *\n   * @param boundsInfo is the info to update with additional bounding information.\n   * @param bounds     are the surfaces delineating what's inside the shape.\n   */\n  public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {\n    // For clarity, load local variables with good names\n    final double A = this.x;\n    final double B = this.y;\n    final double C = this.z;\n\n    // Now compute latitude min/max points\n    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {\n      //System.err.println(\"Looking at latitude for plane \"+this);\n      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {\n        //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n        // sin (phi) = z\n        // cos (theta - phi) = D\n        // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )\n        // Q: what is z?\n        //\n        // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n\n        if (Math.abs(C) < MINIMUM_RESOLUTION) {\n          // Special case: circle is vertical.\n          //System.err.println(\" Degenerate case; it's vertical circle\");\n          // cos(phi) = D, and we want sin(phi) = z\n          // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.\n          // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .\n\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt(1.0 - D * D);\n          y = -B * D * denom;\n          x = -A * D * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          addPoint(boundsInfo, bounds, x, y, z);\n        } else if (Math.abs(D) < MINIMUM_RESOLUTION) {\n          //System.err.println(\" Plane through origin case\");\n          // The general case is degenerate when the plane goes through the origin.\n          // Luckily there's a pretty good way to figure out the max and min for that case though.\n          // We find the two z values by computing the angle of the plane's inclination with the normal.\n          // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.\n          // Also if this.z == -1, then z value is 0 again.\n          // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).\n          //\n          // The only tricky part is computing x and y.\n          double z;\n          double x;\n          double y;\n\n          final double denom = 1.0 / (A * A + B * B);\n\n          z = Math.sqrt((A * A + B * B) / (A * A + B * B + C * C));\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n          z = -z;\n          y = -B * (C * z) * denom;\n          x = -A * (C * z) * denom;\n          addPoint(boundsInfo, bounds, x, y, z);\n\n        } else {\n          //System.err.println(\" General latitude case\");\n          // We might be able to identify a specific new latitude maximum or minimum.\n          //\n          // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D\n          //\n          // This is tricky.  If cos(phi) = something, and we want to figure out\n          // what sin(phi) is, in order to capture all solutions we need to recognize\n          // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that\n          // whatever solution we find we have to mirror it across the x-y plane,\n          // and include both +z and -z solutions.\n          //\n          // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)\n          // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)\n          //\n          // D = cos(theta)cos(phi) + sin(theta)sin(phi)\n          // Substitute:\n          // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z\n          // Solve for z...\n          // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)\n          // Square both sides.\n          // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2\n          // D^2 +/- 2DCz  = 1 - C^2 - z^2\n          // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0\n          //\n          // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)\n          // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )\n          //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)\n          //\n          // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to\n          // code a different solution for that case!\n\n          // To get x and y, we need to plug z into the equations, as follows:\n          //\n          // Ax + By = -Cz - D\n          // x^2 + y^2 = 1 - z^2\n          //\n          // x = (-Cz -D -By) /A\n          // y = (-Cz -D -Ax) /B\n          //\n          // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2\n          // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2\n          // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0\n          // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0\n          //\n          //\n          // Use quadratic formula, where:\n          // a = [A^2 + B^2]\n          // b = [2BD + 2CBz]\n          // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]\n          //\n          // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])\n          // Take out a 2:\n          // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]\n          //\n          // The sqrt term simplifies:\n          //\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?\n          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2\n          //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?\n          // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2\n          //                  - B^2 + B^2 * z^2] =?\n          // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?\n          // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?\n          //\n          // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // correspondingly:\n          // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]\n          //\n          // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If\n          // it is NOT zero, then we aren't looking at the right z value.\n\n          double z;\n          double x;\n          double y;\n\n          double sqrtValue = D * D * C * C + 1.0 - C * C - D * D;\n          double denom = 1.0 / (A * A + B * B);\n          if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {\n            //System.err.println(\" One latitude solution\");\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C;\n            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          } else if (sqrtValue > 0.0) {\n            //System.err.println(\" Two latitude solutions\");\n            double sqrtResult = Math.sqrt(sqrtValue);\n\n            double insideValue;\n            double sqrtTerm;\n\n            z = D * C + sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            z = D * C - sqrtResult;\n            //System.out.println(\"z= \"+z+\" D-C*z = \" + (D-C*z) + \" Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = \"+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));\n            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.\n            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n            // Check the solution on the other side of the x-y plane\n            z = -z;\n            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;\n            //System.err.println(\" z=\"+z+\" C=\"+C+\" D=\"+D+\" inside value \"+insideValue);\n            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {\n              y = -B * (D + C * z) * denom;\n              x = -A * (D + C * z) * denom;\n              if (evaluateIsZero(x, y, z)) {\n                addPoint(boundsInfo, bounds, x, y, z);\n              }\n            }\n          }\n        }\n      } else {\n        // Horizontal circle.\n        // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,\n        // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need\n        // to check Membership objects.\n        boundsInfo.addHorizontalCircle(-D * C);\n      }\n      //System.err.println(\"Done latitude bounds\");\n    }\n\n    // First, figure out our longitude bounds, unless we no longer need to consider that\n    if (!boundsInfo.checkNoLongitudeBound()) {\n      //System.err.println(\"Computing longitude bounds for \"+this);\n      //System.out.println(\"A = \"+A+\" B = \"+B+\" C = \"+C+\" D = \"+D);\n      // Compute longitude bounds\n\n      double a;\n      double b;\n      double c;\n\n      if (Math.abs(C) < MINIMUM_RESOLUTION) {\n        // Degenerate; the equation describes a line\n        //System.out.println(\"It's a zero-width ellipse\");\n        // Ax + By + D = 0\n        if (Math.abs(D) >= MINIMUM_RESOLUTION) {\n          if (Math.abs(A) > Math.abs(B)) {\n            // Use equation suitable for A != 0\n            // We need to find the endpoints of the zero-width ellipse.\n            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints\n            // of that line.  But luckily, we know some things: specifically, since it is a\n            // degenerate situation in projection, the C value had to have been 0.  That\n            // means that our line's endpoints will coincide with the unit circle.  All we\n            // need to do then is to find the intersection of the unit circle and the line\n            // equation:\n            //\n            // A x + B y + D = 0\n            //\n            // Since A != 0:\n            // x = (-By - D)/A\n            //\n            // The unit circle:\n            // x^2 + y^2 - 1 = 0\n            // Substitute:\n            // [(-By-D)/A]^2 + y^2 -1 = 0\n            // Multiply through by A^2:\n            // [-By - D]^2 + A^2*y^2 - A^2 = 0\n            // Multiply out:\n            // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0\n            // Group:\n            // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0\n\n            a = B * B + A * A;\n            b = 2.0 * B * D;\n            c = D * D - A * A;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double y0 = -b / (2.0 * a);\n              double x0 = (-D - B * y0) / A;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / A;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n\n              double x0a = (-D - B * y0a) * Hdenom;\n              double x0b = (-D - B * y0b) * Hdenom;\n\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            // Use equation suitable for B != 0\n            // Since I != 0, we rewrite:\n            // y = (-Ax - D)/B\n            a = B * B + A * A;\n            b = 2.0 * A * D;\n            c = D * D - B * B;\n\n            double sqrtClause = b * b - 4.0 * a * c;\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {\n              double x0 = -b / (2.0 * a);\n              double y0 = (-D - A * x0) / B;\n              double z0 = 0.0;\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / B;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-D - A * x0a) * Idenom;\n              double y0b = (-D - A * x0b) * Idenom;\n              double z0a = 0.0;\n              double z0b = 0.0;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n\n      } else {\n        //System.err.println(\"General longitude bounds...\");\n\n        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.\n        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,\n        // and z for latitude, and that's all the values are good for.\n\n        // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:\n        // From plane:\n        // z = (-Ax - By - D) / C\n        // From unit sphere:\n        // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1\n        // Simplify/expand:\n        // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2\n        //\n        // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2\n        // Group:\n        // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0\n        // For convenience, introduce post-projection coefficient variables to make life easier.\n        // E x^2 + F y^2 + G xy + H x + I y + J = 0\n        double E = A * A + C * C;\n        double F = B * B + C * C;\n        double G = 2.0 * A * B;\n        double H = 2.0 * A * D;\n        double I = 2.0 * B * D;\n        double J = D * D - C * C;\n\n        //System.err.println(\"E = \" + E + \" F = \" + F + \" G = \" + G + \" H = \"+ H + \" I = \" + I + \" J = \" + J);\n\n        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero\n        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {\n          // The derivative of the curve above is:\n          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0\n          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0\n          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)\n          //\n          // The equation of a line going through the origin with the slope dy/dx is:\n          // y = dy/dx x\n          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x\n          // Rearrange:\n          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0\n          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0\n          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n          //\n          // Multiply the original equation by 2:\n          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0\n          // Subtract one from the other, to remove the high-order terms:\n          // Hx + Iy + 2J = 0\n          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.\n          // But we will need to base this on which coefficient is non-zero\n\n          if (Math.abs(H) > Math.abs(I)) {\n            //System.err.println(\" Using the y quadratic\");\n            // x = (-2J - Iy)/H\n\n            // Plug into the original equation:\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0\n            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0\n            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.\n\n            // Plug into derivative equation:\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0\n            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0\n            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0\n\n            // Multiply by H^2 to make manipulation easier\n            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0\n            // Do the square\n            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0\n\n            // Multiply it out\n            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0\n            // Group:\n            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * E * I * J - 2.0 * G * H * J;\n            c = 4.0 * E * J * J - J * H * H;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution\");\n              double y0 = -b / (2.0 * a);\n              double x0 = (-2.0 * J - I * y0) / H;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Hdenom = 1.0 / H;\n              double Cdenom = 1.0 / C;\n\n              double y0a = (-b + sqrtResult) * denom;\n              double y0b = (-b - sqrtResult) * denom;\n              double x0a = (-2.0 * J - I * y0a) * Hdenom;\n              double x0b = (-2.0 * J - I * y0b) * Hdenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n\n          } else {\n            //System.err.println(\" Using the x quadratic\");\n            // y = (-2J - Hx)/I\n\n            // Plug into the original equation:\n            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0\n\n            // Multiply by I^2 to make manipulation easier\n            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0\n            // Do the square\n            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0\n\n            // Multiply it out\n            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0\n            // Group:\n            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0\n\n            // E x^2 + F y^2 + G xy + H x + I y + J = 0\n\n            a = E * I * I - G * H * I + F * H * H;\n            b = 4.0 * F * H * J - 2.0 * G * I * J;\n            c = 4.0 * F * J * J - J * I * I;\n\n            //System.out.println(\"a=\"+a+\" b=\"+b+\" c=\"+c);\n            double sqrtClause = b * b - 4.0 * a * c;\n            //System.out.println(\"sqrtClause=\"+sqrtClause);\n            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {\n              //System.err.println(\" One solution; sqrt clause was \"+sqrtClause);\n              double x0 = -b / (2.0 * a);\n              double y0 = (-2.0 * J - H * x0) / I;\n              double z0 = (-A * x0 - B * y0 - D) / C;\n              // Verify that x&y fulfill the equation\n              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0\n              addPoint(boundsInfo, bounds, x0, y0, z0);\n            } else if (sqrtClause > 0.0) {\n              //System.err.println(\" Two solutions\");\n              double sqrtResult = Math.sqrt(sqrtClause);\n              double denom = 1.0 / (2.0 * a);\n              double Idenom = 1.0 / I;\n              double Cdenom = 1.0 / C;\n\n              double x0a = (-b + sqrtResult) * denom;\n              double x0b = (-b - sqrtResult) * denom;\n              double y0a = (-2.0 * J - H * x0a) * Idenom;\n              double y0b = (-2.0 * J - H * x0b) * Idenom;\n              double z0a = (-A * x0a - B * y0a - D) * Cdenom;\n              double z0b = (-A * x0b - B * y0b - D) * Cdenom;\n\n              addPoint(boundsInfo, bounds, x0a, y0a, z0a);\n              addPoint(boundsInfo, bounds, x0b, y0b, z0b);\n            }\n          }\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aafaf65c7159614a90c78005b3e21b3043b46024":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"0fb9dbed1415914caa27460f8abb7afadaa61451":["851e4197476b684154a7b65f996f535522e67400"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fec06d6753751ae302c7d35866763e6cb414112d":["aafaf65c7159614a90c78005b3e21b3043b46024","f9f97ca977ad649f14b4f60a888adef2edd7a64e"],"e2997acf74723385bd84aff1ea0b12af4aefde77":["4762743d2f10f32ae47dc222ef92e0807ffe2ab8"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e2997acf74723385bd84aff1ea0b12af4aefde77"],"4762743d2f10f32ae47dc222ef92e0807ffe2ab8":["7aca5c321bc9760dbfc9cefcc9d648e946b4615e"],"851e4197476b684154a7b65f996f535522e67400":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7aca5c321bc9760dbfc9cefcc9d648e946b4615e":["0fb9dbed1415914caa27460f8abb7afadaa61451"],"f9f97ca977ad649f14b4f60a888adef2edd7a64e":["aafaf65c7159614a90c78005b3e21b3043b46024"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fec06d6753751ae302c7d35866763e6cb414112d"]},"commit2Childs":{"aafaf65c7159614a90c78005b3e21b3043b46024":["fec06d6753751ae302c7d35866763e6cb414112d","f9f97ca977ad649f14b4f60a888adef2edd7a64e"],"0fb9dbed1415914caa27460f8abb7afadaa61451":["7aca5c321bc9760dbfc9cefcc9d648e946b4615e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c921d81476f94b6686d3f216daa1f6b076b4a6c0","851e4197476b684154a7b65f996f535522e67400"],"fec06d6753751ae302c7d35866763e6cb414112d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e2997acf74723385bd84aff1ea0b12af4aefde77":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["aafaf65c7159614a90c78005b3e21b3043b46024"],"851e4197476b684154a7b65f996f535522e67400":["0fb9dbed1415914caa27460f8abb7afadaa61451"],"4762743d2f10f32ae47dc222ef92e0807ffe2ab8":["e2997acf74723385bd84aff1ea0b12af4aefde77"],"f9f97ca977ad649f14b4f60a888adef2edd7a64e":["fec06d6753751ae302c7d35866763e6cb414112d"],"7aca5c321bc9760dbfc9cefcc9d648e946b4615e":["4762743d2f10f32ae47dc222ef92e0807ffe2ab8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}