{"path":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","commits":[{"id":"310045472df7463a74daabf6252eafc9d93960e0","date":1413271286,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p/>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent= parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted,this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if(node == null) node = wildCardChild;\n          if(node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if(event == OBJECT_START || event == ARRAY_START){\n                if(node.recursiveWildCardChild !=null) runnable = new Wrapper(node, frameWrapper,name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if(val !=null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p/>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper( Node node) {\n          this.node = node;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if(node == null) node = wildCardChild;\n          if(node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? name : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if(event == OBJECT_START || event == ARRAY_START){\n                if(node.recursiveWildCardChild !=null) runnable = new Wrapper(node);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if(val !=null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p/>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent= parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted,this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if(node == null) node = wildCardChild;\n          if(node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if(event == OBJECT_START || event == ARRAY_START){\n                if(node.recursiveWildCardChild !=null) runnable = new Wrapper(node, frameWrapper,name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if(val !=null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p/>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper( Node node) {\n          this.node = node;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if(node == null) node = wildCardChild;\n          if(node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? name : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if(event == OBJECT_START || event == ARRAY_START){\n                if(node.recursiveWildCardChild !=null) runnable = new Wrapper(node);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if(val !=null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d23f179b9528b0d2ae2128e17b957fd055d3f4a0","date":1415202068,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p/>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent= parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted,this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if(node == null) node = wildCardChild;\n          if(node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if(event == OBJECT_START || event == ARRAY_START){\n                if(node.recursiveWildCardChild !=null) runnable = new Wrapper(node, frameWrapper,name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if(val !=null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p/>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent= parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted,this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if(node == null) node = wildCardChild;\n          if(node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if(event == OBJECT_START || event == ARRAY_START){\n                if(node.recursiveWildCardChild !=null) runnable = new Wrapper(node, frameWrapper,name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if(val !=null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2330174b38007b9942205a2679db9ddffe35af89","date":1423653924,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p/>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent= parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted,this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if(node == null) node = wildCardChild;\n          if(node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if(event == OBJECT_START || event == ARRAY_START){\n                if(node.recursiveWildCardChild !=null) runnable = new Wrapper(node, frameWrapper,name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if(val !=null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"986e12881edf3577b0b211320599354a4771de0c","date":1425932508,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) ) {\n            for (String fld : valuesAddedinThisFrame) {\n              values.remove(fld);\n            }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["e0b642a3812459b02e629bc9b078a521513741b9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e0b642a3812459b02e629bc9b078a521513741b9","date":1425932588,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) ) {\n            for (String fld : valuesAddedinThisFrame) {\n              values.remove(fld);\n            }\n        }\n      }\n    }\n\n","bugFix":["caf7f9acfdff984e59be68054cc1e0048b8ee030","986e12881edf3577b0b211320599354a4771de0c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                if (isRecordStarted) valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted) && !stack.empty()) {\n          Set<String> cleanThis = stack.pop();\n          if (cleanThis != null) {\n            for (String fld : cleanThis) {\n              values.remove(fld);\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7272013f8448f299f54112ec41cb3dc047cda543","date":1453483707,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"310045472df7463a74daabf6252eafc9d93960e0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["2330174b38007b9942205a2679db9ddffe35af89","e0b642a3812459b02e629bc9b078a521513741b9"],"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","310045472df7463a74daabf6252eafc9d93960e0"],"7272013f8448f299f54112ec41cb3dc047cda543":["e0b642a3812459b02e629bc9b078a521513741b9"],"2330174b38007b9942205a2679db9ddffe35af89":["d23f179b9528b0d2ae2128e17b957fd055d3f4a0"],"e0b642a3812459b02e629bc9b078a521513741b9":["986e12881edf3577b0b211320599354a4771de0c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d23f179b9528b0d2ae2128e17b957fd055d3f4a0":["310045472df7463a74daabf6252eafc9d93960e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7272013f8448f299f54112ec41cb3dc047cda543"],"986e12881edf3577b0b211320599354a4771de0c":["2330174b38007b9942205a2679db9ddffe35af89"]},"commit2Childs":{"310045472df7463a74daabf6252eafc9d93960e0":["55980207f1977bd1463465de1659b821347e2fa8","d23f179b9528b0d2ae2128e17b957fd055d3f4a0"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"55980207f1977bd1463465de1659b821347e2fa8":[],"7272013f8448f299f54112ec41cb3dc047cda543":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2330174b38007b9942205a2679db9ddffe35af89":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","986e12881edf3577b0b211320599354a4771de0c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["310045472df7463a74daabf6252eafc9d93960e0","55980207f1977bd1463465de1659b821347e2fa8"],"e0b642a3812459b02e629bc9b078a521513741b9":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","7272013f8448f299f54112ec41cb3dc047cda543"],"d23f179b9528b0d2ae2128e17b957fd055d3f4a0":["2330174b38007b9942205a2679db9ddffe35af89"],"986e12881edf3577b0b211320599354a4771de0c":["e0b642a3812459b02e629bc9b078a521513741b9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}