{"path":"solr/core/src/java/org/apache/solr/search/join/GraphPointsCollector#getResultQuery(SchemaField,boolean).mjava","commits":[{"id":"487de3f55283f58d7e02a16993f8be55bbe32061","date":1502123368,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphPointsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphPointsCollector[GraphTermsCollector]#getResultQuery().mjava","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (set.cardinality() == 0) return null;\n\n    Query q = null;\n\n    // How we interpret the longs collected depends on the field we collect from (single valued can be diff from multi valued)\n    // The basic type of the from & to field must match though (int/long/float/double)\n    NumberType ntype = collectField.getType().getNumberType();\n    boolean multiValued = collectField.multiValued();\n\n    if (ntype == NumberType.LONG || ntype == NumberType.DATE) {\n      long[] vals = new long[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        long v = bits;\n        vals[i++] = v;\n      }\n      q = LongPoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.INTEGER) {\n      int[] vals = new int[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        int v = (int)bits;\n        vals[i++] = v;\n      }\n      q = IntPoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.DOUBLE) {\n      double[] vals = new double[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        double v = multiValued ? NumericUtils.sortableLongToDouble(bits) : Double.longBitsToDouble(bits);\n        vals[i++] = v;\n      }\n      q = DoublePoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.FLOAT) {\n      float[] vals = new float[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        float v = multiValued ? NumericUtils.sortableIntToFloat((int) bits) : Float.intBitsToFloat((int) bits);\n        vals[i++] = v;\n      }\n      q = FloatPoint.newSetQuery(matchField.getName(), vals);\n    }\n\n    return q;\n  }\n\n","sourceOld":"  @Override\n  protected Query getResultQuery() {\n    if (set.cardinality() == 0) return null;\n\n    Query q = null;\n    SchemaField sfield = weight.fromSchemaField;\n    NumberType ntype = sfield.getType().getNumberType();\n    boolean multiValued = sfield.multiValued();\n\n    if (ntype == NumberType.LONG || ntype == NumberType.DATE) {\n      long[] vals = new long[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        long v = bits;\n        vals[i++] = v;\n      }\n      q = LongPoint.newSetQuery(sfield.getName(), vals);\n    } else if (ntype == NumberType.INTEGER) {\n      int[] vals = new int[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        int v = (int)bits;\n        vals[i++] = v;\n      }\n      q = IntPoint.newSetQuery(sfield.getName(), vals);\n    } else if (ntype == NumberType.DOUBLE) {\n      double[] vals = new double[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        double v = multiValued ? NumericUtils.sortableLongToDouble(bits) : Double.longBitsToDouble(bits);\n        vals[i++] = v;\n      }\n      q = DoublePoint.newSetQuery(sfield.getName(), vals);\n    } else if (ntype == NumberType.FLOAT) {\n      float[] vals = new float[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        float v = multiValued ? NumericUtils.sortableIntToFloat((int) bits) : Float.intBitsToFloat((int) bits);\n        vals[i++] = v;\n      }\n      q = FloatPoint.newSetQuery(sfield.getName(), vals);\n    }\n\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphPointsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (set.cardinality() == 0) return null;\n\n    Query q = null;\n\n    // How we interpret the longs collected depends on the field we collect from (single valued can be diff from multi valued)\n    // The basic type of the from & to field must match though (int/long/float/double)\n    NumberType ntype = collectField.getType().getNumberType();\n    boolean multiValued = collectField.multiValued();\n\n    if (ntype == NumberType.LONG || ntype == NumberType.DATE) {\n      long[] vals = new long[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        long v = bits;\n        vals[i++] = v;\n      }\n      q = LongPoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.INTEGER) {\n      int[] vals = new int[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        int v = (int)bits;\n        vals[i++] = v;\n      }\n      q = IntPoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.DOUBLE) {\n      double[] vals = new double[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        double v = multiValued ? NumericUtils.sortableLongToDouble(bits) : Double.longBitsToDouble(bits);\n        vals[i++] = v;\n      }\n      q = DoublePoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.FLOAT) {\n      float[] vals = new float[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        float v = multiValued ? NumericUtils.sortableIntToFloat((int) bits) : Float.intBitsToFloat((int) bits);\n        vals[i++] = v;\n      }\n      q = FloatPoint.newSetQuery(matchField.getName(), vals);\n    }\n\n    return q;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/join/GraphPointsCollector#getResultQuery(SchemaField,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/join/GraphPointsCollector[GraphTermsCollector]#getResultQuery().mjava","sourceNew":"  @Override\n  public Query getResultQuery(SchemaField matchField, boolean useAutomaton) {\n    if (set.cardinality() == 0) return null;\n\n    Query q = null;\n\n    // How we interpret the longs collected depends on the field we collect from (single valued can be diff from multi valued)\n    // The basic type of the from & to field must match though (int/long/float/double)\n    NumberType ntype = collectField.getType().getNumberType();\n    boolean multiValued = collectField.multiValued();\n\n    if (ntype == NumberType.LONG || ntype == NumberType.DATE) {\n      long[] vals = new long[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        long v = bits;\n        vals[i++] = v;\n      }\n      q = LongPoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.INTEGER) {\n      int[] vals = new int[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        int v = (int)bits;\n        vals[i++] = v;\n      }\n      q = IntPoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.DOUBLE) {\n      double[] vals = new double[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        double v = multiValued ? NumericUtils.sortableLongToDouble(bits) : Double.longBitsToDouble(bits);\n        vals[i++] = v;\n      }\n      q = DoublePoint.newSetQuery(matchField.getName(), vals);\n    } else if (ntype == NumberType.FLOAT) {\n      float[] vals = new float[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        float v = multiValued ? NumericUtils.sortableIntToFloat((int) bits) : Float.intBitsToFloat((int) bits);\n        vals[i++] = v;\n      }\n      q = FloatPoint.newSetQuery(matchField.getName(), vals);\n    }\n\n    return q;\n  }\n\n","sourceOld":"  @Override\n  protected Query getResultQuery() {\n    if (set.cardinality() == 0) return null;\n\n    Query q = null;\n    SchemaField sfield = weight.fromSchemaField;\n    NumberType ntype = sfield.getType().getNumberType();\n    boolean multiValued = sfield.multiValued();\n\n    if (ntype == NumberType.LONG || ntype == NumberType.DATE) {\n      long[] vals = new long[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        long v = bits;\n        vals[i++] = v;\n      }\n      q = LongPoint.newSetQuery(sfield.getName(), vals);\n    } else if (ntype == NumberType.INTEGER) {\n      int[] vals = new int[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        int v = (int)bits;\n        vals[i++] = v;\n      }\n      q = IntPoint.newSetQuery(sfield.getName(), vals);\n    } else if (ntype == NumberType.DOUBLE) {\n      double[] vals = new double[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        double v = multiValued ? NumericUtils.sortableLongToDouble(bits) : Double.longBitsToDouble(bits);\n        vals[i++] = v;\n      }\n      q = DoublePoint.newSetQuery(sfield.getName(), vals);\n    } else if (ntype == NumberType.FLOAT) {\n      float[] vals = new float[set.cardinality()];\n      int i = 0;\n      for (LongIterator iter = set.iterator(); iter.hasNext(); ) {\n        long bits = iter.next();\n        float v = multiValued ? NumericUtils.sortableIntToFloat((int) bits) : Float.intBitsToFloat((int) bits);\n        vals[i++] = v;\n      }\n      q = FloatPoint.newSetQuery(sfield.getName(), vals);\n    }\n\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"58884af1f68e9d61c217c753fbd6266d86a63b14":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","487de3f55283f58d7e02a16993f8be55bbe32061"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","487de3f55283f58d7e02a16993f8be55bbe32061"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"487de3f55283f58d7e02a16993f8be55bbe32061":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["487de3f55283f58d7e02a16993f8be55bbe32061"]},"commit2Childs":{"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","487de3f55283f58d7e02a16993f8be55bbe32061"],"487de3f55283f58d7e02a16993f8be55bbe32061":["58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}