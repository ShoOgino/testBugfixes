{"path":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","commits":[{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"/dev/null","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n            String op = req.getParams().get(\"op\");\n            if(\"leader\".equals(op)){\n              zkController.forceOverSeer();\n            } else if (\"rejoin\".equals(op)) zkController.rejoinOverseerElection();\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b15576cafd8b5d06857055c28f26912321937e3","date":1396452121,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           if (\"rejoin\".equals(op)) zkController.rejoinOverseerElection();\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n            String op = req.getParams().get(\"op\");\n            if(\"leader\".equals(op)){\n              zkController.forceOverSeer();\n            } else if (\"rejoin\".equals(op)) zkController.rejoinOverseerElection();\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           if (\"rejoin\".equals(op)) zkController.rejoinOverseerElection();\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n            String op = req.getParams().get(\"op\");\n            if(\"leader\".equals(op)){\n              zkController.forceOverSeer();\n            } else if (\"rejoin\".equals(op)) zkController.rejoinOverseerElection();\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d996c36bf85996da326201b915c87d41449d7f5","date":1403084374,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           if (\"rejoin\".equals(op)) zkController.rejoinOverseerElection();\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e57c73924f3b8c19defa62e96bfa34a4922d49c2","date":1403106358,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           if (\"rejoin\".equals(op)) zkController.rejoinOverseerElection();\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6b620c271c84c0f14919eec7b90083b292ee51","date":1419461736,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n\n        case REJOINLEADERELECTION:\n          ZkController zkController = coreContainer.getZkController();\n\n          if (zkController != null) {\n            zkController.rejoinShardLeaderElection(req.getParams());\n          } else {\n            log.warn(\"zkController is null in CoreAdminHandler.handleRequestInternal:REJOINLEADERELCTIONS. No action taken.\");\n          }\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":null,"bugIntro":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n\n        case REJOINLEADERELECTION:\n          ZkController zkController = coreContainer.getZkController();\n\n          if (zkController != null) {\n            zkController.rejoinShardLeaderElection(req.getParams());\n          } else {\n            log.warn(\"zkController is null in CoreAdminHandler.handleRequestInternal:REJOINLEADERELCTIONS. No action taken.\");\n          }\n          break;\n        case INVOKE:\n          handleInvoke(req, rsp);\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n\n        case REJOINLEADERELECTION:\n          ZkController zkController = coreContainer.getZkController();\n\n          if (zkController != null) {\n            zkController.rejoinShardLeaderElection(req.getParams());\n          } else {\n            log.warn(\"zkController is null in CoreAdminHandler.handleRequestInternal:REJOINLEADERELCTIONS. No action taken.\");\n          }\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064","date":1441124018,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n\n        case REJOINLEADERELECTION:\n          ZkController zkController = coreContainer.getZkController();\n\n          if (zkController != null) {\n            zkController.rejoinShardLeaderElection(req.getParams());\n          } else {\n            log.warn(\"zkController is null in CoreAdminHandler.handleRequestInternal:REJOINLEADERELECTION. No action taken.\");\n          }\n          break;\n        case INVOKE:\n          handleInvoke(req, rsp);\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n\n        case REJOINLEADERELECTION:\n          ZkController zkController = coreContainer.getZkController();\n\n          if (zkController != null) {\n            zkController.rejoinShardLeaderElection(req.getParams());\n          } else {\n            log.warn(\"zkController is null in CoreAdminHandler.handleRequestInternal:REJOINLEADERELCTIONS. No action taken.\");\n          }\n          break;\n        case INVOKE:\n          handleInvoke(req, rsp);\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":["4e6b620c271c84c0f14919eec7b90083b292ee51"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05","date":1446751515,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n\n        case REJOINLEADERELECTION:\n          ZkController zkController = coreContainer.getZkController();\n\n          if (zkController != null) {\n            zkController.rejoinShardLeaderElection(req.getParams());\n          } else {\n            log.warn(\"zkController is null in CoreAdminHandler.handleRequestInternal:REJOINLEADERELECTION. No action taken.\");\n          }\n          break;\n        case INVOKE:\n          handleInvoke(req, rsp);\n          break;\n        case FORCEPREPAREFORLEADERSHIP: {\n          this.handleForcePrepareForLeadership(req, rsp);\n          break;\n        }\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n\n        case REJOINLEADERELECTION:\n          ZkController zkController = coreContainer.getZkController();\n\n          if (zkController != null) {\n            zkController.rejoinShardLeaderElection(req.getParams());\n          } else {\n            log.warn(\"zkController is null in CoreAdminHandler.handleRequestInternal:REJOINLEADERELECTION. No action taken.\");\n          }\n          break;\n        case INVOKE:\n          handleInvoke(req, rsp);\n          break;\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa0876236f0bd8be403747120d248bdd42b75a96","date":1451844229,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleRequestInternal(SolrQueryRequest,SolrQueryResponse,CoreAdminAction).mjava","sourceNew":null,"sourceOld":"  protected void handleRequestInternal(SolrQueryRequest req, SolrQueryResponse rsp, CoreAdminAction action) throws Exception {\n    if (action != null) {\n      switch (action) {\n        case CREATE: {\n          this.handleCreateAction(req, rsp);\n          break;\n        }\n\n        case RENAME: {\n          this.handleRenameAction(req, rsp);\n          break;\n        }\n\n        case UNLOAD: {\n          this.handleUnloadAction(req, rsp);\n          break;\n        }\n\n        case STATUS: {\n          this.handleStatusAction(req, rsp);\n          break;\n\n        }\n\n        case PERSIST: {\n          this.handlePersistAction(req, rsp);\n          break;\n        }\n\n        case RELOAD: {\n          this.handleReloadAction(req, rsp);\n          break;\n        }\n\n        case SWAP: {\n          this.handleSwapAction(req, rsp);\n          break;\n        }\n\n        case MERGEINDEXES: {\n          this.handleMergeAction(req, rsp);\n          break;\n        }\n\n        case SPLIT: {\n          this.handleSplitAction(req, rsp);\n          break;\n        }\n\n        case PREPRECOVERY: {\n          this.handleWaitForStateAction(req, rsp);\n          break;\n        }\n\n        case REQUESTRECOVERY: {\n          this.handleRequestRecoveryAction(req, rsp);\n          break;\n        }\n\n        case REQUESTSYNCSHARD: {\n          this.handleRequestSyncAction(req, rsp);\n          break;\n        }\n\n        // todo : Can this be done by the regular RecoveryStrategy route?\n        case REQUESTAPPLYUPDATES: {\n          this.handleRequestApplyUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTBUFFERUPDATES:  {\n          this.handleRequestBufferUpdatesAction(req, rsp);\n          break;\n        }\n        case REQUESTSTATUS: {\n          this.handleRequestActionStatus(req, rsp);\n          break;\n        }\n        case OVERSEEROP:{\n          ZkController zkController = coreContainer.getZkController();\n          if(zkController != null){\n           String op = req.getParams().get(\"op\");\n           String electionNode = req.getParams().get(\"electionNode\");\n           if(electionNode != null) {\n             zkController.rejoinOverseerElection(electionNode, \"rejoinAtHead\".equals(op));\n           } else {\n             log.info(\"electionNode is required param\");\n           }\n          }\n          break;\n        }\n        default: {\n          this.handleCustomAction(req, rsp);\n          break;\n        }\n        case LOAD:\n          break;\n\n        case REJOINLEADERELECTION:\n          ZkController zkController = coreContainer.getZkController();\n\n          if (zkController != null) {\n            zkController.rejoinShardLeaderElection(req.getParams());\n          } else {\n            log.warn(\"zkController is null in CoreAdminHandler.handleRequestInternal:REJOINLEADERELECTION. No action taken.\");\n          }\n          break;\n        case INVOKE:\n          handleInvoke(req, rsp);\n          break;\n        case FORCEPREPAREFORLEADERSHIP: {\n          this.handleForcePrepareForLeadership(req, rsp);\n          break;\n        }\n      }\n    }\n    rsp.setHttpCaching(false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","5b15576cafd8b5d06857055c28f26912321937e3"],"7d996c36bf85996da326201b915c87d41449d7f5":["5b15576cafd8b5d06857055c28f26912321937e3"],"5b15576cafd8b5d06857055c28f26912321937e3":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":["5b15576cafd8b5d06857055c28f26912321937e3","7d996c36bf85996da326201b915c87d41449d7f5"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["4e6b620c271c84c0f14919eec7b90083b292ee51"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fa0876236f0bd8be403747120d248bdd42b75a96":["55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05"],"55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"4e6b620c271c84c0f14919eec7b90083b292ee51":["7d996c36bf85996da326201b915c87d41449d7f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa0876236f0bd8be403747120d248bdd42b75a96"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"7d996c36bf85996da326201b915c87d41449d7f5":["e57c73924f3b8c19defa62e96bfa34a4922d49c2","4e6b620c271c84c0f14919eec7b90083b292ee51"],"5b15576cafd8b5d06857055c28f26912321937e3":["5eb2511ababf862ea11e10761c70ee560cd84510","7d996c36bf85996da326201b915c87d41449d7f5","e57c73924f3b8c19defa62e96bfa34a4922d49c2"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":[],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["5eb2511ababf862ea11e10761c70ee560cd84510","5b15576cafd8b5d06857055c28f26912321937e3"],"fa0876236f0bd8be403747120d248bdd42b75a96":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05":["fa0876236f0bd8be403747120d248bdd42b75a96"],"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064":["55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05"],"4e6b620c271c84c0f14919eec7b90083b292ee51":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","e57c73924f3b8c19defa62e96bfa34a4922d49c2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}