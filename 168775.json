{"path":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"/dev/null","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {\n    // we will generate some illegal syntax regular expressions...\n    try {\n      new RegExp(regexp).toAutomaton();\n    } catch (Exception e) {\n      return;\n    }\n    \n    // we will also generate some undefined unicode queries\n    if (!UnicodeUtil.validUTF16String(regexp))\n      return;\n    \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    assertEquals(dumbDocs.totalHits, smartDocs.totalHits);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n    \n    assertEquals(\"for re:\" + regexp, dumbDocs.totalHits, smartDocs.totalHits);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {\n    // we will generate some illegal syntax regular expressions...\n    try {\n      new RegExp(regexp).toAutomaton();\n    } catch (Exception e) {\n      return;\n    }\n    \n    // we will also generate some undefined unicode queries\n    if (!UnicodeUtil.validUTF16String(regexp))\n      return;\n    \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    assertEquals(dumbDocs.totalHits, smartDocs.totalHits);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d6bb824137f6f5852490621a0a1004f9eef688c","date":1279212100,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n    \n    assertEquals(\"for re:\" + regexp, dumbDocs.totalHits, smartDocs.totalHits);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n    \n    assertEquals(\"for re:\" + regexp, dumbDocs.totalHits, smartDocs.totalHits);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"810a795efcabe031acf5c03c6924d366cbdb36dd","date":1280174569,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":["c5145e7af5e55022ec6ba083c0aef480e49e0d3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp));\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp));\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8dd2a69747e9f2922fd8b6970bd1661b26a692d","date":1291080135,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25833e37398c5210d7bddaca9d14de45e194439a","date":1294165371,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  private void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1bb50752d43a65ef1b623eabdb8e865983d3cd6","date":1304257984,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher1.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher1.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher1.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher.search(smart, 25);\n    TopDocs dumbDocs = searcher.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n   \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    \n    // we can't compare the two if automaton rewrites to a simpler enum.\n    // for example: \"a\\uda07\\udcc7?.*?\" gets rewritten to a simpler query:\n    // a\\uda07* prefixquery. Prefixquery then does the \"wrong\" thing, which\n    // isn't really wrong as the query was undefined to begin with... but not\n    // automatically comparable.\n    \n    // TODO: does this check even matter anymore?!\n    Terms terms = MultiFields.getTerms(searcher1.getIndexReader(), \"field\");\n    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))\n      return;\n    \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5145e7af5e55022ec6ba083c0aef480e49e0d3b","date":1319475599,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(fieldName, regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(fieldName, regexp), RegExp.NONE);\n   \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(\"field\", regexp), RegExp.NONE);\n   \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":["810a795efcabe031acf5c03c6924d366cbdb36dd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestRegexpRandom2#assertSame(String).mjava","sourceNew":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(fieldName, regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(fieldName, regexp), RegExp.NONE);\n   \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","sourceOld":"  /** check that the # of hits is the same as from a very\n   * simple regexpquery implementation.\n   */\n  protected void assertSame(String regexp) throws IOException {   \n    RegexpQuery smart = new RegexpQuery(new Term(fieldName, regexp), RegExp.NONE);\n    DumbRegexpQuery dumb = new DumbRegexpQuery(new Term(fieldName, regexp), RegExp.NONE);\n   \n    TopDocs smartDocs = searcher1.search(smart, 25);\n    TopDocs dumbDocs = searcher2.search(dumb, 25);\n\n    CheckHits.checkEqual(smart, smartDocs.scoreDocs, dumbDocs.scoreDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["3bb13258feba31ab676502787ab2e1779f129b7a","25833e37398c5210d7bddaca9d14de45e194439a"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["5f4e87790277826a2aea119328600dfb07761f32","810a795efcabe031acf5c03c6924d366cbdb36dd"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c5145e7af5e55022ec6ba083c0aef480e49e0d3b"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["70ad682703b8585f5d0a637efec044d57ec05efb","c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5f4e87790277826a2aea119328600dfb07761f32":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","3d6bb824137f6f5852490621a0a1004f9eef688c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"c1bb50752d43a65ef1b623eabdb8e865983d3cd6":["25833e37398c5210d7bddaca9d14de45e194439a"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"3d6bb824137f6f5852490621a0a1004f9eef688c":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"a3776dccca01c11e7046323cfad46a3b4a471233":["25833e37398c5210d7bddaca9d14de45e194439a","c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"810a795efcabe031acf5c03c6924d366cbdb36dd":["3d6bb824137f6f5852490621a0a1004f9eef688c"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","25833e37398c5210d7bddaca9d14de45e194439a"],"25833e37398c5210d7bddaca9d14de45e194439a":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"e8dd2a69747e9f2922fd8b6970bd1661b26a692d":["810a795efcabe031acf5c03c6924d366cbdb36dd"],"3bb13258feba31ab676502787ab2e1779f129b7a":["810a795efcabe031acf5c03c6924d366cbdb36dd","e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c5145e7af5e55022ec6ba083c0aef480e49e0d3b":["60ba444201d2570214b6fcf1d15600dc1a01f548"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["5f4e87790277826a2aea119328600dfb07761f32","3d6bb824137f6f5852490621a0a1004f9eef688c"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"5f4e87790277826a2aea119328600dfb07761f32":["3242a09f703274d3b9283f2064a1a33064b53a1b"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"c1bb50752d43a65ef1b623eabdb8e865983d3cd6":["135621f3a0670a9394eb563224a3b76cc4dddc0f","60ba444201d2570214b6fcf1d15600dc1a01f548","a3776dccca01c11e7046323cfad46a3b4a471233"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["c5145e7af5e55022ec6ba083c0aef480e49e0d3b"],"3d6bb824137f6f5852490621a0a1004f9eef688c":["5f4e87790277826a2aea119328600dfb07761f32","810a795efcabe031acf5c03c6924d366cbdb36dd"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"810a795efcabe031acf5c03c6924d366cbdb36dd":["3242a09f703274d3b9283f2064a1a33064b53a1b","e8dd2a69747e9f2922fd8b6970bd1661b26a692d","3bb13258feba31ab676502787ab2e1779f129b7a"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"3bb13258feba31ab676502787ab2e1779f129b7a":["70ad682703b8585f5d0a637efec044d57ec05efb"],"25833e37398c5210d7bddaca9d14de45e194439a":["70ad682703b8585f5d0a637efec044d57ec05efb","c1bb50752d43a65ef1b623eabdb8e865983d3cd6","a3776dccca01c11e7046323cfad46a3b4a471233","868da859b43505d9d2a023bfeae6dd0c795f5295"],"e8dd2a69747e9f2922fd8b6970bd1661b26a692d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","25833e37398c5210d7bddaca9d14de45e194439a","3bb13258feba31ab676502787ab2e1779f129b7a"],"c5145e7af5e55022ec6ba083c0aef480e49e0d3b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","a3776dccca01c11e7046323cfad46a3b4a471233","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}