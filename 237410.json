{"path":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","commits":[{"id":"43adc163640856c8b07e4cf1b2046c9af56d3ae7","date":1286989273,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\r\n  public void doTest() throws Exception {\r\n    del(\"*:*\");\r\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\r\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\r\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\r\n    );\r\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\r\n    );\r\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\r\n    );\r\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\r\n    );\r\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\r\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\r\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\r\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\r\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\r\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\r\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\r\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\r\n\r\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\r\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    String[] vals = new String[100];\r\n    for (int i=0; i<100; i++) {\r\n      vals[i] = \"test \" + i;\r\n    }\r\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\r\n\r\n    for (int i=100; i<150; i++) {\r\n      indexr(id, i);      \r\n    }\r\n\r\n    commit();\r\n\r\n    handle.clear();\r\n    handle.put(\"QTime\", SKIPVAL);\r\n    handle.put(\"timestamp\", SKIPVAL);\r\n\r\n    // random value sort\r\n    for (String f : fieldNames) {\r\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\r\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\r\n    }\r\n\r\n    // these queries should be exactly ordered and scores should exactly match\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\r\n    //is agnostic of request params.\r\n    handle.remove(\"maxScore\");\r\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\r\n\r\n    handle.put(\"highlighting\", UNORDERED);\r\n    handle.put(\"response\", UNORDERED);\r\n\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"quick\");\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\r\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\r\n\r\n    handle.put(\"score\", SKIPVAL);\r\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \r\n\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\r\n\r\n    // test faceting multiple things at once\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",t1);\r\n\r\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\r\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\r\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\r\n    ,\"facet.field\",t1\r\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\r\n    );\r\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\r\n\r\n    // test field that is valid in schema but missing in all shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\r\n    // test field that is valid in schema and missing in some shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\r\n\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\r\n\r\n    /*** TODO: the failure may come back in \"exception\"\r\n    try {\r\n      // test error produced for field that is invalid for schema\r\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\r\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\r\n    } catch (SolrServerException ex) {\r\n      // expected\r\n    }\r\n    ***/\r\n\r\n    // Try to get better coverage for refinement queries by turning off over requesting.\r\n    // This makes it much more likely that we may not get the top facet values and hence\r\n    // we turn of that checking.\r\n    handle.put(\"facet_fields\", SKIPVAL);    \r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    // check a complex key name\r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    handle.remove(\"facet_fields\");\r\n\r\n\r\n    // index the same document to two servers and make sure things\r\n    // don't blow up.\r\n    if (clients.size()>=2) {\r\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      for (int i=0; i<clients.size(); i++) {\r\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      }\r\n      commit();\r\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"*:*\", \"rows\",100);\r\n    }\r\n\r\n    // test debugging\r\n    handle.put(\"explain\", UNORDERED);\r\n    handle.put(\"debug\", UNORDERED);\r\n    handle.put(\"time\", SKIPVAL);\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\r\n\r\n    // TODO: This test currently fails because debug info is obtained only\r\n    // on shards with matches.\r\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\r\n\r\n    // Thread.sleep(10000000000L);\r\n    if (DEBUG) {\r\n      super.printLayout();\r\n    }\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\r\n  public void doTest() throws Exception {\r\n    del(\"*:*\");\r\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\r\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\r\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\r\n    );\r\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\r\n    );\r\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\r\n    );\r\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\r\n    );\r\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\r\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\r\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\r\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\r\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\r\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\r\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\r\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\r\n\r\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\r\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    String[] vals = new String[100];\r\n    for (int i=0; i<100; i++) {\r\n      vals[i] = \"test \" + i;\r\n    }\r\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\r\n\r\n    for (int i=100; i<150; i++) {\r\n      indexr(id, i);      \r\n    }\r\n\r\n    commit();\r\n\r\n    handle.clear();\r\n    handle.put(\"QTime\", SKIPVAL);\r\n    handle.put(\"timestamp\", SKIPVAL);\r\n\r\n    // random value sort\r\n    for (String f : fieldNames) {\r\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\r\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\r\n    }\r\n\r\n    // these queries should be exactly ordered and scores should exactly match\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\r\n    //is agnostic of request params.\r\n    handle.remove(\"maxScore\");\r\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\r\n\r\n    handle.put(\"highlighting\", UNORDERED);\r\n    handle.put(\"response\", UNORDERED);\r\n\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"quick\");\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\r\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\r\n\r\n    handle.put(\"score\", SKIPVAL);\r\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \r\n\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\r\n\r\n    // test faceting multiple things at once\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",t1);\r\n\r\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\r\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\r\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\r\n    ,\"facet.field\",t1\r\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\r\n    );\r\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\r\n\r\n    // test field that is valid in schema but missing in all shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\r\n    // test field that is valid in schema and missing in some shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\r\n\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\r\n\r\n    /*** TODO: the failure may come back in \"exception\"\r\n    try {\r\n      // test error produced for field that is invalid for schema\r\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\r\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\r\n    } catch (SolrServerException ex) {\r\n      // expected\r\n    }\r\n    ***/\r\n\r\n    // Try to get better coverage for refinement queries by turning off over requesting.\r\n    // This makes it much more likely that we may not get the top facet values and hence\r\n    // we turn of that checking.\r\n    handle.put(\"facet_fields\", SKIPVAL);    \r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    // check a complex key name\r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    handle.remove(\"facet_fields\");\r\n\r\n\r\n    // index the same document to two servers and make sure things\r\n    // don't blow up.\r\n    if (clients.size()>=2) {\r\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      for (int i=0; i<clients.size(); i++) {\r\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      }\r\n      commit();\r\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"*:*\", \"rows\",100);\r\n    }\r\n\r\n    // test debugging\r\n    handle.put(\"explain\", UNORDERED);\r\n    handle.put(\"debug\", UNORDERED);\r\n    handle.put(\"time\", SKIPVAL);\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\r\n\r\n    // TODO: This test currently fails because debug info is obtained only\r\n    // on shards with matches.\r\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\r\n\r\n    // Thread.sleep(10000000000L);\r\n    if (DEBUG) {\r\n      super.printLayout();\r\n    }\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\r\n  public void doTest() throws Exception {\r\n    del(\"*:*\");\r\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\r\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\r\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\r\n    );\r\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\r\n    );\r\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\r\n    );\r\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\r\n    );\r\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\r\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\r\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\r\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\r\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\r\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\r\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\r\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\r\n\r\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\r\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    String[] vals = new String[100];\r\n    for (int i=0; i<100; i++) {\r\n      vals[i] = \"test \" + i;\r\n    }\r\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\r\n\r\n    for (int i=100; i<150; i++) {\r\n      indexr(id, i);      \r\n    }\r\n\r\n    commit();\r\n\r\n    handle.clear();\r\n    handle.put(\"QTime\", SKIPVAL);\r\n    handle.put(\"timestamp\", SKIPVAL);\r\n\r\n    // random value sort\r\n    for (String f : fieldNames) {\r\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\r\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\r\n    }\r\n\r\n    // these queries should be exactly ordered and scores should exactly match\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\r\n    //is agnostic of request params.\r\n    handle.remove(\"maxScore\");\r\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\r\n\r\n    handle.put(\"highlighting\", UNORDERED);\r\n    handle.put(\"response\", UNORDERED);\r\n\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"quick\");\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\r\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\r\n\r\n    handle.put(\"score\", SKIPVAL);\r\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \r\n\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\r\n\r\n    // test faceting multiple things at once\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",t1);\r\n\r\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\r\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\r\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\r\n    ,\"facet.field\",t1\r\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\r\n    );\r\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\r\n\r\n    // test field that is valid in schema but missing in all shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\r\n    // test field that is valid in schema and missing in some shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\r\n\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\r\n\r\n    /*** TODO: the failure may come back in \"exception\"\r\n    try {\r\n      // test error produced for field that is invalid for schema\r\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\r\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\r\n    } catch (SolrServerException ex) {\r\n      // expected\r\n    }\r\n    ***/\r\n\r\n    // Try to get better coverage for refinement queries by turning off over requesting.\r\n    // This makes it much more likely that we may not get the top facet values and hence\r\n    // we turn of that checking.\r\n    handle.put(\"facet_fields\", SKIPVAL);    \r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    // check a complex key name\r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    handle.remove(\"facet_fields\");\r\n\r\n\r\n    // index the same document to two servers and make sure things\r\n    // don't blow up.\r\n    if (clients.size()>=2) {\r\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      for (int i=0; i<clients.size(); i++) {\r\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      }\r\n      commit();\r\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"*:*\", \"rows\",100);\r\n    }\r\n\r\n    // test debugging\r\n    handle.put(\"explain\", UNORDERED);\r\n    handle.put(\"debug\", UNORDERED);\r\n    handle.put(\"time\", SKIPVAL);\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\r\n\r\n    // TODO: This test currently fails because debug info is obtained only\r\n    // on shards with matches.\r\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\r\n\r\n    // Thread.sleep(10000000000L);\r\n    if (DEBUG) {\r\n      super.printLayout();\r\n    }\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bed62fe6383040eaff2ec720cdc55bb1462c61da","date":1296408595,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\r\n  public void doTest() throws Exception {\r\n    del(\"*:*\");\r\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\r\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\r\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\r\n    );\r\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\r\n    );\r\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\r\n    );\r\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\r\n    );\r\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\r\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\r\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\r\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\r\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\r\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\r\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\r\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\r\n\r\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\r\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    String[] vals = new String[100];\r\n    for (int i=0; i<100; i++) {\r\n      vals[i] = \"test \" + i;\r\n    }\r\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\r\n\r\n    for (int i=100; i<150; i++) {\r\n      indexr(id, i);      \r\n    }\r\n\r\n    commit();\r\n\r\n    handle.clear();\r\n    handle.put(\"QTime\", SKIPVAL);\r\n    handle.put(\"timestamp\", SKIPVAL);\r\n\r\n    // random value sort\r\n    for (String f : fieldNames) {\r\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\r\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\r\n    }\r\n\r\n    // these queries should be exactly ordered and scores should exactly match\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\r\n    //is agnostic of request params.\r\n    handle.remove(\"maxScore\");\r\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\r\n\r\n    handle.put(\"highlighting\", UNORDERED);\r\n    handle.put(\"response\", UNORDERED);\r\n\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"quick\");\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\r\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\r\n\r\n    handle.put(\"score\", SKIPVAL);\r\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \r\n\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\r\n\r\n    // test faceting multiple things at once\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",t1);\r\n\r\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\r\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\r\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\r\n    ,\"facet.field\",t1\r\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\r\n    );\r\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\r\n\r\n    // test field that is valid in schema but missing in all shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\r\n    // test field that is valid in schema and missing in some shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\r\n\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\r\n\r\n    /*** TODO: the failure may come back in \"exception\"\r\n    try {\r\n      // test error produced for field that is invalid for schema\r\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\r\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\r\n    } catch (SolrServerException ex) {\r\n      // expected\r\n    }\r\n    ***/\r\n\r\n    // Try to get better coverage for refinement queries by turning off over requesting.\r\n    // This makes it much more likely that we may not get the top facet values and hence\r\n    // we turn of that checking.\r\n    handle.put(\"facet_fields\", SKIPVAL);    \r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    // check a complex key name\r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    handle.remove(\"facet_fields\");\r\n\r\n\r\n    // index the same document to two servers and make sure things\r\n    // don't blow up.\r\n    if (clients.size()>=2) {\r\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      for (int i=0; i<clients.size(); i++) {\r\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      }\r\n      commit();\r\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"*:*\", \"rows\",100);\r\n    }\r\n\r\n    // test debugging\r\n    handle.put(\"explain\", UNORDERED);\r\n    handle.put(\"debug\", UNORDERED);\r\n    handle.put(\"time\", SKIPVAL);\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\r\n\r\n    // TODO: This test currently fails because debug info is obtained only\r\n    // on shards with matches.\r\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\r\n\r\n    // Thread.sleep(10000000000L);\r\n    if (DEBUG) {\r\n      super.printLayout();\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252","e19067e820b148e8dc0b240da4f2771cf7b68252","e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9001fdb834e467ef899e41c747c42b27b4d45099","date":1296775304,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252","e19067e820b148e8dc0b240da4f2771cf7b68252","e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\r\n  public void doTest() throws Exception {\r\n    del(\"*:*\");\r\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\r\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\r\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\r\n    );\r\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\r\n    );\r\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\r\n    );\r\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\r\n    );\r\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\r\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\r\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\r\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\r\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\r\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\r\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\r\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\r\n\r\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\r\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    String[] vals = new String[100];\r\n    for (int i=0; i<100; i++) {\r\n      vals[i] = \"test \" + i;\r\n    }\r\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\r\n\r\n    for (int i=100; i<150; i++) {\r\n      indexr(id, i);      \r\n    }\r\n\r\n    commit();\r\n\r\n    handle.clear();\r\n    handle.put(\"QTime\", SKIPVAL);\r\n    handle.put(\"timestamp\", SKIPVAL);\r\n\r\n    // random value sort\r\n    for (String f : fieldNames) {\r\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\r\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\r\n    }\r\n\r\n    // these queries should be exactly ordered and scores should exactly match\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\r\n    //is agnostic of request params.\r\n    handle.remove(\"maxScore\");\r\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\r\n\r\n    handle.put(\"highlighting\", UNORDERED);\r\n    handle.put(\"response\", UNORDERED);\r\n\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"quick\");\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\r\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\r\n\r\n    handle.put(\"score\", SKIPVAL);\r\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \r\n\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\r\n\r\n    // test faceting multiple things at once\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",t1);\r\n\r\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\r\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\r\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\r\n    ,\"facet.field\",t1\r\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\r\n    );\r\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\r\n\r\n    // test field that is valid in schema but missing in all shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\r\n    // test field that is valid in schema and missing in some shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\r\n\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\r\n\r\n    /*** TODO: the failure may come back in \"exception\"\r\n    try {\r\n      // test error produced for field that is invalid for schema\r\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\r\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\r\n    } catch (SolrServerException ex) {\r\n      // expected\r\n    }\r\n    ***/\r\n\r\n    // Try to get better coverage for refinement queries by turning off over requesting.\r\n    // This makes it much more likely that we may not get the top facet values and hence\r\n    // we turn of that checking.\r\n    handle.put(\"facet_fields\", SKIPVAL);    \r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    // check a complex key name\r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    handle.remove(\"facet_fields\");\r\n\r\n\r\n    // index the same document to two servers and make sure things\r\n    // don't blow up.\r\n    if (clients.size()>=2) {\r\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      for (int i=0; i<clients.size(); i++) {\r\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      }\r\n      commit();\r\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"*:*\", \"rows\",100);\r\n    }\r\n\r\n    // test debugging\r\n    handle.put(\"explain\", UNORDERED);\r\n    handle.put(\"debug\", UNORDERED);\r\n    handle.put(\"time\", SKIPVAL);\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\r\n\r\n    // TODO: This test currently fails because debug info is obtained only\r\n    // on shards with matches.\r\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\r\n\r\n    // Thread.sleep(10000000000L);\r\n    if (DEBUG) {\r\n      super.printLayout();\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\r\n  public void doTest() throws Exception {\r\n    del(\"*:*\");\r\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\r\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\r\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\r\n    );\r\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\r\n    );\r\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\r\n    );\r\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\r\n    );\r\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\r\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\r\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\r\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\r\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\r\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\r\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\r\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\r\n\r\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\r\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\r\n    String[] vals = new String[100];\r\n    for (int i=0; i<100; i++) {\r\n      vals[i] = \"test \" + i;\r\n    }\r\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\r\n\r\n    for (int i=100; i<150; i++) {\r\n      indexr(id, i);      \r\n    }\r\n\r\n    commit();\r\n\r\n    handle.clear();\r\n    handle.put(\"QTime\", SKIPVAL);\r\n    handle.put(\"timestamp\", SKIPVAL);\r\n\r\n    // random value sort\r\n    for (String f : fieldNames) {\r\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\r\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\r\n    }\r\n\r\n    // these queries should be exactly ordered and scores should exactly match\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\r\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\r\n    //is agnostic of request params.\r\n    handle.remove(\"maxScore\");\r\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\r\n\r\n    handle.put(\"highlighting\", UNORDERED);\r\n    handle.put(\"response\", UNORDERED);\r\n\r\n    handle.put(\"maxScore\", SKIPVAL);\r\n    query(\"q\",\"quick\");\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\r\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\r\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\r\n\r\n    handle.put(\"score\", SKIPVAL);\r\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\r\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\r\n            \"hl\",\"true\",\"hl.fl\",t1);\r\n\r\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \r\n\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\r\n\r\n    // test faceting multiple things at once\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",t1);\r\n\r\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\r\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\r\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\r\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\r\n    ,\"facet.field\",t1\r\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\r\n    );\r\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\r\n\r\n    // test field that is valid in schema but missing in all shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\r\n    // test field that is valid in schema and missing in some shards\r\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\r\n\r\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\r\n\r\n    /*** TODO: the failure may come back in \"exception\"\r\n    try {\r\n      // test error produced for field that is invalid for schema\r\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\r\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\r\n    } catch (SolrServerException ex) {\r\n      // expected\r\n    }\r\n    ***/\r\n\r\n    // Try to get better coverage for refinement queries by turning off over requesting.\r\n    // This makes it much more likely that we may not get the top facet values and hence\r\n    // we turn of that checking.\r\n    handle.put(\"facet_fields\", SKIPVAL);    \r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    // check a complex key name\r\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\r\n    handle.remove(\"facet_fields\");\r\n\r\n\r\n    // index the same document to two servers and make sure things\r\n    // don't blow up.\r\n    if (clients.size()>=2) {\r\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      for (int i=0; i<clients.size(); i++) {\r\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\r\n      }\r\n      commit();\r\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\r\n      query(\"q\",\"*:*\", \"rows\",100);\r\n    }\r\n\r\n    // test debugging\r\n    handle.put(\"explain\", UNORDERED);\r\n    handle.put(\"debug\", UNORDERED);\r\n    handle.put(\"time\", SKIPVAL);\r\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\r\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\r\n\r\n    // TODO: This test currently fails because debug info is obtained only\r\n    // on shards with matches.\r\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\r\n\r\n    // Thread.sleep(10000000000L);\r\n    if (DEBUG) {\r\n      super.printLayout();\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n    if (DEBUG) {\n      super.printLayout();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"43adc163640856c8b07e4cf1b2046c9af56d3ae7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["9001fdb834e467ef899e41c747c42b27b4d45099"],"9001fdb834e467ef899e41c747c42b27b4d45099":["bed62fe6383040eaff2ec720cdc55bb1462c61da"],"c26f00b574427b55127e869b935845554afde1fa":["9001fdb834e467ef899e41c747c42b27b4d45099","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","9001fdb834e467ef899e41c747c42b27b4d45099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["9001fdb834e467ef899e41c747c42b27b4d45099"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","43adc163640856c8b07e4cf1b2046c9af56d3ae7"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","9001fdb834e467ef899e41c747c42b27b4d45099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"bed62fe6383040eaff2ec720cdc55bb1462c61da":["43adc163640856c8b07e4cf1b2046c9af56d3ae7"]},"commit2Childs":{"43adc163640856c8b07e4cf1b2046c9af56d3ae7":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","4ecea1664e8617d82eca3b8055a3c37cb4da8511","bed62fe6383040eaff2ec720cdc55bb1462c61da"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"9001fdb834e467ef899e41c747c42b27b4d45099":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"bed62fe6383040eaff2ec720cdc55bb1462c61da":["9001fdb834e467ef899e41c747c42b27b4d45099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}