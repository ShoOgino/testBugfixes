{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock(int).mjava","commits":[{"id":"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b","date":1561536972,"type":1,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock(int leafCardinality) throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n          prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock(int).mjava","sourceNew":"    private void writeLeafBlock(int leafCardinality) throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(dataOut.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues, leafCardinality);\n      scratchOut.copyTo(dataOut);\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock(int leafCardinality) throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock(int).mjava","sourceNew":"    private void writeLeafBlock(int leafCardinality) throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, config.packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * config.packedBytesLength, maxPackedValue, 0, config.packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, config.packedBytesLength));\n      }\n      leafBlockFPs.add(dataOut.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * config.packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, config.bytesPerDim, leafValues, offset, offset + config.bytesPerDim);\n      if (prefix == -1) {\n        prefix = config.bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = config.packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = config.packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(config, leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, config.packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * config.packedBytesLength, leafCount * config.packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues, leafCardinality);\n      scratchOut.copyTo(dataOut);\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock(int leafCardinality) throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(dataOut.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues, leafCardinality);\n      scratchOut.copyTo(dataOut);\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["e70dbc563c35c0f6b6a0a545e65346166e6e5f2b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e70dbc563c35c0f6b6a0a545e65346166e6e5f2b"],"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}