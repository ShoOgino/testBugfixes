{"path":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#encodeExcValues(IntBuffer,int[],int,int,int).mjava","commits":[{"id":"824ab25acd22f2eca198755bafab3cb8b7878493","date":1341276186,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#encodeExcValues(IntBuffer,int[],int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  static void encodeExcValues(IntBuffer intBuffer, int[] values, int num, int perbytes, int byteOffset) {\n    if (num == 0)\n      return;\n    if (perbytes == 1) {\n      int curBytePos = byteOffset;\n      for (int i=0; i<num; ++i) {\n        int curIntPos = curBytePos / 4;\n        setBufferIntBits(intBuffer, curIntPos, (curBytePos & 3)*8, 8, values[i]);\n        curBytePos++;\n      }\n    } else if (perbytes == 2) {\n      int shortOffset = (byteOffset+1)/2;\n      int curIntPos = shortOffset/2;\n      int i=0;\n      if ((shortOffset & 1) == 1) {  // cut head to ensure remaining fit ints\n        setBufferIntBits(intBuffer, curIntPos++, 16, 16, values[i++]); \n      }\n      for (; i<num-1; i+=2) {\n        intBuffer.put(curIntPos++, (values[i+1]<<16) | values[i]);\n      }\n      if (i<num) {\n        intBuffer.put(curIntPos, values[i]); // cut tail, also clear high 16 bits\n      }\n    } else if (perbytes == 4) {\n      int curIntPos = (byteOffset+3) / 4;\n      for (int i=0; i<num; ++i) {\n        intBuffer.put(curIntPos++, values[i]);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b","date":1342134079,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#encodeExcValues(IntBuffer,int[],int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#encodeExcValues(IntBuffer,int[],int,int,int).mjava","sourceNew":"  /**\n   * Encode exception values into exception area.\n   * The width for each exception will be fixed as:\n   * 1, 2, or 4 byte(s).\n   */\n  static void encodeExcValues(IntBuffer intBuffer, int[] values, int num, int perbytes, int byteOffset) {\n    if (num == 0)\n      return;\n    if (perbytes == 1) {\n      int curBytePos = byteOffset;\n      for (int i=0; i<num; ++i) {\n        int curIntPos = curBytePos / 4;\n        setBufferIntBits(intBuffer, curIntPos, (curBytePos & 3)*8, 8, values[i]);\n        curBytePos++;\n      }\n    } else if (perbytes == 2) {\n      int shortOffset = (byteOffset+1)/2;\n      int curIntPos = shortOffset/2;\n      int i=0;\n      if ((shortOffset & 1) == 1) {  // cut head to ensure remaining fit ints\n        setBufferIntBits(intBuffer, curIntPos++, 16, 16, values[i++]); \n      }\n      for (; i<num-1; i+=2) {\n        intBuffer.put(curIntPos++, (values[i+1]<<16) | values[i]);\n      }\n      if (i<num) {\n        intBuffer.put(curIntPos, values[i]); // cut tail, also clear high 16 bits\n      }\n    } else if (perbytes == 4) {\n      int curIntPos = (byteOffset+3) / 4;\n      for (int i=0; i<num; ++i) {\n        intBuffer.put(curIntPos++, values[i]);\n      }\n    }\n  }\n\n","sourceOld":"  static void encodeExcValues(IntBuffer intBuffer, int[] values, int num, int perbytes, int byteOffset) {\n    if (num == 0)\n      return;\n    if (perbytes == 1) {\n      int curBytePos = byteOffset;\n      for (int i=0; i<num; ++i) {\n        int curIntPos = curBytePos / 4;\n        setBufferIntBits(intBuffer, curIntPos, (curBytePos & 3)*8, 8, values[i]);\n        curBytePos++;\n      }\n    } else if (perbytes == 2) {\n      int shortOffset = (byteOffset+1)/2;\n      int curIntPos = shortOffset/2;\n      int i=0;\n      if ((shortOffset & 1) == 1) {  // cut head to ensure remaining fit ints\n        setBufferIntBits(intBuffer, curIntPos++, 16, 16, values[i++]); \n      }\n      for (; i<num-1; i+=2) {\n        intBuffer.put(curIntPos++, (values[i+1]<<16) | values[i]);\n      }\n      if (i<num) {\n        intBuffer.put(curIntPos, values[i]); // cut tail, also clear high 16 bits\n      }\n    } else if (perbytes == 4) {\n      int curIntPos = (byteOffset+3) / 4;\n      for (int i=0; i<num; ++i) {\n        intBuffer.put(curIntPos++, values[i]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7250f5f8fbbaeebf817404fb2b3ce3b26161d5df","date":1343686506,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#encodeExcValues(IntBuffer,int[],int,int,int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Encode exception values into exception area.\n   * The width for each exception will be fixed as:\n   * 1, 2, or 4 byte(s).\n   */\n  static void encodeExcValues(IntBuffer intBuffer, int[] values, int num, int perbytes, int byteOffset) {\n    if (num == 0)\n      return;\n    if (perbytes == 1) {\n      int curBytePos = byteOffset;\n      for (int i=0; i<num; ++i) {\n        int curIntPos = curBytePos / 4;\n        setBufferIntBits(intBuffer, curIntPos, (curBytePos & 3)*8, 8, values[i]);\n        curBytePos++;\n      }\n    } else if (perbytes == 2) {\n      int shortOffset = (byteOffset+1)/2;\n      int curIntPos = shortOffset/2;\n      int i=0;\n      if ((shortOffset & 1) == 1) {  // cut head to ensure remaining fit ints\n        setBufferIntBits(intBuffer, curIntPos++, 16, 16, values[i++]); \n      }\n      for (; i<num-1; i+=2) {\n        intBuffer.put(curIntPos++, (values[i+1]<<16) | values[i]);\n      }\n      if (i<num) {\n        intBuffer.put(curIntPos, values[i]); // cut tail, also clear high 16 bits\n      }\n    } else if (perbytes == 4) {\n      int curIntPos = (byteOffset+3) / 4;\n      for (int i=0; i<num; ++i) {\n        intBuffer.put(curIntPos++, values[i]);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"824ab25acd22f2eca198755bafab3cb8b7878493":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7250f5f8fbbaeebf817404fb2b3ce3b26161d5df":["48d40647dc87c7b55ffe4d9dca73f63a3cebc58b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b":["824ab25acd22f2eca198755bafab3cb8b7878493"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"824ab25acd22f2eca198755bafab3cb8b7878493":["48d40647dc87c7b55ffe4d9dca73f63a3cebc58b"],"7250f5f8fbbaeebf817404fb2b3ce3b26161d5df":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["824ab25acd22f2eca198755bafab3cb8b7878493","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b":["7250f5f8fbbaeebf817404fb2b3ce3b26161d5df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7250f5f8fbbaeebf817404fb2b3ce3b26161d5df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}