{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","commits":[{"id":"bd0ef6574805f3cb9880e0983b7548a6aa933508","date":1315345052,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  public abstract void init(UpdateHandler uhandler, SolrCore core);\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","sourceOld":"  public abstract void init(UpdateHandler uhandler, SolrCore core);\n\n","bugFix":null,"bugIntro":["ff45be733a5a8b75c121109c056c3fc497139907","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","sourceOld":"  public abstract void init(UpdateHandler uhandler, SolrCore core);\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","sourceOld":"  public abstract void init(UpdateHandler uhandler, SolrCore core);\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4404c73eb4b69219f283c2f08a34a08bfdb6327f","date":1327615748,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","bugFix":null,"bugIntro":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"414ae8f6c01f0259255c532b2bd51b03000c2480","date":1329623863,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n\n    UpdateLog.RecentUpdates startingRecentUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingRecentUpdates.getVersions(numRecordsToKeep);\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingRecentUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingRecentUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n  }\n\n","bugFix":null,"bugIntro":["e99829242bceda4cf974ec0eb5d82d713615b3da"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a9e81d464930e5664da049442e2630d4b9b00d5","date":1330726364,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingRecentUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingRecentUpdates.getVersions(numRecordsToKeep);\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingRecentUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingRecentUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n\n    UpdateLog.RecentUpdates startingRecentUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingRecentUpdates.getVersions(numRecordsToKeep);\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingRecentUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingRecentUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingRecentUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingRecentUpdates.getVersions(numRecordsToKeep);\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingRecentUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingRecentUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog);\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n    newestLogOnStartup = oldLog;\n\n    versionInfo = new VersionInfo(uhandler, 256);\n\n    UpdateLog.RecentUpdates startingRecentUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingRecentUpdates.getVersions(numRecordsToKeep);\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingRecentUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingRecentUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e99829242bceda4cf974ec0eb5d82d713615b3da","date":1337646971,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingRecentUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingRecentUpdates.getVersions(numRecordsToKeep);\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingRecentUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingRecentUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n  }\n\n","bugFix":["414ae8f6c01f0259255c532b2bd51b03000c2480"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingRecentUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingRecentUpdates.getVersions(numRecordsToKeep);\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingRecentUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingRecentUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingRecentUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","date":1341327930,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9767265f21f7d1246b13dd7e73e8a4ad88b4384","date":1342986300,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(this, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":["ff45be733a5a8b75c121109c056c3fc497139907"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(this, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(this, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(uhandler, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"812be77cd3a7675a8ad97a5df58fa83f540e0698","date":1345576761,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(this, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n    \n    versionInfo = new VersionInfo(this, 256);\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4d5fc8284faca306256427bbbb86017a32002cf","date":1347055110,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ad158dd03dce94a7f19283d896946a0c8dbf8d","date":1347662441,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        f.delete();\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3fc0aa9a0ea3688c5b0fc6109449a008563be32","date":1355170793,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n    \n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n    \n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ab99a2487a34179af579c58aee0f6954a54173b","date":1370025444,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n    \n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n    \n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n    \n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n    \n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19","date":1400739326,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    // ulogDir from CoreDescriptor overrides\n    String ulogDir = core.getCoreDescriptor().getUlogDir();\n    if (ulogDir != null) {\n      dataDir = ulogDir;\n    }\n\n    if (dataDir == null || dataDir.length()==0) {\n      dataDir = core.getDataDir();\n    }\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal shutdown both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0a4f17ad1d2f38358efd6114311efd9c3f98444","date":1432133504,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, 256);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n    \n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = new TransactionLog( f, null, true );\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","date":1449051812,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    UpdateLog.RecentUpdates startingUpdates = getRecentUpdates();\n    try {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i=startingUpdates.deleteList.size()-1; i>=0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1,du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    } finally {\n      startingUpdates.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"268f09ed3a9a9b77003b15a5ae30386dc4e3721f","date":1483992000,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoMBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoMBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoMBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoMBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff45be733a5a8b75c121109c056c3fc497139907","date":1522855161,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n\n      versionInfo.reload();\n\n      // on a normal reopen, we currently shouldn't have to do anything\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n      startingOperation = startingUpdates.getLatestOperation();\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6afb0ba86024b96e8b34cfc2e15562239dc36360","date":1579768208,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id + \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id, \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":["4404c73eb4b69219f283c2f08a34a08bfdb6327f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir={}, next id={} this is a reopen...nothing else to do\", tlogDir, id);\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir={}, existing tlogs={}, next id={}\", tlogDir, Arrays.asList(tlogFiles), id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: {}\", e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", next id=\" + id + \" this is a reopen... nothing else to do.\");\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir=\" + tlogDir + \", existing tlogs=\" + Arrays.asList(tlogFiles) + \", next id=\" + id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \" + e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir={}, next id={} this is a reopen...nothing else to do\", tlogDir, id);\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir={}, existing tlogs={}, next id={}\", tlogDir, Arrays.asList(tlogFiles), id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: {}\", e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        @SuppressWarnings({\"unchecked\"})\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir={}, next id={} this is a reopen...nothing else to do\", tlogDir, id);\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir={}, existing tlogs={}, next id={}\", tlogDir, Arrays.asList(tlogFiles), id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: {}\", e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#init(UpdateHandler,SolrCore).mjava","sourceNew":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir={}, next id={} this is a reopen...nothing else to do\", tlogDir, id);\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir={}, existing tlogs={}, next id={}\", tlogDir, Arrays.asList(tlogFiles), id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: \", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        @SuppressWarnings({\"unchecked\"})\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","sourceOld":"  /* Note, when this is called, uhandler is not completely constructed.\n   * This must be called when a new log is created, or\n   * for an existing log whenever the core or update handler changes.\n   */\n  public void init(UpdateHandler uhandler, SolrCore core) {\n    dataDir = core.getUlogDir();\n\n    this.uhandler = uhandler;\n\n    if (dataDir.equals(lastDataDir)) {\n      versionInfo.reload();\n      core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n\n      if (debug) {\n        log.debug(\"UpdateHandler init: tlogDir={}, next id={} this is a reopen...nothing else to do\", tlogDir, id);\n      }\n      return;\n    }\n    lastDataDir = dataDir;\n    tlogDir = new File(dataDir, TLOG_NAME);\n    tlogDir.mkdirs();\n    tlogFiles = getLogList(tlogDir);\n    id = getLastLogId() + 1;   // add 1 since we will create a new log for the next update\n\n    if (debug) {\n      log.debug(\"UpdateHandler init: tlogDir={}, existing tlogs={}, next id={}\", tlogDir, Arrays.asList(tlogFiles), id);\n    }\n\n    String[] oldBufferTlog = getBufferLogList(tlogDir);\n    if (oldBufferTlog != null && oldBufferTlog.length != 0) {\n      existOldBufferLog = true;\n    }\n    TransactionLog oldLog = null;\n    for (String oldLogName : tlogFiles) {\n      File f = new File(tlogDir, oldLogName);\n      try {\n        oldLog = newTransactionLog(f, null, true);\n        addOldLog(oldLog, false);  // don't remove old logs on startup since more than one may be uncapped.\n      } catch (Exception e) {\n        SolrException.log(log, \"Failure to open existing log file (non fatal) \" + f, e);\n        deleteFile(f);\n      }\n    }\n\n    // Record first two logs (oldest first) at startup for potential tlog recovery.\n    // It's possible that at abnormal close both \"tlog\" and \"prevTlog\" were uncapped.\n    for (TransactionLog ll : logs) {\n      newestLogsOnStartup.addFirst(ll);\n      if (newestLogsOnStartup.size() >= 2) break;\n    }\n\n    try {\n      versionInfo = new VersionInfo(this, numVersionBuckets);\n    } catch (SolrException e) {\n      log.error(\"Unable to use updateLog: {}\", e.getMessage(), e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                              \"Unable to use updateLog: \" + e.getMessage(), e);\n    }\n\n    // TODO: these startingVersions assume that we successfully recover from all non-complete tlogs.\n    try (RecentUpdates startingUpdates = getRecentUpdates()) {\n      startingVersions = startingUpdates.getVersions(numRecordsToKeep);\n\n      // populate recent deletes list (since we can't get that info from the index)\n      for (int i = startingUpdates.deleteList.size() - 1; i >= 0; i--) {\n        DeleteUpdate du = startingUpdates.deleteList.get(i);\n        oldDeletes.put(new BytesRef(du.id), new LogPtr(-1, du.version));\n      }\n\n      // populate recent deleteByQuery commands\n      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {\n        Update update = startingUpdates.deleteByQueryList.get(i);\n        @SuppressWarnings({\"unchecked\"})\n        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);\n        long version = (Long) dbq.get(1);\n        String q = (String) dbq.get(2);\n        trackDeleteByQuery(q, version);\n      }\n\n    }\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.TLOG.toString(), this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["54ad158dd03dce94a7f19283d896946a0c8dbf8d","c3fc0aa9a0ea3688c5b0fc6109449a008563be32"],"001b25b42373b22a52f399dbf072f1224632e8e6":["aba371508186796cc6151d8223a5b4e16d02e26e","812be77cd3a7675a8ad97a5df58fa83f540e0698"],"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f":["e99829242bceda4cf974ec0eb5d82d713615b3da"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["6ab99a2487a34179af579c58aee0f6954a54173b","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["414ae8f6c01f0259255c532b2bd51b03000c2480","1a9e81d464930e5664da049442e2630d4b9b00d5"],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","4404c73eb4b69219f283c2f08a34a08bfdb6327f"],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"4404c73eb4b69219f283c2f08a34a08bfdb6327f":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b7605579001505896d48b07160075a5c8b8e128e":["849494cf2f3a96af5c8c84995108ddd8456fcd04","4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"b0a4f17ad1d2f38358efd6114311efd9c3f98444":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"1455c941cc4ce652efc776fc23471b0e499246f6":["ff45be733a5a8b75c121109c056c3fc497139907"],"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"812be77cd3a7675a8ad97a5df58fa83f540e0698":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["bd0ef6574805f3cb9880e0983b7548a6aa933508","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"ff45be733a5a8b75c121109c056c3fc497139907":["816521ebaad5add9cb96bb88c577394e2938c40b"],"aba371508186796cc6151d8223a5b4e16d02e26e":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["ff45be733a5a8b75c121109c056c3fc497139907","1455c941cc4ce652efc776fc23471b0e499246f6"],"3599646b4d4c346cf74d334813488b8b337b5bf5":["1a9e81d464930e5664da049442e2630d4b9b00d5","e99829242bceda4cf974ec0eb5d82d713615b3da"],"c3fc0aa9a0ea3688c5b0fc6109449a008563be32":["54ad158dd03dce94a7f19283d896946a0c8dbf8d"],"54ad158dd03dce94a7f19283d896946a0c8dbf8d":["e4d5fc8284faca306256427bbbb86017a32002cf"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"e99829242bceda4cf974ec0eb5d82d713615b3da":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","4404c73eb4b69219f283c2f08a34a08bfdb6327f"],"1a9e81d464930e5664da049442e2630d4b9b00d5":["414ae8f6c01f0259255c532b2bd51b03000c2480"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["bd0ef6574805f3cb9880e0983b7548a6aa933508","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"816521ebaad5add9cb96bb88c577394e2938c40b":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["6ab99a2487a34179af579c58aee0f6954a54173b"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["b0a4f17ad1d2f38358efd6114311efd9c3f98444"],"e4d5fc8284faca306256427bbbb86017a32002cf":["812be77cd3a7675a8ad97a5df58fa83f540e0698"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["1455c941cc4ce652efc776fc23471b0e499246f6"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["e99829242bceda4cf974ec0eb5d82d713615b3da","fb999ed3fc6e419b9104de9ebfe62ace27f31d5f"],"6ab99a2487a34179af579c58aee0f6954a54173b":["c3fc0aa9a0ea3688c5b0fc6109449a008563be32"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f"],"f592209545c71895260367152601e9200399776d":["ff45be733a5a8b75c121109c056c3fc497139907","1455c941cc4ce652efc776fc23471b0e499246f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"414ae8f6c01f0259255c532b2bd51b03000c2480":["4404c73eb4b69219f283c2f08a34a08bfdb6327f"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"001b25b42373b22a52f399dbf072f1224632e8e6":[],"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"740d649f013f07efbeb73ca854f106c60166e7c0":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","816521ebaad5add9cb96bb88c577394e2938c40b"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"4404c73eb4b69219f283c2f08a34a08bfdb6327f":["fd92b8bcc88e969302510acf77bd6970da3994c4","78a55f24d9b493c2a1cecf79f1d78279062b545b","414ae8f6c01f0259255c532b2bd51b03000c2480"],"b7605579001505896d48b07160075a5c8b8e128e":[],"b0a4f17ad1d2f38358efd6114311efd9c3f98444":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19":["b7605579001505896d48b07160075a5c8b8e128e","d0ef034a4f10871667ae75181537775ddcf8ade4"],"1455c941cc4ce652efc776fc23471b0e499246f6":["b70042a8a492f7054d480ccdd2be9796510d4327","6afb0ba86024b96e8b34cfc2e15562239dc36360","f592209545c71895260367152601e9200399776d"],"812be77cd3a7675a8ad97a5df58fa83f540e0698":["001b25b42373b22a52f399dbf072f1224632e8e6","e4d5fc8284faca306256427bbbb86017a32002cf"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"aba371508186796cc6151d8223a5b4e16d02e26e":["001b25b42373b22a52f399dbf072f1224632e8e6"],"ff45be733a5a8b75c121109c056c3fc497139907":["1455c941cc4ce652efc776fc23471b0e499246f6","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"54ad158dd03dce94a7f19283d896946a0c8dbf8d":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c3fc0aa9a0ea3688c5b0fc6109449a008563be32"],"c3fc0aa9a0ea3688c5b0fc6109449a008563be32":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6ab99a2487a34179af579c58aee0f6954a54173b"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"e99829242bceda4cf974ec0eb5d82d713615b3da":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","3599646b4d4c346cf74d334813488b8b337b5bf5","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":[],"1a9e81d464930e5664da049442e2630d4b9b00d5":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","3599646b4d4c346cf74d334813488b8b337b5bf5","e99829242bceda4cf974ec0eb5d82d713615b3da"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"816521ebaad5add9cb96bb88c577394e2938c40b":["ff45be733a5a8b75c121109c056c3fc497139907"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","b7605579001505896d48b07160075a5c8b8e128e","4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"e4d5fc8284faca306256427bbbb86017a32002cf":["54ad158dd03dce94a7f19283d896946a0c8dbf8d"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["740d649f013f07efbeb73ca854f106c60166e7c0"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"6ab99a2487a34179af579c58aee0f6954a54173b":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["b0a4f17ad1d2f38358efd6114311efd9c3f98444"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["4404c73eb4b69219f283c2f08a34a08bfdb6327f","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["812be77cd3a7675a8ad97a5df58fa83f540e0698","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"f592209545c71895260367152601e9200399776d":[],"414ae8f6c01f0259255c532b2bd51b03000c2480":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1a9e81d464930e5664da049442e2630d4b9b00d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","001b25b42373b22a52f399dbf072f1224632e8e6","37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","fd92b8bcc88e969302510acf77bd6970da3994c4","b7605579001505896d48b07160075a5c8b8e128e","b70042a8a492f7054d480ccdd2be9796510d4327","3599646b4d4c346cf74d334813488b8b337b5bf5","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","78a55f24d9b493c2a1cecf79f1d78279062b545b","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}