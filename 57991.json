{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","commits":[{"id":"d3102a9c9032617766c43974e7ec8b7a3148fb91","date":1519273763,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.now(); // todo how to play well with simulation framework?\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli(), true)))  {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c252a8291191876badb5f6235f62895d6e36b33e","date":1519309955,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","sourceNew":null,"sourceOld":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.now(); // todo how to play well with simulation framework?\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli(), true)))  {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1dec9417ffbde1f9d7317d78c151248cb8f6af88","date":1520019381,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.now(); // todo how to play well with simulation framework?\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli(), true)))  {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b6486136ec2c4fa54e33c828abf690144736bd8","date":1520351825,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","sourceNew":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.now(); // todo how to play well with simulation framework?\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.now(); // todo how to play well with simulation framework?\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli(), true)))  {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c6c0dad4932399aec99b4818086cb1772773916","date":1520515900,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","sourceNew":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    TimeSource timeSource = cloudManager.getTimeSource();\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.ofEpochMilli(\n        TimeUnit.NANOSECONDS.toMillis(timeSource.getEpochTime()));\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTime(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.now(); // todo how to play well with simulation framework?\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4404f65815cc874649176858833ace645e4ca172","date":1520945234,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","sourceNew":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    TimeSource timeSource = cloudManager.getTimeSource();\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.ofEpochMilli(\n        TimeUnit.NANOSECONDS.toMillis(timeSource.getEpochTime()));\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTime(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTime(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    TimeSource timeSource = cloudManager.getTimeSource();\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.ofEpochMilli(\n        TimeUnit.NANOSECONDS.toMillis(timeSource.getEpochTime()));\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), nextRunTime.toEpochMilli(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTime(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4412883c12067d8a4e2a354aa8adc58c32be1d6","date":1521129281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","sourceNew":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    TimeSource timeSource = cloudManager.getTimeSource();\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.ofEpochMilli(\n        TimeUnit.NANOSECONDS.toMillis(timeSource.getEpochTimeNs()));\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTimeNs(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTimeNs(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    TimeSource timeSource = cloudManager.getTimeSource();\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.ofEpochMilli(\n        TimeUnit.NANOSECONDS.toMillis(timeSource.getEpochTime()));\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTime(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTime(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","sourceNew":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.debug(\"ScheduledTrigger ran but was already closed\");\n        return;\n      }\n    }\n\n    TimeSource timeSource = cloudManager.getTimeSource();\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.ofEpochMilli(\n        TimeUnit.NANOSECONDS.toMillis(timeSource.getEpochTimeNs()));\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTimeNs(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTimeNs(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","sourceOld":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.warn(\"ScheduledTrigger ran but was already closed\");\n        throw new RuntimeException(\"Trigger has been closed\");\n      }\n    }\n\n    TimeSource timeSource = cloudManager.getTimeSource();\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.ofEpochMilli(\n        TimeUnit.NANOSECONDS.toMillis(timeSource.getEpochTimeNs()));\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTimeNs(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTimeNs(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","bugFix":["1dec9417ffbde1f9d7317d78c151248cb8f6af88"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ScheduledTrigger#run().mjava","sourceNew":null,"sourceOld":"  @Override\n  public void run() {\n    synchronized (this) {\n      if (isClosed) {\n        log.debug(\"ScheduledTrigger ran but was already closed\");\n        return;\n      }\n    }\n\n    TimeSource timeSource = cloudManager.getTimeSource();\n    DateMathParser dateMathParser = new DateMathParser(timeZone);\n    dateMathParser.setNow(new Date(lastRunAt.toEpochMilli()));\n    Instant nextRunTime, nextPlusGrace;\n    try {\n      Date next = dateMathParser.parseMath(everyStr);\n      dateMathParser.setNow(next);\n      nextPlusGrace = dateMathParser.parseMath(graceDurationStr).toInstant();\n      nextRunTime = next.toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to calculate next run time. lastRan: \" + lastRunAt.toString() + \" and date math string: \" + everyStr, e);\n    }\n\n    Instant now = Instant.ofEpochMilli(\n        TimeUnit.NANOSECONDS.toMillis(timeSource.getEpochTimeNs()));\n    AutoScaling.TriggerEventProcessor processor = processorRef.get();\n\n    if (now.isBefore(nextRunTime)) {\n      return; // it's not time yet\n    }\n    if (now.isAfter(nextPlusGrace)) {\n      // we are past time and we could not run per schedule so skip this event\n      if (log.isWarnEnabled())  {\n        log.warn(\"ScheduledTrigger was not able to run event at scheduled time: {}. Now: {}\",\n            nextRunTime, now);\n      }\n      // Even though we are skipping the event, we need to notify any listeners of the IGNORED stage\n      // so we create a dummy event with the ignored=true flag and ScheduledTriggers will do the rest\n      if (processor != null && processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTimeNs(),\n          preferredOp, now.toEpochMilli(), true))) {\n        lastRunAt = nextRunTime;\n        return;\n      }\n    }\n\n    if (processor != null)  {\n      if (log.isDebugEnabled()) {\n        log.debug(\"ScheduledTrigger {} firing registered processor for scheduled time {}, now={}\", name,\n            nextRunTime, now);\n      }\n      if (processor.process(new ScheduledEvent(getEventType(), getName(), timeSource.getTimeNs(),\n          preferredOp, now.toEpochMilli()))) {\n        lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n      }\n    } else  {\n      lastRunAt = nextRunTime; // set to nextRunTime instead of now to avoid drift\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9c6c0dad4932399aec99b4818086cb1772773916":["6b6486136ec2c4fa54e33c828abf690144736bd8"],"3f504512a03d978990cbff30db0522b354e846db":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"6b6486136ec2c4fa54e33c828abf690144736bd8":["1dec9417ffbde1f9d7317d78c151248cb8f6af88"],"c252a8291191876badb5f6235f62895d6e36b33e":["d3102a9c9032617766c43974e7ec8b7a3148fb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4404f65815cc874649176858833ace645e4ca172":["9c6c0dad4932399aec99b4818086cb1772773916"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["4404f65815cc874649176858833ace645e4ca172"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"1dec9417ffbde1f9d7317d78c151248cb8f6af88":["c252a8291191876badb5f6235f62895d6e36b33e"],"d3102a9c9032617766c43974e7ec8b7a3148fb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"9c6c0dad4932399aec99b4818086cb1772773916":["4404f65815cc874649176858833ace645e4ca172"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["3f504512a03d978990cbff30db0522b354e846db"],"6b6486136ec2c4fa54e33c828abf690144736bd8":["9c6c0dad4932399aec99b4818086cb1772773916"],"c252a8291191876badb5f6235f62895d6e36b33e":["1dec9417ffbde1f9d7317d78c151248cb8f6af88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3102a9c9032617766c43974e7ec8b7a3148fb91"],"4404f65815cc874649176858833ace645e4ca172":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"1dec9417ffbde1f9d7317d78c151248cb8f6af88":["6b6486136ec2c4fa54e33c828abf690144736bd8"],"d3102a9c9032617766c43974e7ec8b7a3148fb91":["c252a8291191876badb5f6235f62895d6e36b33e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}