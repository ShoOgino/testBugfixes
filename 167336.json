{"path":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","commits":[{"id":"d964716078bb50d7bcd908536ac068a86a771a5d","date":1219956864,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"/dev/null","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      return new ConstantScoreQuery(new WildcardFilter(((WildcardQuery)q).getTerm()));\n    }\n    return q;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fbdd7b4f937ad415349159b57272901047d49af4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbdd7b4f937ad415349159b57272901047d49af4","date":1242391451,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      wildcardQuery.setConstantScoreRewrite(true);\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      return new ConstantScoreQuery(new WildcardFilter(((WildcardQuery)q).getTerm()));\n    }\n    return q;\n  }\n\n","bugFix":["d964716078bb50d7bcd908536ac068a86a771a5d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c20f931a6f10b153366015604398a5eb7a4d17fa","date":1249615266,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      wildcardQuery.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      wildcardQuery.setConstantScoreRewrite(true);\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f66fbc07ecf3707c1ec81e35ca9e4df7ff22101a","date":1252677016,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      termStr = ReverseStringFilter.reverse(termStr + factory.getMarkerChar());\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      wildcardQuery.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      wildcardQuery.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":["32ca1a5456982c342df2a79ffa46397f3565bf5d","4ea4e0df42b1e8d32da66955b10083ed12ba7cc4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1facc74fa57831ffe3e76f17bc7dfe7bd2bef4c2","date":1256051637,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      termStr = ReverseStringFilter.reverse(termStr + factory.getMarkerChar());\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      termStr = ReverseStringFilter.reverse(termStr + factory.getMarkerChar());\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      wildcardQuery.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ea4e0df42b1e8d32da66955b10083ed12ba7cc4","date":1258992545,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      termStr = ReverseStringFilter.reverse(termStr + factory.getMarkerChar());\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":["f66fbc07ecf3707c1ec81e35ca9e4df7ff22101a"],"bugIntro":["32ca1a5456982c342df2a79ffa46397f3565bf5d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","pathOld":"src/java/org/apache/solr/search/SolrQueryParser#getWildcardQuery(String,String).mjava","sourceNew":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","sourceOld":"  protected Query getWildcardQuery(String field, String termStr) throws ParseException {\n    // *:* -> MatchAllDocsQuery\n    if (\"*\".equals(field) && \"*\".equals(termStr)) {\n      return newMatchAllDocsQuery();\n    }\n    \n    // can we use reversed wildcards in this field?\n    String type = schema.getFieldType(field).getTypeName();\n    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);\n    if (factory != null && factory.shouldReverse(termStr)) {\n      int len = termStr.length();\n      char[] chars = new char[len+1];\n      chars[0] = factory.getMarkerChar();      \n      termStr.getChars(0, len, chars, 1);\n      ReversedWildcardFilter.reverse(chars, 1, len);\n      termStr = new String(chars);\n    }\n    Query q = super.getWildcardQuery(field, termStr);\n    if (q instanceof WildcardQuery) {\n      // use a constant score query to avoid overflowing clauses\n      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());\n      return  wildcardQuery; \n    }\n    return q;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c20f931a6f10b153366015604398a5eb7a4d17fa":["fbdd7b4f937ad415349159b57272901047d49af4"],"fbdd7b4f937ad415349159b57272901047d49af4":["d964716078bb50d7bcd908536ac068a86a771a5d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ea4e0df42b1e8d32da66955b10083ed12ba7cc4":["1facc74fa57831ffe3e76f17bc7dfe7bd2bef4c2"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"f66fbc07ecf3707c1ec81e35ca9e4df7ff22101a":["c20f931a6f10b153366015604398a5eb7a4d17fa"],"d964716078bb50d7bcd908536ac068a86a771a5d":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"ad94625fb8d088209f46650c8097196fec67f00c":["4ea4e0df42b1e8d32da66955b10083ed12ba7cc4"],"1facc74fa57831ffe3e76f17bc7dfe7bd2bef4c2":["f66fbc07ecf3707c1ec81e35ca9e4df7ff22101a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c20f931a6f10b153366015604398a5eb7a4d17fa":["f66fbc07ecf3707c1ec81e35ca9e4df7ff22101a"],"fbdd7b4f937ad415349159b57272901047d49af4":["c20f931a6f10b153366015604398a5eb7a4d17fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ea4e0df42b1e8d32da66955b10083ed12ba7cc4":["ad94625fb8d088209f46650c8097196fec67f00c"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["d964716078bb50d7bcd908536ac068a86a771a5d"],"f66fbc07ecf3707c1ec81e35ca9e4df7ff22101a":["1facc74fa57831ffe3e76f17bc7dfe7bd2bef4c2"],"d964716078bb50d7bcd908536ac068a86a771a5d":["fbdd7b4f937ad415349159b57272901047d49af4"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"1facc74fa57831ffe3e76f17bc7dfe7bd2bef4c2":["4ea4e0df42b1e8d32da66955b10083ed12ba7cc4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}