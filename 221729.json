{"path":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","commits":[{"id":"c66158bb16e902a21272772f1b911f04b1a55abb","date":1424959524,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(String,String,int,boolean).mjava","sourceNew":"  private void init(int port) {\n\n    System.setProperty(\"solr.solr.home\", solrHome);\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n        System.clearProperty(\"hostPort\");\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n\n        System.setProperty(\"hostPort\", Integer.toString(lastPort));\n        if (solrConfigFilename != null) System.setProperty(\"solrconfig\",\n            solrConfigFilename);\n        if (schemaFilename != null) System.setProperty(\"schema\", \n            schemaFilename);\n        if (coreRootDirectory != null)\n          System.setProperty(\"coreRootDirectory\", coreRootDirectory);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n\n        dispatchFilter = root.addFilter(SolrDispatchFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n\n        if (solrConfigFilename != null) System.clearProperty(\"solrconfig\");\n        if (schemaFilename != null) System.clearProperty(\"schema\");\n        System.clearProperty(\"solr.solr.home\");\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","sourceOld":"  private void init(String solrHome, String context, int port, boolean stopAtShutdown) {\n    this.context = context;\n    this.solrHome = solrHome;\n    this.stopAtShutdown = stopAtShutdown;\n\n    System.setProperty(\"solr.solr.home\", solrHome);\n    \n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(stopAtShutdown);\n    \n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final boolean useSsl = sslConfig == null ? false : sslConfig.isSSLMode();\n      final SslContextFactory sslcontext = new SslContextFactory(false);\n      sslInit(useSsl, sslcontext);\n\n      ServerConnector connector;\n      if (useSsl) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n        System.clearProperty(\"hostPort\");\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n        lastPort = getFirstConnectorPort();\n        System.setProperty(\"hostPort\", Integer.toString(lastPort));\n        if (solrConfigFilename != null) System.setProperty(\"solrconfig\",\n            solrConfigFilename);\n        if (schemaFilename != null) System.setProperty(\"schema\", \n            schemaFilename);\n        if (coreRootDirectory != null)\n          System.setProperty(\"coreRootDirectory\", coreRootDirectory);\n//        SolrDispatchFilter filter = new SolrDispatchFilter();\n//        FilterHolder fh = new FilterHolder(filter);\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        if (extraRequestFilters != null) {\n          extraFilters = new LinkedList<>();\n          for (Class filterClass : extraRequestFilters.keySet()) {\n            extraFilters.add(root.addFilter(filterClass, extraRequestFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n          }\n        }\n        for (ServletHolder servletHolder : extraServlets.keySet()) {\n          String pathSpec = extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.addFilter(SolrDispatchFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        if (solrConfigFilename != null) System.clearProperty(\"solrconfig\");\n        if (schemaFilename != null) System.clearProperty(\"schema\");\n        System.clearProperty(\"solr.solr.home\");\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bc766d645fa848f86c381c7f6acf2c881c99399","date":1425549246,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n\n        dispatchFilter = root.addFilter(SolrDispatchFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    System.setProperty(\"solr.solr.home\", solrHome);\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n        System.clearProperty(\"hostPort\");\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n\n        System.setProperty(\"hostPort\", Integer.toString(lastPort));\n        if (solrConfigFilename != null) System.setProperty(\"solrconfig\",\n            solrConfigFilename);\n        if (schemaFilename != null) System.setProperty(\"schema\", \n            schemaFilename);\n        if (coreRootDirectory != null)\n          System.setProperty(\"coreRootDirectory\", coreRootDirectory);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n\n        dispatchFilter = root.addFilter(SolrDispatchFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n\n        if (solrConfigFilename != null) System.clearProperty(\"solrconfig\");\n        if (schemaFilename != null) System.clearProperty(\"schema\");\n        System.clearProperty(\"solr.solr.home\");\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"/dev/null","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n\n        dispatchFilter = root.addFilter(SolrDispatchFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b26da217d39e3ab00cf66ccad07eb82d19d520a","date":1442427418,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n\n        dispatchFilter = root.addFilter(SolrDispatchFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","bugFix":["d5b778829b5b506ab02023b2f4ba58aef5d7f0fd","c66158bb16e902a21272772f1b911f04b1a55abb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"845803a90b690b8bcccfd3f331016cf5fdfd6da3","date":1448976188,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(2048);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"49bee3135753f5a129ce7f3eef9151efbb39fb27","date":1452189117,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(2048);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee3cfd8b5963fd43298f37bd602c8bf77896e72e","date":1455656470,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n    root.addFilter(GzipFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST));\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n\n  }\n\n","bugFix":null,"bugIntro":["e6973041cca0d55346d6eee6e18e1419b9540a10","a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(10000);\n    qtp.setIdleTimeout((int) TimeUnit.SECONDS.toMillis(5));\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(0);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n\n      // Enable Low Resources Management\n      LowResourceMonitor lowResources = new LowResourceMonitor(server);\n      lowResources.setLowResourcesIdleTimeout(1500);\n      lowResources.setMaxConnections(10000);\n      server.addBean(lowResources);\n\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"269c5aee1e7702d512e3f45bf1f01afd15a2af5f","date":1516133643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(BaseHolder.Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        lastPort = getFirstConnectorPort();\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(lastPort));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d62f7f419840d73a16d064ad5789dfcbea744e43","date":1532972772,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        logger.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n        \n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setStopTimeout((int) TimeUnit.MINUTES.toMillis(1));\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      \n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":["859081acf00749f5dd462772c571d611d4a4d2db","2c007e7c4cf8c55bc2a5884e315123afaaeec87f","02dcd6f50ddccf04be4560b3acbd93a90a932d32"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n        \n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n      \n      ServerConnector connector;\n      if (sslcontext != null) {\n        HttpConfiguration configuration = new HttpConfiguration();\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        connector = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n            new HttpConnectionFactory(configuration));\n      } else {\n        connector = new ServerConnector(server, new HttpConnectionFactory());\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory());\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n        \n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n        \n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n    \n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n        \n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(root);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":["ee3cfd8b5963fd43298f37bd602c8bf77896e72e","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should \n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n        \n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n    \n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b348431b834ecbda752134f7d345c754e283815","date":1567051312,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Class<? extends Filter> filterClass : config.extraFilters.keySet()) {\n          extraFilters.add(root.addFilter(filterClass, config.extraFilters.get(filterClass),\n              EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (ServletHolder servletHolder : config.extraServlets.keySet()) {\n          String pathSpec = config.extraServlets.get(servletHolder);\n          root.addServlet(servletHolder, pathSpec);\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de1f4f89cef95d8efa9877bdd893d1b542c9b140","date":1574241654,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        root.addFilter(dispatchFilter, \"*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // for some reason, there must be a servlet for this to get applied\n    root.addServlet(Servlet404.class, \"/*\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d108aa89491a609eab235fa2459dc3ab78b4c838","date":1576707883,"type":3,"author":"Matthias Krueger","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ea0f43f20834b3c8930e074b144aba27a935fee8","date":1576814747,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory.Server sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":["c66158bb16e902a21272772f1b911f04b1a55abb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c66470e527299cc148ad0b3441d08dfb7cb9e03","date":1576859740,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory.Server sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setSoLingerTime(-1);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setSoLingerTime(-1);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6973041cca0d55346d6eee6e18e1419b9540a10","date":1582240461,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#init(int).mjava","sourceNew":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory.Server sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(23); // https://github.com/eclipse/jetty.project/issues/4191\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","sourceOld":"  private void init(int port) {\n\n    QueuedThreadPool qtp = new QueuedThreadPool();\n    qtp.setMaxThreads(THREAD_POOL_MAX_THREADS);\n    qtp.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n    qtp.setReservedThreads(0);\n    server = new Server(qtp);\n    server.manage(qtp);\n    server.setStopAtShutdown(config.stopAtShutdown);\n\n    if (System.getProperty(\"jetty.testMode\") != null) {\n      // if this property is true, then jetty will be configured to use SSL\n      // leveraging the same system properties as java to specify\n      // the keystore/truststore if they are set unless specific config\n      // is passed via the constructor.\n      //\n      // This means we will use the same truststore, keystore (and keys) for\n      // the server as well as any client actions taken by this JVM in\n      // talking to that server, but for the purposes of testing that should\n      // be good enough\n      final SslContextFactory.Server sslcontext = SSLConfig.createContextFactory(config.sslConfig);\n\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector;\n      if (sslcontext != null) {\n        configuration.setSecureScheme(\"https\");\n        configuration.addCustomizer(new SecureRequestCustomizer());\n        HttpConnectionFactory http1ConnectionFactory = new HttpConnectionFactory(configuration);\n\n        if (config.onlyHttp1 || !Constants.JRE_IS_MINIMUM_JAVA9) {\n          connector = new ServerConnector(server, new SslConnectionFactory(sslcontext,\n              http1ConnectionFactory.getProtocol()),\n              http1ConnectionFactory);\n        } else {\n          sslcontext.setCipherComparator(HTTP2Cipher.COMPARATOR);\n\n          connector = new ServerConnector(server);\n          SslConnectionFactory sslConnectionFactory = new SslConnectionFactory(sslcontext, \"alpn\");\n          connector.addConnectionFactory(sslConnectionFactory);\n          connector.setDefaultProtocol(sslConnectionFactory.getProtocol());\n\n          HTTP2ServerConnectionFactory http2ConnectionFactory = new HTTP2ServerConnectionFactory(configuration);\n\n          ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory(\n              http2ConnectionFactory.getProtocol(),\n              http1ConnectionFactory.getProtocol());\n          alpn.setDefaultProtocol(http1ConnectionFactory.getProtocol());\n          connector.addConnectionFactory(alpn);\n          connector.addConnectionFactory(http1ConnectionFactory);\n          connector.addConnectionFactory(http2ConnectionFactory);\n        }\n      } else {\n        if (config.onlyHttp1) {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n        } else {\n          connector = new ServerConnector(server, new HttpConnectionFactory(configuration),\n              new HTTP2CServerConnectionFactory(configuration));\n        }\n      }\n\n      connector.setReuseAddress(true);\n      connector.setPort(port);\n      connector.setHost(\"127.0.0.1\");\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      connector.setStopTimeout(0);\n      server.setConnectors(new Connector[] {connector});\n      server.setSessionIdManager(new DefaultSessionIdManager(server, new Random()));\n    } else {\n      HttpConfiguration configuration = new HttpConfiguration();\n      ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(configuration));\n      connector.setPort(port);\n      connector.setIdleTimeout(THREAD_POOL_MAX_IDLE_TIME_MS);\n      server.setConnectors(new Connector[] {connector});\n    }\n\n    HandlerWrapper chain;\n    {\n    // Initialize the servlets\n    final ServletContextHandler root = new ServletContextHandler(server, config.context, ServletContextHandler.SESSIONS);\n\n    server.addLifeCycleListener(new LifeCycle.Listener() {\n\n      @Override\n      public void lifeCycleStopping(LifeCycle arg0) {\n      }\n\n      @Override\n      public void lifeCycleStopped(LifeCycle arg0) {}\n\n      @Override\n      public void lifeCycleStarting(LifeCycle arg0) {\n\n      }\n\n      @Override\n      public void lifeCycleStarted(LifeCycle arg0) {\n\n        jettyPort = getFirstConnectorPort();\n        int port = jettyPort;\n        if (proxyPort != -1) port = proxyPort;\n        nodeProperties.setProperty(\"hostPort\", Integer.toString(port));\n        nodeProperties.setProperty(\"hostContext\", config.context);\n\n        root.getServletContext().setAttribute(SolrDispatchFilter.PROPERTIES_ATTRIBUTE, nodeProperties);\n        root.getServletContext().setAttribute(SolrDispatchFilter.SOLRHOME_ATTRIBUTE, solrHome);\n\n        log.info(\"Jetty properties: {}\", nodeProperties);\n\n        debugFilter = root.addFilter(DebugFilter.class, \"/*\", EnumSet.of(DispatcherType.REQUEST) );\n        extraFilters = new LinkedList<>();\n        for (Map.Entry<Class<? extends Filter>, String> entry : config.extraFilters.entrySet()) {\n          extraFilters.add(root.addFilter(entry.getKey(), entry.getValue(), EnumSet.of(DispatcherType.REQUEST)));\n        }\n\n        for (Map.Entry<ServletHolder, String> entry : config.extraServlets.entrySet()) {\n          root.addServlet(entry.getKey(), entry.getValue());\n        }\n        dispatchFilter = root.getServletHandler().newFilterHolder(Source.EMBEDDED);\n        dispatchFilter.setHeldClass(SolrDispatchFilter.class);\n        dispatchFilter.setInitParameter(\"excludePatterns\", excludePatterns);\n        // Map dispatchFilter in same path as in web.xml\n        root.addFilter(dispatchFilter, \"/*\", EnumSet.of(DispatcherType.REQUEST));\n\n        synchronized (JettySolrRunner.this) {\n          waitOnSolr = true;\n          JettySolrRunner.this.notify();\n        }\n      }\n\n      @Override\n      public void lifeCycleFailure(LifeCycle arg0, Throwable arg1) {\n        System.clearProperty(\"hostPort\");\n      }\n    });\n    // Default servlet as a fall-through\n    root.addServlet(Servlet404.class, \"/\");\n    chain = root;\n    }\n\n    chain = injectJettyHandlers(chain);\n\n    if(config.enableV2) {\n      RewriteHandler rwh = new RewriteHandler();\n      rwh.setHandler(chain);\n      rwh.setRewriteRequestURI(true);\n      rwh.setRewritePathInfo(false);\n      rwh.setOriginalPathAttribute(\"requestedPath\");\n      rwh.addRule(new RewritePatternRule(\"/api/*\", \"/solr/____v2\"));\n      chain = rwh;\n    }\n    GzipHandler gzipHandler = new GzipHandler();\n    gzipHandler.setHandler(chain);\n\n    gzipHandler.setMinGzipSize(0);\n    gzipHandler.setCheckGzExists(false);\n    gzipHandler.setCompressionLevel(-1);\n    gzipHandler.setExcludedAgentPatterns(\".*MSIE.6\\\\.0.*\");\n    gzipHandler.setIncludedMethods(\"GET\");\n\n    server.setHandler(gzipHandler);\n  }\n\n","bugFix":["ee3cfd8b5963fd43298f37bd602c8bf77896e72e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3b348431b834ecbda752134f7d345c754e283815":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"b94236357aaa22b76c10629851fe4e376e0cea82":["859081acf00749f5dd462772c571d611d4a4d2db","269c5aee1e7702d512e3f45bf1f01afd15a2af5f"],"d62f7f419840d73a16d064ad5789dfcbea744e43":["84f20f331d8001864545c7021812d8c6509c7593"],"ee3cfd8b5963fd43298f37bd602c8bf77896e72e":["49bee3135753f5a129ce7f3eef9151efbb39fb27"],"9b26da217d39e3ab00cf66ccad07eb82d19d520a":["9bc766d645fa848f86c381c7f6acf2c881c99399"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["d62f7f419840d73a16d064ad5789dfcbea744e43"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["c66158bb16e902a21272772f1b911f04b1a55abb"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"84f20f331d8001864545c7021812d8c6509c7593":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":["de1f4f89cef95d8efa9877bdd893d1b542c9b140","ea0f43f20834b3c8930e074b144aba27a935fee8"],"49bee3135753f5a129ce7f3eef9151efbb39fb27":["845803a90b690b8bcccfd3f331016cf5fdfd6da3"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9bc766d645fa848f86c381c7f6acf2c881c99399"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["3b348431b834ecbda752134f7d345c754e283815"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e6973041cca0d55346d6eee6e18e1419b9540a10":["ea0f43f20834b3c8930e074b144aba27a935fee8"],"d108aa89491a609eab235fa2459dc3ab78b4c838":["de1f4f89cef95d8efa9877bdd893d1b542c9b140"],"ea0f43f20834b3c8930e074b144aba27a935fee8":["d108aa89491a609eab235fa2459dc3ab78b4c838"],"de1f4f89cef95d8efa9877bdd893d1b542c9b140":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"859081acf00749f5dd462772c571d611d4a4d2db":["ee3cfd8b5963fd43298f37bd602c8bf77896e72e"],"269c5aee1e7702d512e3f45bf1f01afd15a2af5f":["859081acf00749f5dd462772c571d611d4a4d2db"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"845803a90b690b8bcccfd3f331016cf5fdfd6da3":["9b26da217d39e3ab00cf66ccad07eb82d19d520a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e6973041cca0d55346d6eee6e18e1419b9540a10"],"c66158bb16e902a21272772f1b911f04b1a55abb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b0b597c65628ca9e73913a07e81691f8229bae35":["3b348431b834ecbda752134f7d345c754e283815","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"3b348431b834ecbda752134f7d345c754e283815":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","b0b597c65628ca9e73913a07e81691f8229bae35"],"b94236357aaa22b76c10629851fe4e376e0cea82":["84f20f331d8001864545c7021812d8c6509c7593"],"d62f7f419840d73a16d064ad5789dfcbea744e43":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ee3cfd8b5963fd43298f37bd602c8bf77896e72e":["859081acf00749f5dd462772c571d611d4a4d2db"],"9b26da217d39e3ab00cf66ccad07eb82d19d520a":["845803a90b690b8bcccfd3f331016cf5fdfd6da3"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["9b26da217d39e3ab00cf66ccad07eb82d19d520a","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"84f20f331d8001864545c7021812d8c6509c7593":["d62f7f419840d73a16d064ad5789dfcbea744e43"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":[],"49bee3135753f5a129ce7f3eef9151efbb39fb27":["ee3cfd8b5963fd43298f37bd602c8bf77896e72e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["de1f4f89cef95d8efa9877bdd893d1b542c9b140","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","c66158bb16e902a21272772f1b911f04b1a55abb"],"e6973041cca0d55346d6eee6e18e1419b9540a10":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d108aa89491a609eab235fa2459dc3ab78b4c838":["ea0f43f20834b3c8930e074b144aba27a935fee8"],"ea0f43f20834b3c8930e074b144aba27a935fee8":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","e6973041cca0d55346d6eee6e18e1419b9540a10"],"de1f4f89cef95d8efa9877bdd893d1b542c9b140":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","d108aa89491a609eab235fa2459dc3ab78b4c838"],"859081acf00749f5dd462772c571d611d4a4d2db":["b94236357aaa22b76c10629851fe4e376e0cea82","269c5aee1e7702d512e3f45bf1f01afd15a2af5f"],"269c5aee1e7702d512e3f45bf1f01afd15a2af5f":["b94236357aaa22b76c10629851fe4e376e0cea82"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["3b348431b834ecbda752134f7d345c754e283815"],"845803a90b690b8bcccfd3f331016cf5fdfd6da3":["49bee3135753f5a129ce7f3eef9151efbb39fb27"],"c66158bb16e902a21272772f1b911f04b1a55abb":["9bc766d645fa848f86c381c7f6acf2c881c99399"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}