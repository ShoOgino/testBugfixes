{"path":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","commits":[{"id":"6eecfe8d494cb2e3ead94e9cdb9381bfe4993dcd","date":1438089844,"type":0,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","pathOld":"/dev/null","sourceNew":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    SolrCache cache = (SolrCache) h.getCore().getInfoRegistry()\n        .get(\"queryResultCache\");\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(cache, statPre);\n    }\n\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(cache, statPre);\n    }\n\n    {\n      NamedList statPre = cache.getStatistics();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(cache, statPre);\n\n      statPre = cache.getStatistics();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(cache, statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n      try {\n        h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.substring(0, score.length() - 1) +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n        );\n        fail(\"excpecting exception\");\n      } catch (IllegalArgumentException e) {\n        assertTrue(e.getMessage().contains(\"ScoreMode\"));\n      }\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    cache.clear();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b5dc820d653826ca85d4355563ef001f156c644","date":1438618492,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","sourceNew":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    SolrCache cache = (SolrCache) h.getCore().getInfoRegistry()\n        .get(\"queryResultCache\");\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(cache, statPre);\n    }\n\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(cache, statPre);\n    }\n\n    {\n      NamedList statPre = cache.getStatistics();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(cache, statPre);\n\n      statPre = cache.getStatistics();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(cache, statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    cache.clear();\n  }\n\n","sourceOld":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    SolrCache cache = (SolrCache) h.getCore().getInfoRegistry()\n        .get(\"queryResultCache\");\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(cache, statPre);\n    }\n\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(cache, statPre);\n    }\n\n    {\n      NamedList statPre = cache.getStatistics();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(cache, statPre);\n\n      statPre = cache.getStatistics();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(cache, statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n      try {\n        h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.substring(0, score.length() - 1) +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n        );\n        fail(\"excpecting exception\");\n      } catch (IllegalArgumentException e) {\n        assertTrue(e.getMessage().contains(\"ScoreMode\"));\n      }\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    cache.clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","sourceNew":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    MetricsMap mm = (MetricsMap)metrics.get(\"CACHE.searcher.queryResultCache\");\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","sourceOld":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    SolrCache cache = (SolrCache) h.getCore().getInfoRegistry()\n        .get(\"queryResultCache\");\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(cache, statPre);\n    }\n\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(cache, statPre);\n    }\n\n    {\n      NamedList statPre = cache.getStatistics();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(cache, statPre);\n\n      statPre = cache.getStatistics();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(cache, statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    cache.clear();\n  }\n\n","bugFix":null,"bugIntro":["bfc52860e6d13d034226a760813c59d984c6817a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","sourceNew":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    MetricsMap mm = (MetricsMap)metrics.get(\"CACHE.searcher.queryResultCache\");\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","sourceOld":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    SolrCache cache = (SolrCache) h.getCore().getInfoRegistry()\n        .get(\"queryResultCache\");\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(cache, statPre);\n    }\n\n    {\n      final NamedList statPre = cache.getStatistics();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(cache, statPre);\n    }\n\n    {\n      NamedList statPre = cache.getStatistics();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(cache, statPre);\n\n      statPre = cache.getStatistics();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(cache, statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    cache.clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfc52860e6d13d034226a760813c59d984c6817a","date":1522229027,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","sourceNew":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    MetricsMap mm = (MetricsMap)((SolrMetricManager.GaugeWrapper)metrics.get(\"CACHE.searcher.queryResultCache\")).getGauge();\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","sourceOld":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    MetricsMap mm = (MetricsMap)metrics.get(\"CACHE.searcher.queryResultCache\");\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","bugFix":["816521ebaad5add9cb96bb88c577394e2938c40b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43564cbb30b064675027cfb569564e8531096e97","date":1522334265,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","sourceNew":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    MetricsMap mm = (MetricsMap)((SolrMetricManager.GaugeWrapper)metrics.get(\"CACHE.searcher.queryResultCache\")).getGauge();\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","sourceOld":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    MetricsMap mm = (MetricsMap)metrics.get(\"CACHE.searcher.queryResultCache\");\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00a778ad8ad6c2c04607538d2f36fee001239eef","date":1576657013,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","sourceNew":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    @SuppressWarnings(\"rawtypes\")\n    MetricsMap mm = (MetricsMap)((SolrMetricManager.GaugeWrapper)metrics.get(\"CACHE.searcher.queryResultCache\")).getGauge();\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    @SuppressWarnings(\"rawtypes\")\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","sourceOld":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    MetricsMap mm = (MetricsMap)((SolrMetricManager.GaugeWrapper)metrics.get(\"CACHE.searcher.queryResultCache\")).getGauge();\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"246314af59d76a47fccc31e9494eefee01ec9c00","date":1576657955,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/TestScoreJoinQPScore#testCacheHit().mjava","sourceNew":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    @SuppressWarnings(\"rawtypes\")\n    MetricsMap mm = (MetricsMap)((SolrMetricManager.GaugeWrapper)metrics.get(\"CACHE.searcher.queryResultCache\")).getGauge();\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    @SuppressWarnings(\"rawtypes\")\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","sourceOld":"  public void testCacheHit() throws Exception {\n    indexDataForScorring();\n\n    Map<String, Metric> metrics = h.getCoreContainer().getMetricManager().registry(h.getCore().getCoreMetricManager().getRegistryName()).getMetrics();\n\n    MetricsMap mm = (MetricsMap)((SolrMetricManager.GaugeWrapper)metrics.get(\"CACHE.searcher.queryResultCache\")).getGauge();\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHitOrInsert(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n      h.query(req(\"q\", \"{!join from=movieId_s to=id score=Avg}title:first\", \"fl\", \"id\", \"omitHeader\", \"true\"));\n      assertHit(mm.getValue(), statPre);\n    }\n\n    {\n      Map<String,Object> statPre = mm.getValue();\n\n      Random r = random();\n      boolean changed = false;\n      boolean x = false;\n      String from = (x = r.nextBoolean()) ? \"id\" : \"movieId_s\";\n      changed |= x;\n      String to = (x = r.nextBoolean()) ? \"movieId_s\" : \"id\";\n      changed |= x;\n      String score = (x = r.nextBoolean()) ? not(ScoreMode.Avg).name() : \"Avg\";\n      changed |= x;\n      /* till SOLR-7814\n       * String boost = (x = r.nextBoolean()) ? \"23\" : \"1\";\n      changed |= x; */\n      String q = (!changed) ? (r.nextBoolean() ? \"title:first^67\" : \"title:night\") : \"title:first\";\n\n      final String resp = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to +\n              \" score=\" + score + \n              //\" b=\" + boost + \n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertInsert(mm.getValue(), statPre);\n\n      statPre = mm.getValue();\n      final String repeat = h.query(req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + score.toLowerCase(Locale.ROOT) +\n          //\" b=\" + boost\n              \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\")\n      );\n      assertHit(mm.getValue(), statPre);\n\n      assertEquals(\"lowercase shouldn't change anything\", resp, repeat);\n\n        final String aMod = score.substring(0, score.length() - 1);\n        assertQEx(\"exception on \"+aMod, \"ScoreMode\", \n            req(\"q\", \"{!join from=\" + from + \" to=\" + to + \" score=\" + aMod +\n                \"}\" + q, \"fl\", \"id\", \"omitHeader\", \"true\"), \n                SolrException.ErrorCode.BAD_REQUEST);\n    }\n    // this queries are not overlap, with other in this test case. \n    // however it might be better to extract this method into the separate suite\n    // for a while let's nuke a cache content, in case of repetitions\n    SolrCache cache = (SolrCache)h.getCore().getInfoRegistry().get(\"queryResultCache\");\n    cache.clear();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["0b5dc820d653826ca85d4355563ef001f156c644"],"246314af59d76a47fccc31e9494eefee01ec9c00":["43564cbb30b064675027cfb569564e8531096e97","00a778ad8ad6c2c04607538d2f36fee001239eef"],"0b5dc820d653826ca85d4355563ef001f156c644":["6eecfe8d494cb2e3ead94e9cdb9381bfe4993dcd"],"bfc52860e6d13d034226a760813c59d984c6817a":["816521ebaad5add9cb96bb88c577394e2938c40b"],"43564cbb30b064675027cfb569564e8531096e97":["816521ebaad5add9cb96bb88c577394e2938c40b","bfc52860e6d13d034226a760813c59d984c6817a"],"6eecfe8d494cb2e3ead94e9cdb9381bfe4993dcd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"00a778ad8ad6c2c04607538d2f36fee001239eef":["43564cbb30b064675027cfb569564e8531096e97"],"816521ebaad5add9cb96bb88c577394e2938c40b":["0b5dc820d653826ca85d4355563ef001f156c644"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["00a778ad8ad6c2c04607538d2f36fee001239eef"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"246314af59d76a47fccc31e9494eefee01ec9c00":[],"0b5dc820d653826ca85d4355563ef001f156c644":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","816521ebaad5add9cb96bb88c577394e2938c40b"],"bfc52860e6d13d034226a760813c59d984c6817a":["43564cbb30b064675027cfb569564e8531096e97"],"43564cbb30b064675027cfb569564e8531096e97":["246314af59d76a47fccc31e9494eefee01ec9c00","00a778ad8ad6c2c04607538d2f36fee001239eef"],"6eecfe8d494cb2e3ead94e9cdb9381bfe4993dcd":["0b5dc820d653826ca85d4355563ef001f156c644"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6eecfe8d494cb2e3ead94e9cdb9381bfe4993dcd"],"00a778ad8ad6c2c04607538d2f36fee001239eef":["246314af59d76a47fccc31e9494eefee01ec9c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"816521ebaad5add9cb96bb88c577394e2938c40b":["bfc52860e6d13d034226a760813c59d984c6817a","43564cbb30b064675027cfb569564e8531096e97"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","246314af59d76a47fccc31e9494eefee01ec9c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}