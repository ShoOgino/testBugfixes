{"path":"solr/src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","pathOld":"/dev/null","sourceNew":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      int posInc = t.getPositionIncrement();\n      origPosIncrement += posInc;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        t.setPositionIncrement(origPosIncrement);\n        return t;\n      }\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if ((type & lastType)==0) {  // no overlap in character type\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if (stemEnglishPossessive != 0 && ((lastType & ALPHA)!=0)) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n            } else if ((lastType & UPPER)!=0 && (type & ALPHA)!=0) {\n              // UPPER->letter: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              t.setPositionIncrement(origPosIncrement);\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              t.setPositionIncrement(origPosIncrement);              \n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n\n        // if this token had a \"normal\" gap of 1, remove it.\n        if (posInc==1) origPosIncrement-=1;\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/analysis/WordDelimiterFilter#next(Token).mjava","sourceNew":null,"sourceOld":"  public final Token next(Token in) throws IOException {\n\n    // check the queue first\n    if (queuePos<queue.size()) {\n      return queue.get(queuePos++);\n    }\n\n    // reset the queue if it had been previously used\n    if (queuePos!=0) {\n      queuePos=0;\n      queue.clear();\n    }\n\n\n    // optimize for the common case: assume there will be\n    // no subwords (just a simple word)\n    //\n    // Would it actually be faster to check for the common form\n    // of isLetter() isLower()*, and then backtrack if it doesn't match?\n\n    int origPosIncrement = 0;\n    Token t;\n    while(true) {\n      // t is either returned, or a new token is made from it, so it should\n      // be safe to use the next(Token) method.\n      t = input.next(in);\n      if (t == null) return null;\n\n      char [] termBuffer = t.termBuffer();\n      int len = t.termLength();\n      int start=0;\n      if (len ==0) continue;\n\n      int posInc = t.getPositionIncrement();\n      origPosIncrement += posInc;\n\n      //skip protected tokens\n      if (protWords != null && protWords.contains(termBuffer, 0, len)) {\n        t.setPositionIncrement(origPosIncrement);\n        return t;\n      }\n\n      // Avoid calling charType more than once for each char (basically\n      // avoid any backtracking).\n      // makes code slightly more difficult, but faster.\n      int ch=termBuffer[start];\n      int type=charType(ch);\n\n      int numWords=0;\n\n      while (start< len) {\n        // first eat delimiters at the start of this subword\n        while ((type & SUBWORD_DELIM)!=0 && ++start< len) {\n          ch=termBuffer[start];\n          type=charType(ch);\n        }\n\n        int pos=start;\n\n        // save the type of the first char of the subword\n        // as a way to tell what type of subword token this is (number, word, etc)\n        int firstType=type;\n        int lastType=type;  // type of the previously read char\n\n\n        while (pos< len) {\n\n          if ((type & lastType)==0) {  // no overlap in character type\n            // check and remove \"'s\" from the end of a token.\n            // the pattern to check for is\n            //   ALPHA \"'\" (\"s\"|\"S\") (SUBWORD_DELIM | END)\n            if (stemEnglishPossessive != 0 && ((lastType & ALPHA)!=0)) {\n              if (ch=='\\'' && pos+1< len\n                      && (termBuffer[pos+1]=='s' || termBuffer[pos+1]=='S'))\n              {\n                int subWordEnd=pos;\n                if (pos+2>= len) {\n                  // end of string detected after \"'s\"\n                  pos+=2;\n                } else {\n                  // make sure that a delimiter follows \"'s\"\n                  int ch2 = termBuffer[pos+2];\n                  int type2 = charType(ch2);\n                  if ((type2 & SUBWORD_DELIM)!=0) {\n                    // if delimiter, move position pointer\n                    // to it (skipping over \"'s\"\n                    ch=ch2;\n                    type=type2;\n                    pos+=2;\n                  }\n                }\n\n                queue.add(newTok(t,start,subWordEnd));\n                if ((firstType & ALPHA)!=0) numWords++;\n                break;\n              }\n            }\n\n            // For case changes, only split on a transition from\n            // lower to upper case, not vice-versa.\n            // That will correctly handle the\n            // case of a word starting with a capital (won't split).\n            // It will also handle pluralization of\n            // an uppercase word such as FOOs (won't split).\n\n            if (splitOnCaseChange == 0 && \n                (lastType & ALPHA) != 0 && (type & ALPHA) != 0) {\n              // ALPHA->ALPHA: always ignore if case isn't considered.\n            } else if ((lastType & UPPER)!=0 && (type & ALPHA)!=0) {\n              // UPPER->letter: Don't split\n            } else if(splitOnNumerics == 0 &&\n                ( ((lastType &  ALPHA) != 0 && (type & DIGIT) != 0) || ((lastType &  DIGIT) != 0 && (type & ALPHA) != 0) ) ) {\n              // ALPHA->NUMERIC, NUMERIC->ALPHA :Don't split\n            } else {\n              // NOTE: this code currently assumes that only one flag\n              // is set for each character now, so we don't have\n              // to explicitly check for all the classes of transitions\n              // listed below.\n\n              // LOWER->UPPER\n              // ALPHA->NUMERIC\n              // NUMERIC->ALPHA\n              // *->DELIMITER\n              queue.add(newTok(t,start,pos));\n              if ((firstType & ALPHA)!=0) numWords++;\n              break;\n            }\n          }\n\n          if (++pos >= len) {\n            if (start==0) {\n              // the subword is the whole original token, so\n              // return it unchanged.\n              t.setPositionIncrement(origPosIncrement);\n              return t;\n            }\n\n            // optimization... if this is the only token,\n            // return it immediately.\n            if (queue.size()==0 && preserveOriginal == 0) {\n              // just adjust the text w/o changing the rest\n              // of the original token\n              t.setTermBuffer(termBuffer, start, len-start);\n              t.setStartOffset(t.startOffset() + start);\n              t.setPositionIncrement(origPosIncrement);              \n              return t;\n            }\n\n            Token newtok = newTok(t,start,pos);\n\n            queue.add(newtok);\n            if ((firstType & ALPHA)!=0) numWords++;\n            break;\n          }\n\n          lastType = type;\n          ch = termBuffer[pos];\n          type = charType(ch);\n        }\n\n        // start of the next subword is the current position\n        start=pos;\n      }\n\n      // System.out.println(\"##########TOKEN=\" + s + \" ######### WORD DELIMITER QUEUE=\" + str(queue));\n\n      final int numtok = queue.size();\n\n      // We reached the end of the current token.\n      // If the queue is empty, we should continue by reading\n      // the next token\n      if (numtok==0) {\n        // the token might have been all delimiters, in which\n        // case return it if we're meant to preserve it\n        if (preserveOriginal != 0) {\n          return t;\n        }\n\n        // if this token had a \"normal\" gap of 1, remove it.\n        if (posInc==1) origPosIncrement-=1;\n        continue;\n      }\n\n      // if number of tokens is 1, there are no catenations to be done.\n      if (numtok==1) {\n        break;\n      }\n\n\n      final int numNumbers = numtok - numWords;\n\n      // check conditions under which the current token\n      // queue may be used as-is (no catenations needed)\n      if (catenateAll==0    // no \"everything\" to catenate\n        && (catenateWords==0 || numWords<=1)   // no words to catenate\n        && (catenateNumbers==0 || numNumbers<=1)    // no numbers to catenate\n        && (generateWordParts!=0 || numWords==0)  // word generation is on\n        && (generateNumberParts!=0 || numNumbers==0)) // number generation is on\n      {\n        break;\n      }\n\n\n      // swap queue and the temporary working list, then clear the\n      // queue in preparation for adding all combinations back to it.\n      ArrayList<Token> tmp=tlist;\n      tlist=queue;\n      queue=tmp;\n      queue.clear();\n\n      if (numWords==0) {\n        // all numbers\n        addCombos(tlist,0,numtok,generateNumberParts!=0,catenateNumbers!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (numNumbers==0) {\n        // all words\n        addCombos(tlist,0,numtok,generateWordParts!=0,catenateWords!=0 || catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      } else if (generateNumberParts==0 && generateWordParts==0 && catenateNumbers==0 && catenateWords==0) {\n        // catenate all *only*\n        // OPT:could be optimized to add to current queue...\n        addCombos(tlist,0,numtok,false,catenateAll!=0, 1);\n        if (queue.size() > 0 || preserveOriginal!=0) break; else continue;\n      }\n\n      //\n      // Find all adjacent tokens of the same type.\n      //\n      Token tok = tlist.get(0);\n      boolean isWord = (tokType(tok) & ALPHA) != 0;\n      boolean wasWord=isWord;\n\n      for(int i=0; i<numtok;) {\n          int j;\n          for (j=i+1; j<numtok; j++) {\n            wasWord=isWord;\n            tok = tlist.get(j);\n            isWord = (tokType(tok) & ALPHA) != 0;\n            if (isWord != wasWord) break;\n          }\n          if (wasWord) {\n            addCombos(tlist,i,j,generateWordParts!=0,catenateWords!=0,1);\n          } else {\n            addCombos(tlist,i,j,generateNumberParts!=0,catenateNumbers!=0,1);\n          }\n          i=j;\n      }\n\n      // take care catenating all subwords\n      if (catenateAll!=0) {\n        addCombos(tlist,0,numtok,false,true,0);\n      }\n\n      // NOTE: in certain cases, queue may be empty (for instance, if catenate\n      // and generate are both set to false).  Only exit the loop if the queue\n      // is not empty.\n      if (queue.size() > 0 || preserveOriginal!=0) break;\n    }\n\n    // System.out.println(\"##########AFTER COMBINATIONS:\"+ str(queue));\n\n    if (preserveOriginal != 0) {\n      queuePos = 0;\n      if (queue.size() > 0) {\n        // overlap first token with the original\n        queue.get(0).setPositionIncrement(0);\n      }\n      return t;  // return the original\n    } else {\n      queuePos=1;\n      Token tok = queue.get(0);\n      tok.setPositionIncrement(origPosIncrement);\n      return tok;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}