{"path":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) throws IOException \n  {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) throws IOException \n  {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) throws IOException \n  {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) throws IOException \n  {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) throws IOException \n  {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) throws IOException \n  {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) throws IOException \n  {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":["2070bf73ffa1039a505000f99ea245884ff19e11"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) throws IOException \n  {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<Object>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<Object>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add(NAME, ti.getThreadName());\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add(NAME, ti.getLockOwnerName());\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add(NAME, ti.getThreadName());\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add(NAME, ti.getLockOwnerName());\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add( \"name\", ti.getThreadName() );\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add( \"name\", ti.getLockOwnerName() );\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( ID, tid );\n    info.add(NAME, ti.getThreadName());\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add(NAME, ti.getLockOwnerName());\n      owner.add( ID, ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add(NAME, ti.getThreadName());\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add(NAME, ti.getLockOwnerName());\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( ID, tid );\n    info.add(NAME, ti.getThreadName());\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add(NAME, ti.getLockOwnerName());\n      owner.add( ID, ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( \"id\", tid );\n    info.add(NAME, ti.getThreadName());\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add(NAME, ti.getLockOwnerName());\n      owner.add( \"id\", ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43773b467552e527b377ad41ba33808922816e42","date":1594321982,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ThreadDumpHandler#getThreadInfo(ThreadInfo,ThreadMXBean).mjava","sourceNew":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( ID, tid );\n    info.add(NAME, ti.getThreadName());\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      // TODO: this is redundent with lock-waiting below .. deprecate & remove\n      // TODO: (but first needs UI change)\n      info.add( \"lock\", ti.getLockName() );\n    }\n    { final LockInfo lockInfo = ti.getLockInfo();\n      if (null != lockInfo) {\n        final SimpleOrderedMap<Object> lock = new SimpleOrderedMap<>();\n        info.add(\"lock-waiting\", lock);\n        lock.add(NAME, lockInfo.toString());\n        if (-1 == ti.getLockOwnerId() && null == ti.getLockOwnerName()) {\n          lock.add(\"owner\", null );\n        } else {\n          final SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n          lock.add(\"owner\", owner);\n          owner.add(NAME, ti.getLockOwnerName());\n          owner.add( ID, ti.getLockOwnerId() );\n        }\n      }\n    }\n    { final LockInfo[] synchronizers = ti.getLockedSynchronizers();\n      if (0 < synchronizers.length) {\n        final List<String> locks = new ArrayList<>(synchronizers.length);\n        info.add(\"synchronizers-locked\", locks);\n        for (LockInfo sync : synchronizers) {\n          locks.add(sync.toString());\n        }\n      }\n    }\n    { final LockInfo[] monitors = ti.getLockedMonitors();\n      if (0 < monitors.length) {\n        final List<String> locks = new ArrayList<>(monitors.length);\n        info.add(\"monitors-locked\", locks);\n        for (LockInfo monitor : monitors) {\n          locks.add(monitor.toString());\n        }\n      }\n    }\n    \n    \n\n    \n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","sourceOld":"  private static SimpleOrderedMap<Object> getThreadInfo( ThreadInfo ti, ThreadMXBean tmbean ) {\n    SimpleOrderedMap<Object> info = new SimpleOrderedMap<>();\n    long tid = ti.getThreadId();\n\n    info.add( ID, tid );\n    info.add(NAME, ti.getThreadName());\n    info.add( \"state\", ti.getThreadState().toString() );\n    \n    if (ti.getLockName() != null) {\n      info.add( \"lock\", ti.getLockName() );\n    }\n    if (ti.isSuspended()) {\n      info.add( \"suspended\", true );\n    }\n    if (ti.isInNative()) {\n      info.add( \"native\", true );\n    }\n    \n    if (tmbean.isThreadCpuTimeSupported()) {\n      info.add( \"cpuTime\", formatNanos(tmbean.getThreadCpuTime(tid)) );\n      info.add( \"userTime\", formatNanos(tmbean.getThreadUserTime(tid)) );\n    }\n\n    if (ti.getLockOwnerName() != null) {\n      SimpleOrderedMap<Object> owner = new SimpleOrderedMap<>();\n      owner.add(NAME, ti.getLockOwnerName());\n      owner.add( ID, ti.getLockOwnerId() );\n    }\n    \n    // Add the stack trace\n    int i=0;\n    String[] trace = new String[ti.getStackTrace().length];\n    for( StackTraceElement ste : ti.getStackTrace()) {\n      trace[i++] = ste.toString();\n    }\n    info.add( \"stackTrace\", trace );\n    return info;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"43773b467552e527b377ad41ba33808922816e42":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["c26f00b574427b55127e869b935845554afde1fa","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","1390137e395d2f07f9ba5b8c43d293befe84d563"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["c26f00b574427b55127e869b935845554afde1fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["43773b467552e527b377ad41ba33808922816e42"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1390137e395d2f07f9ba5b8c43d293befe84d563","d2638f781be724518ff6c2263d14a48cf6e68017"],"43773b467552e527b377ad41ba33808922816e42":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c26f00b574427b55127e869b935845554afde1fa":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["43773b467552e527b377ad41ba33808922816e42"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["6d2dadc1f5ca8703d8659f4964961f9967935d75","e5fa6615014cd2288fe930f8c8bb726f9504961d","d2638f781be724518ff6c2263d14a48cf6e68017"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e5fa6615014cd2288fe930f8c8bb726f9504961d","fe33227f6805edab2036cbb80645cc4e2d1fa424","d2638f781be724518ff6c2263d14a48cf6e68017","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}