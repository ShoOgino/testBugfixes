{"path":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        //System.out.println(\"doc=\"+doc);\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e36f19452726fab77a51c5fcb61fd7d9ee91068","date":1280918442,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0638cded77f278f667f33442bd4a132d484068d1","date":1286833084,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-5f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          \n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final ReaderContext[] context = getLeaves(s);\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer(indexSearcher.getTopReaderContext(), true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer(indexSearcher.getTopReaderContext(), true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705","date":1294747166,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final ReaderContext[] context = getLeaves(s);\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer(indexSearcher.getTopReaderContext(), true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer(indexSearcher.getTopReaderContext(), true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"323f871ffe96b871d8c534a614be60751bb023c2","date":1294820532,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dc63f17f42c64d6ccc8c361cfcdf074f115f770c","date":1294930751,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"790e1fde4caa765b3faaad3fbcd25c6973450336","date":1296689245,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":null,"sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private IndexReader reader;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(reader, true, false);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(IndexReader reader, int docBase) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          Weight w = q.weight(new IndexSearcher(previousReader));\n          Scorer scorer = w.scorer(previousReader, true, false);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n\n        this.reader = lastReader[0] = reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      Weight w = q.weight(new IndexSearcher(previousReader));\n      Scorer scorer = w.scorer(previousReader, true, false);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":5,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"323f871ffe96b871d8c534a614be60751bb023c2":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","0638cded77f278f667f33442bd4a132d484068d1"],"dc63f17f42c64d6ccc8c361cfcdf074f115f770c":["323f871ffe96b871d8c534a614be60751bb023c2"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["790e1fde4caa765b3faaad3fbcd25c6973450336"],"790e1fde4caa765b3faaad3fbcd25c6973450336":["dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["0638cded77f278f667f33442bd4a132d484068d1","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["0638cded77f278f667f33442bd4a132d484068d1"],"0e36f19452726fab77a51c5fcb61fd7d9ee91068":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["868da859b43505d9d2a023bfeae6dd0c795f5295","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"0638cded77f278f667f33442bd4a132d484068d1":["0e36f19452726fab77a51c5fcb61fd7d9ee91068"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"323f871ffe96b871d8c534a614be60751bb023c2":["dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","0e36f19452726fab77a51c5fcb61fd7d9ee91068"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"dc63f17f42c64d6ccc8c361cfcdf074f115f770c":["790e1fde4caa765b3faaad3fbcd25c6973450336","868da859b43505d9d2a023bfeae6dd0c795f5295"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"790e1fde4caa765b3faaad3fbcd25c6973450336":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"0e36f19452726fab77a51c5fcb61fd7d9ee91068":["0638cded77f278f667f33442bd4a132d484068d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["323f871ffe96b871d8c534a614be60751bb023c2"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"0638cded77f278f667f33442bd4a132d484068d1":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","29ef99d61cda9641b6250bf9567329a6e65f901d","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}