{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/BackupCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName = message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.cloudManager.getClusterStateProvider().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String backupName = message.getStr(NAME);\n    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);\n\n    Instant startTime = Instant.now();\n\n    CoreContainer cc = ocmh.overseer.getCoreContainer();\n    BackupRepository repository = cc.newBackupRepository(Optional.ofNullable(repo));\n    BackupManager backupMgr = new BackupManager(repository, ocmh.zkStateReader);\n\n    // Backup location\n    URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));\n    URI backupPath = repository.resolve(location, backupName);\n\n    //Validating if the directory already exists.\n    if (repository.exists(backupPath)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The backup directory already exists: \" + backupPath);\n    }\n\n    // Create a directory to store backup details.\n    repository.createDirectory(backupPath);\n\n    String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);\n    switch (strategy) {\n      case CollectionAdminParams.COPY_FILES_STRATEGY: {\n        copyIndexFiles(backupPath, collectionName, message, results);\n        break;\n      }\n      case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {\n        break;\n      }\n    }\n\n    log.info(\"Starting to backup ZK data for backupName={}\", backupName);\n\n    //Download the configs\n    String configName = ocmh.zkStateReader.readConfigName(collectionName);\n    backupMgr.downloadConfigDir(location, backupName, configName);\n\n    //Save the collection's state (coming from the collection's state.json)\n    //We extract the state and back it up as a separate json\n    DocCollection collectionState = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n    backupMgr.writeCollectionState(location, backupName, collectionName, collectionState);\n\n    Properties properties = new Properties();\n\n    properties.put(BackupManager.BACKUP_NAME_PROP, backupName);\n    properties.put(BackupManager.COLLECTION_NAME_PROP, collectionName);\n    properties.put(BackupManager.COLLECTION_ALIAS_PROP, extCollectionName);\n    properties.put(CollectionAdminParams.COLL_CONF, configName);\n    properties.put(BackupManager.START_TIME_PROP, startTime.toString());\n    properties.put(BackupManager.INDEX_VERSION_PROP, Version.LATEST.toString());\n    //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.\n    //if they are not the same then we can throw an error or have an 'overwriteConfig' flag\n    //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.\n\n    backupMgr.writeBackupProperties(location, backupName, properties);\n\n    backupMgr.downloadCollectionProperties(location, backupName, collectionName);\n\n    log.info(\"Completed backing up ZK data for backupName={}\", backupName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}