{"path":"lucene/test-framework/src/java/org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.RAMFieldsConsumer#write(Fields,NormsProducer).mjava","commits":[{"id":"622a708571e534680618b3c5e0c28ac539a47776","date":1517406892,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.RAMFieldsConsumer#write(Fields,NormsProducer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.RAMFieldsConsumer#write(Fields).mjava","sourceNew":"    @Override\n    public void write(Fields fields, NormsProducer norms) throws IOException {\n      for(String field : fields) {\n\n        Terms terms = fields.terms(field);\n        if (terms == null) {\n          continue;\n        }\n\n        TermsEnum termsEnum = terms.iterator();\n\n        FieldInfo fieldInfo = state.fieldInfos.fieldInfo(field);\n        if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0) {\n          throw new UnsupportedOperationException(\"this codec cannot index offsets\");\n        }\n\n        RAMField ramField = new RAMField(field, fieldInfo);\n        postings.fieldToTerms.put(field, ramField);\n        termsConsumer.reset(ramField);\n\n        FixedBitSet docsSeen = new FixedBitSet(state.segmentInfo.maxDoc());\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        PostingsEnum postingsEnum = null;\n        int enumFlags;\n\n        IndexOptions indexOptions = fieldInfo.getIndexOptions();\n        boolean writeFreqs = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n        boolean writePositions = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n        boolean writeOffsets = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;        \n        boolean writePayloads = fieldInfo.hasPayloads();\n\n        if (writeFreqs == false) {\n          enumFlags = 0;\n        } else if (writePositions == false) {\n          enumFlags = PostingsEnum.FREQS;\n        } else if (writeOffsets == false) {\n          if (writePayloads) {\n            enumFlags = PostingsEnum.PAYLOADS;\n          } else {\n            enumFlags = 0;\n          }\n        } else {\n          if (writePayloads) {\n            enumFlags = PostingsEnum.PAYLOADS | PostingsEnum.OFFSETS;\n          } else {\n            enumFlags = PostingsEnum.OFFSETS;\n          }\n        }\n\n        while (true) {\n          BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          RAMPostingsWriterImpl postingsWriter = termsConsumer.startTerm(term);\n          postingsEnum = termsEnum.postings(postingsEnum, enumFlags);\n\n          int docFreq = 0;\n          long totalTermFreq = 0;\n          while (true) {\n            int docID = postingsEnum.nextDoc();\n            if (docID == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docsSeen.set(docID);\n            docFreq++;\n\n            int freq;\n            if (writeFreqs) {\n              freq = postingsEnum.freq();\n              totalTermFreq += freq;\n            } else {\n              freq = -1;\n            }\n\n            postingsWriter.startDoc(docID, freq);\n            if (writePositions) {\n              for (int i=0;i<freq;i++) {\n                int pos = postingsEnum.nextPosition();\n                BytesRef payload = writePayloads ? postingsEnum.getPayload() : null;\n                int startOffset;\n                int endOffset;\n                if (writeOffsets) {\n                  startOffset = postingsEnum.startOffset();\n                  endOffset = postingsEnum.endOffset();\n                } else {\n                  startOffset = -1;\n                  endOffset = -1;\n                }\n                postingsWriter.addPosition(pos, payload, startOffset, endOffset);\n              }\n            }\n\n            postingsWriter.finishDoc();\n          }\n          termsConsumer.finishTerm(term, new TermStats(docFreq, totalTermFreq));\n          sumDocFreq += docFreq;\n          sumTotalTermFreq += totalTermFreq;\n        }\n\n        termsConsumer.finish(sumTotalTermFreq, sumDocFreq, docsSeen.cardinality());\n      }\n    }\n\n","sourceOld":"    @Override\n    public void write(Fields fields) throws IOException {\n      for(String field : fields) {\n\n        Terms terms = fields.terms(field);\n        if (terms == null) {\n          continue;\n        }\n\n        TermsEnum termsEnum = terms.iterator();\n\n        FieldInfo fieldInfo = state.fieldInfos.fieldInfo(field);\n        if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0) {\n          throw new UnsupportedOperationException(\"this codec cannot index offsets\");\n        }\n\n        RAMField ramField = new RAMField(field, fieldInfo);\n        postings.fieldToTerms.put(field, ramField);\n        termsConsumer.reset(ramField);\n\n        FixedBitSet docsSeen = new FixedBitSet(state.segmentInfo.maxDoc());\n        long sumTotalTermFreq = 0;\n        long sumDocFreq = 0;\n        PostingsEnum postingsEnum = null;\n        int enumFlags;\n\n        IndexOptions indexOptions = fieldInfo.getIndexOptions();\n        boolean writeFreqs = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n        boolean writePositions = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n        boolean writeOffsets = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;        \n        boolean writePayloads = fieldInfo.hasPayloads();\n\n        if (writeFreqs == false) {\n          enumFlags = 0;\n        } else if (writePositions == false) {\n          enumFlags = PostingsEnum.FREQS;\n        } else if (writeOffsets == false) {\n          if (writePayloads) {\n            enumFlags = PostingsEnum.PAYLOADS;\n          } else {\n            enumFlags = 0;\n          }\n        } else {\n          if (writePayloads) {\n            enumFlags = PostingsEnum.PAYLOADS | PostingsEnum.OFFSETS;\n          } else {\n            enumFlags = PostingsEnum.OFFSETS;\n          }\n        }\n\n        while (true) {\n          BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          RAMPostingsWriterImpl postingsWriter = termsConsumer.startTerm(term);\n          postingsEnum = termsEnum.postings(postingsEnum, enumFlags);\n\n          int docFreq = 0;\n          long totalTermFreq = 0;\n          while (true) {\n            int docID = postingsEnum.nextDoc();\n            if (docID == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            docsSeen.set(docID);\n            docFreq++;\n\n            int freq;\n            if (writeFreqs) {\n              freq = postingsEnum.freq();\n              totalTermFreq += freq;\n            } else {\n              freq = -1;\n            }\n\n            postingsWriter.startDoc(docID, freq);\n            if (writePositions) {\n              for (int i=0;i<freq;i++) {\n                int pos = postingsEnum.nextPosition();\n                BytesRef payload = writePayloads ? postingsEnum.getPayload() : null;\n                int startOffset;\n                int endOffset;\n                if (writeOffsets) {\n                  startOffset = postingsEnum.startOffset();\n                  endOffset = postingsEnum.endOffset();\n                } else {\n                  startOffset = -1;\n                  endOffset = -1;\n                }\n                postingsWriter.addPosition(pos, payload, startOffset, endOffset);\n              }\n            }\n\n            postingsWriter.finishDoc();\n          }\n          termsConsumer.finishTerm(term, new TermStats(docFreq, totalTermFreq));\n          sumDocFreq += docFreq;\n          sumTotalTermFreq += totalTermFreq;\n        }\n\n        termsConsumer.finish(sumTotalTermFreq, sumDocFreq, docsSeen.cardinality());\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"622a708571e534680618b3c5e0c28ac539a47776":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["622a708571e534680618b3c5e0c28ac539a47776"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["622a708571e534680618b3c5e0c28ac539a47776"],"622a708571e534680618b3c5e0c28ac539a47776":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}