{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForBinarySearch(FSTCompiler[T],FSTCompiler.UnCompiledNode[T],long,int).mjava","commits":[{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":1,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForBinarySearch(FSTCompiler[T],FSTCompiler.UnCompiledNode[T],long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForBinarySearch(Builder[T],Builder.UnCompiledNode[T],long,int).mjava","sourceNew":"  private void writeNodeForBinarySearch(FSTCompiler<T> fstCompiler, FSTCompiler.UnCompiledNode<T> nodeIn, long startAddress, int maxBytesPerArc) {\n    // Build the header in a buffer.\n    // It is a false/special arc which is in fact a node header with node flags followed by node metadata.\n    fstCompiler.fixedLengthArcsBuffer\n        .resetPosition()\n        .writeByte(ARCS_FOR_BINARY_SEARCH)\n        .writeVInt(nodeIn.numArcs)\n        .writeVInt(maxBytesPerArc);\n    int headerLen = fstCompiler.fixedLengthArcsBuffer.getPosition();\n\n    // Expand the arcs in place, backwards.\n    long srcPos = fstCompiler.bytes.getPosition();\n    long destPos = startAddress + headerLen + nodeIn.numArcs * maxBytesPerArc;\n    assert destPos >= srcPos;\n    if (destPos > srcPos) {\n      fstCompiler.bytes.skipBytes((int) (destPos - srcPos));\n      for (int arcIdx = nodeIn.numArcs - 1; arcIdx >= 0; arcIdx--) {\n        destPos -= maxBytesPerArc;\n        int arcLen = fstCompiler.numBytesPerArc[arcIdx];\n        srcPos -= arcLen;\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" arcLen=\" + arcLen + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          fstCompiler.bytes.copyBytes(srcPos, destPos, arcLen);\n        }\n      }\n    }\n\n    // Write the header.\n    fstCompiler.bytes.writeBytes(startAddress, fstCompiler.fixedLengthArcsBuffer.getBytes(), 0, headerLen);\n  }\n\n","sourceOld":"  private void writeNodeForBinarySearch(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn, long startAddress, int maxBytesPerArc) {\n    // Build the header in a buffer.\n    // It is a false/special arc which is in fact a node header with node flags followed by node metadata.\n    builder.fixedLengthArcsBuffer\n        .resetPosition()\n        .writeByte(ARCS_FOR_BINARY_SEARCH)\n        .writeVInt(nodeIn.numArcs)\n        .writeVInt(maxBytesPerArc);\n    int headerLen = builder.fixedLengthArcsBuffer.getPosition();\n\n    // Expand the arcs in place, backwards.\n    long srcPos = builder.bytes.getPosition();\n    long destPos = startAddress + headerLen + nodeIn.numArcs * maxBytesPerArc;\n    assert destPos >= srcPos;\n    if (destPos > srcPos) {\n      builder.bytes.skipBytes((int) (destPos - srcPos));\n      for (int arcIdx = nodeIn.numArcs - 1; arcIdx >= 0; arcIdx--) {\n        destPos -= maxBytesPerArc;\n        int arcLen = builder.numBytesPerArc[arcIdx];\n        srcPos -= arcLen;\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" arcLen=\" + arcLen + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          builder.bytes.copyBytes(srcPos, destPos, arcLen);\n        }\n      }\n    }\n\n    // Write the header.\n    builder.bytes.writeBytes(startAddress, builder.fixedLengthArcsBuffer.getBytes(), 0, headerLen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForBinarySearch(FSTCompiler[T],FSTCompiler.UnCompiledNode[T],long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForBinarySearch(Builder[T],Builder.UnCompiledNode[T],long,int).mjava","sourceNew":"  private void writeNodeForBinarySearch(FSTCompiler<T> fstCompiler, FSTCompiler.UnCompiledNode<T> nodeIn, long startAddress, int maxBytesPerArc) {\n    // Build the header in a buffer.\n    // It is a false/special arc which is in fact a node header with node flags followed by node metadata.\n    fstCompiler.fixedLengthArcsBuffer\n        .resetPosition()\n        .writeByte(ARCS_FOR_BINARY_SEARCH)\n        .writeVInt(nodeIn.numArcs)\n        .writeVInt(maxBytesPerArc);\n    int headerLen = fstCompiler.fixedLengthArcsBuffer.getPosition();\n\n    // Expand the arcs in place, backwards.\n    long srcPos = fstCompiler.bytes.getPosition();\n    long destPos = startAddress + headerLen + nodeIn.numArcs * maxBytesPerArc;\n    assert destPos >= srcPos;\n    if (destPos > srcPos) {\n      fstCompiler.bytes.skipBytes((int) (destPos - srcPos));\n      for (int arcIdx = nodeIn.numArcs - 1; arcIdx >= 0; arcIdx--) {\n        destPos -= maxBytesPerArc;\n        int arcLen = fstCompiler.numBytesPerArc[arcIdx];\n        srcPos -= arcLen;\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" arcLen=\" + arcLen + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          fstCompiler.bytes.copyBytes(srcPos, destPos, arcLen);\n        }\n      }\n    }\n\n    // Write the header.\n    fstCompiler.bytes.writeBytes(startAddress, fstCompiler.fixedLengthArcsBuffer.getBytes(), 0, headerLen);\n  }\n\n","sourceOld":"  private void writeNodeForBinarySearch(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn, long startAddress, int maxBytesPerArc) {\n    // Build the header in a buffer.\n    // It is a false/special arc which is in fact a node header with node flags followed by node metadata.\n    builder.fixedLengthArcsBuffer\n        .resetPosition()\n        .writeByte(ARCS_FOR_BINARY_SEARCH)\n        .writeVInt(nodeIn.numArcs)\n        .writeVInt(maxBytesPerArc);\n    int headerLen = builder.fixedLengthArcsBuffer.getPosition();\n\n    // Expand the arcs in place, backwards.\n    long srcPos = builder.bytes.getPosition();\n    long destPos = startAddress + headerLen + nodeIn.numArcs * maxBytesPerArc;\n    assert destPos >= srcPos;\n    if (destPos > srcPos) {\n      builder.bytes.skipBytes((int) (destPos - srcPos));\n      for (int arcIdx = nodeIn.numArcs - 1; arcIdx >= 0; arcIdx--) {\n        destPos -= maxBytesPerArc;\n        int arcLen = builder.numBytesPerArc[arcIdx];\n        srcPos -= arcLen;\n        if (srcPos != destPos) {\n          assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" arcLen=\" + arcLen + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n          builder.bytes.copyBytes(srcPos, destPos, arcLen);\n        }\n      }\n    }\n\n    // Write the header.\n    builder.bytes.writeBytes(startAddress, builder.fixedLengthArcsBuffer.getBytes(), 0, headerLen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}