{"path":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","commits":[{"id":"85f6ce3af19fc13abaaade6799a6e8c192e9b8e2","date":1433415299,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1954d95228d6d15076c41d8c82f6ca9667edd981","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","3f8bf184cb0ae7013c446f68cc56a9843098366e","d0a48d19410927367aa44ee0929e3a2ad64f1c85"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee714b54b99f14411add9eddecb57f7e0f1fd69d","date":1433428315,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    zkStateReader.updateClusterState(true);\n\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    zkStateReader.updateClusterState(true);\n\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    zkStateReader.updateClusterState(true);\n\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = ZkStateReader.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = ZkStateReader.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    zkStateReader.updateClusterState();\n\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    zkStateReader.updateClusterState(true);\n\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    zkStateReader.updateClusterState();\n\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0a48d19410927367aa44ee0929e3a2ad64f1c85","date":1457685126,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections;\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus;\n      DocCollection clusterStateCollection = clusterState.getCollectionOrNull(name);\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":["85f6ce3af19fc13abaaade6799a6e8c192e9b8e2"],"bugIntro":["98a8e78b6470427058bbb198472d95b4c1f1b23f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections;\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus;\n      DocCollection clusterStateCollection = clusterState.getCollectionOrNull(name);\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections;\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus;\n      DocCollection clusterStateCollection = clusterState.getCollectionOrNull(name);\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections;\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus;\n      DocCollection clusterStateCollection = clusterState.getCollectionOrNull(name);\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections;\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus;\n      DocCollection clusterStateCollection = clusterState.getCollectionOrNull(name);\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"115923bc88e5b1dc4bef049b1ded8486723052ed","date":1463216796,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f8bf184cb0ae7013c446f68cc56a9843098366e","date":1518522879,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        for(String paramShard : paramShards){\n            requestedShards.add(paramShard);\n        }\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":["85f6ce3af19fc13abaaade6799a6e8c192e9b8e2"],"bugIntro":["1954d95228d6d15076c41d8c82f6ca9667edd981"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bfcdec9fcf0409223f35c5ec3bc14094314941b4","date":1518533599,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        for(String paramShard : paramShards){\n            requestedShards.add(paramShard);\n        }\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1954d95228d6d15076c41d8c82f6ca9667edd981","date":1519624358,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (SolrException e) {\n        if (e.getCause() instanceof KeeperException.NoNodeException)  {\n          // skip this collection because the collection's znode has been deleted\n          // which can happen during aggressive collection removal, see SOLR-10720\n        } else throw e;\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public  void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        for(String paramShard : paramShards){\n            requestedShards.add(paramShard);\n        }\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":["85f6ce3af19fc13abaaade6799a6e8c192e9b8e2","3f8bf184cb0ae7013c446f68cc56a9843098366e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd6f565d9a71b415146d1d62050d268e573c4cb3","date":1541350911,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (SolrException e) {\n        if (e.getCause() instanceof KeeperException.NoNodeException)  {\n          // skip this collection because the collection's znode has been deleted\n          // which can happen during aggressive collection removal, see SOLR-10720\n        } else throw e;\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (SolrException e) {\n        if (e.getCause() instanceof KeeperException.NoNodeException)  {\n          // skip this collection because the collection's znode has been deleted\n          // which can happen during aggressive collection removal, see SOLR-10720\n        } else throw e;\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98a8e78b6470427058bbb198472d95b4c1f1b23f","date":1541639132,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          SolrException solrException = new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n          solrException.setMetadata(\"CLUSTERSTATUS\",\"NOT_FOUND\");\n          throw solrException;\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (SolrException e) {\n        if (e.getCause() instanceof KeeperException.NoNodeException)  {\n          // skip this collection because the collection's znode has been deleted\n          // which can happen during aggressive collection removal, see SOLR-10720\n        } else throw e;\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (SolrException e) {\n        if (e.getCause() instanceof KeeperException.NoNodeException)  {\n          // skip this collection because the collection's znode has been deleted\n          // which can happen during aggressive collection removal, see SOLR-10720\n        } else throw e;\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":["d0a48d19410927367aa44ee0929e3a2ad64f1c85"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4949836c6e83246ddba8997472e3333f40986c8c","date":1560293762,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          SolrException solrException = new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n          solrException.setMetadata(\"CLUSTERSTATUS\",\"NOT_FOUND\");\n          throw solrException;\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (KeeperException.NoNodeException ex) {\n        // skip this collection because the configset's znode has been deleted\n        // which can happen during aggressive collection removal, see SOLR-10720\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          SolrException solrException = new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n          solrException.setMetadata(\"CLUSTERSTATUS\",\"NOT_FOUND\");\n          throw solrException;\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (SolrException e) {\n        if (e.getCause() instanceof KeeperException.NoNodeException)  {\n          // skip this collection because the collection's znode has been deleted\n          // which can happen during aggressive collection removal, see SOLR-10720\n        } else throw e;\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(@SuppressWarnings({\"rawtypes\"})NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          SolrException solrException = new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n          solrException.setMetadata(\"CLUSTERSTATUS\",\"NOT_FOUND\");\n          throw solrException;\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (KeeperException.NoNodeException ex) {\n        // skip this collection because the configset's znode has been deleted\n        // which can happen during aggressive collection removal, see SOLR-10720\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    @SuppressWarnings({\"rawtypes\"})\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          SolrException solrException = new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n          solrException.setMetadata(\"CLUSTERSTATUS\",\"NOT_FOUND\");\n          throw solrException;\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (KeeperException.NoNodeException ex) {\n        // skip this collection because the configset's znode has been deleted\n        // which can happen during aggressive collection removal, see SOLR-10720\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus#getClusterStatus(NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(@SuppressWarnings({\"rawtypes\"})NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          SolrException solrException = new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n          solrException.setMetadata(\"CLUSTERSTATUS\",\"NOT_FOUND\");\n          throw solrException;\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n        byte[] bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (KeeperException.NoNodeException ex) {\n        // skip this collection because the configset's znode has been deleted\n        // which can happen during aggressive collection removal, see SOLR-10720\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map<String, Object> clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void getClusterStatus(@SuppressWarnings({\"rawtypes\"})NamedList results)\n      throws KeeperException, InterruptedException {\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, List<String>> aliasVsCollections = aliases.getCollectionAliasListMap();\n    for (Map.Entry<String, List<String>> entry : aliasVsCollections.entrySet()) {\n      String alias = entry.getKey();\n      List<String> colls = entry.getValue();\n      for (String coll : colls) {\n        if (collection == null || collection.equals(coll))  {\n          List<String> list = collectionVsAliases.computeIfAbsent(coll, k -> new ArrayList<>());\n          list.add(alias);\n        }\n      }\n    }\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    Map<String, DocCollection> collectionsMap = null;\n    if (collection == null) {\n      collectionsMap = clusterState.getCollectionsMap();\n    } else  {\n      collectionsMap = Collections.singletonMap(collection, clusterState.getCollectionOrNull(collection));\n    }\n\n    boolean isAlias = aliasVsCollections.containsKey(collection);\n    boolean didNotFindCollection = collectionsMap.get(collection) == null;\n\n    if (didNotFindCollection && isAlias) {\n      // In this case this.collection is an alias name not a collection\n      // get all collections and filter out collections not in the alias\n      collectionsMap = clusterState.getCollectionsMap().entrySet().stream()\n          .filter((entry) -> aliasVsCollections.get(collection).contains(entry.getKey()))\n          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<>();\n\n    for (Map.Entry<String, DocCollection> entry : collectionsMap.entrySet()) {\n      Map<String, Object> collectionStatus;\n      String name = entry.getKey();\n      DocCollection clusterStateCollection = entry.getValue();\n      if (clusterStateCollection == null) {\n        if (collection != null) {\n          SolrException solrException = new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection: \" + name + \" not found\");\n          solrException.setMetadata(\"CLUSTERSTATUS\",\"NOT_FOUND\");\n          throw solrException;\n        } else {\n          //collection might have got deleted at the same time\n          continue;\n        }\n      }\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        String[] paramShards = shard.split(\",\");\n        requestedShards.addAll(Arrays.asList(paramShards));\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      try {\n        String configName = zkStateReader.readConfigName(name);\n        collectionStatus.put(\"configName\", configName);\n        collectionProps.add(name, collectionStatus);\n      } catch (KeeperException.NoNodeException ex) {\n        // skip this collection because the configset's znode has been deleted\n        // which can happen during aggressive collection removal, see SOLR-10720\n      }\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    @SuppressWarnings({\"rawtypes\"})\n    Map clusterProps = zkStateReader.getClusterProperties();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    Map<String, String> collectionAliasMap = aliases.getCollectionAliasMap(); // comma delim\n    if (!collectionAliasMap.isEmpty())  {\n      clusterStatus.add(\"aliases\", collectionAliasMap);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":["b693a83132c9e45afcd564fd65a25b60ed80388b","85f6ce3af19fc13abaaade6799a6e8c192e9b8e2","115923bc88e5b1dc4bef049b1ded8486723052ed","ba055e19afc289adcb5bedaf68513793a7254012"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dd6f565d9a71b415146d1d62050d268e573c4cb3":["1954d95228d6d15076c41d8c82f6ca9667edd981"],"85f6ce3af19fc13abaaade6799a6e8c192e9b8e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0ad30c6a479e764150a3316e57263319775f1df2":["73450c0955930295d34703e7ddbfc6973b7a121a","115923bc88e5b1dc4bef049b1ded8486723052ed"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06","3f8bf184cb0ae7013c446f68cc56a9843098366e"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["73450c0955930295d34703e7ddbfc6973b7a121a","0ad30c6a479e764150a3316e57263319775f1df2"],"ba055e19afc289adcb5bedaf68513793a7254012":["4949836c6e83246ddba8997472e3333f40986c8c"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["d0a48d19410927367aa44ee0929e3a2ad64f1c85","73450c0955930295d34703e7ddbfc6973b7a121a"],"98a8e78b6470427058bbb198472d95b4c1f1b23f":["dd6f565d9a71b415146d1d62050d268e573c4cb3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee714b54b99f14411add9eddecb57f7e0f1fd69d":["85f6ce3af19fc13abaaade6799a6e8c192e9b8e2"],"3f8bf184cb0ae7013c446f68cc56a9843098366e":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["ba055e19afc289adcb5bedaf68513793a7254012"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"73450c0955930295d34703e7ddbfc6973b7a121a":["d0a48d19410927367aa44ee0929e3a2ad64f1c85","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["d0a48d19410927367aa44ee0929e3a2ad64f1c85","73450c0955930295d34703e7ddbfc6973b7a121a"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["ee714b54b99f14411add9eddecb57f7e0f1fd69d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","d470c8182e92b264680e34081b75e70a9f2b3c89"],"1954d95228d6d15076c41d8c82f6ca9667edd981":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"115923bc88e5b1dc4bef049b1ded8486723052ed":["73450c0955930295d34703e7ddbfc6973b7a121a"],"4949836c6e83246ddba8997472e3333f40986c8c":["98a8e78b6470427058bbb198472d95b4c1f1b23f"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["d0a48d19410927367aa44ee0929e3a2ad64f1c85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"d0a48d19410927367aa44ee0929e3a2ad64f1c85":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"]},"commit2Childs":{"dd6f565d9a71b415146d1d62050d268e573c4cb3":["98a8e78b6470427058bbb198472d95b4c1f1b23f"],"85f6ce3af19fc13abaaade6799a6e8c192e9b8e2":["ee714b54b99f14411add9eddecb57f7e0f1fd69d"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["d0a48d19410927367aa44ee0929e3a2ad64f1c85"],"bfcdec9fcf0409223f35c5ec3bc14094314941b4":["1954d95228d6d15076c41d8c82f6ca9667edd981"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ba055e19afc289adcb5bedaf68513793a7254012":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["85f6ce3af19fc13abaaade6799a6e8c192e9b8e2"],"98a8e78b6470427058bbb198472d95b4c1f1b23f":["4949836c6e83246ddba8997472e3333f40986c8c"],"ee714b54b99f14411add9eddecb57f7e0f1fd69d":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"3f8bf184cb0ae7013c446f68cc56a9843098366e":["bfcdec9fcf0409223f35c5ec3bc14094314941b4"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["bfcdec9fcf0409223f35c5ec3bc14094314941b4","3f8bf184cb0ae7013c446f68cc56a9843098366e"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"73450c0955930295d34703e7ddbfc6973b7a121a":["0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","7dc08f02757dd10637b16a5c65eaaef839a91a9a","115923bc88e5b1dc4bef049b1ded8486723052ed"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"1954d95228d6d15076c41d8c82f6ca9667edd981":["dd6f565d9a71b415146d1d62050d268e573c4cb3"],"115923bc88e5b1dc4bef049b1ded8486723052ed":["0ad30c6a479e764150a3316e57263319775f1df2"],"4949836c6e83246ddba8997472e3333f40986c8c":["ba055e19afc289adcb5bedaf68513793a7254012"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"d0a48d19410927367aa44ee0929e3a2ad64f1c85":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","73450c0955930295d34703e7ddbfc6973b7a121a","7dc08f02757dd10637b16a5c65eaaef839a91a9a","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}