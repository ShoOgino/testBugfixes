{"path":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","commits":[{"id":"03d1c7f08294f7d7e9ecf082aa1459f38d77f277","date":1493688929,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    Fields fields = readerContext.reader().fields();\n    final Terms terms = fields.terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(null, atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a8e07078a2a2938dbc85aab616aa8b0c651a219c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"23c0f0de44c893e0d072b4c26fc99206ce26687c","date":1493725812,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    Fields fields = readerContext.reader().fields();\n    final Terms terms = fields.terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    Fields fields = readerContext.reader().fields();\n    final Terms terms = fields.terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(null, atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    Fields fields = readerContext.reader().fields();\n    final Terms terms = fields.terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","date":1497408244,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    Fields fields = readerContext.reader().fields();\n    final Terms terms = fields.terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    Fields fields = readerContext.reader().fields();\n    final Terms terms = fields.terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    Fields fields = readerContext.reader().fields();\n    final Terms terms = fields.terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8e07078a2a2938dbc85aab616aa8b0c651a219c","date":1509045642,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n      float docScore = 0.f;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          else if (doc == lastDocRequested) {\n            return docScore;\n          }\n          \n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            docScore =  defaultValues.floatVal(doc);\n            return docScore;\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n          docScore =  (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n          return docScore;\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            return defaultValues.floatVal(doc);\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n\n          return (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","bugFix":["03d1c7f08294f7d7e9ecf082aa1459f38d77f277"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"340d2a56d051f2e4d6d9c707e2d5614d3d81adf8","date":1510236334,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n      float docScore = 0.f;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          else if (doc == lastDocRequested) {\n            return docScore;\n          }\n          \n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            docScore =  defaultValues.floatVal(doc);\n            return docScore;\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.computePayloadFactor(payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n          docScore =  (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n          return docScore;\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n      float docScore = 0.f;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          else if (doc == lastDocRequested) {\n            return docScore;\n          }\n          \n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            docScore =  defaultValues.floatVal(doc);\n            return docScore;\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.decode(atDoc, docs.startOffset(), docs.endOffset(), payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n          docScore =  (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n          return docScore;\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(@SuppressWarnings({\"rawtypes\"})Map context\n          , LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n      float docScore = 0.f;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          else if (doc == lastDocRequested) {\n            return docScore;\n          }\n          \n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            docScore =  defaultValues.floatVal(doc);\n            return docScore;\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.computePayloadFactor(payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n          docScore =  (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n          return docScore;\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n      float docScore = 0.f;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          else if (doc == lastDocRequested) {\n            return docScore;\n          }\n          \n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            docScore =  defaultValues.floatVal(doc);\n            return docScore;\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.computePayloadFactor(payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n          docScore =  (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n          return docScore;\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/FloatPayloadValueSource#getValues(Map,LeafReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(@SuppressWarnings({\"rawtypes\"})Map context\n          , LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    @SuppressWarnings({\"unchecked\"})\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n      float docScore = 0.f;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          else if (doc == lastDocRequested) {\n            return docScore;\n          }\n          \n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            docScore =  defaultValues.floatVal(doc);\n            return docScore;\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.computePayloadFactor(payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n          docScore =  (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n          return docScore;\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(@SuppressWarnings({\"rawtypes\"})Map context\n          , LeafReaderContext readerContext) throws IOException {\n\n    final Terms terms = readerContext.reader().terms(indexedField);\n\n    FunctionValues defaultValues = defaultValueSource.getValues(context, readerContext);\n\n    // copied the bulk of this from TFValueSource - TODO: this is a very repeated pattern - base-class this advance logic stuff?\n    return new FloatDocValues(this) {\n      PostingsEnum docs ;\n      int atDoc;\n      int lastDocRequested = -1;\n      float docScore = 0.f;\n\n      { reset(); }\n\n      public void reset() throws IOException {\n        // no one should call us for deleted docs?\n\n        if (terms != null) {\n          final TermsEnum termsEnum = terms.iterator();\n          if (termsEnum.seekExact(indexedBytes)) {\n            docs = termsEnum.postings(null, PostingsEnum.ALL);\n          } else {\n            docs = null;\n          }\n        } else {\n          docs = null;\n        }\n\n        if (docs == null) {\n          // dummy PostingsEnum so floatVal() can work\n          // when would this be called?  if field/val did not match?  this is called for every doc?  create once and cache?\n          docs = new PostingsEnum() {\n            @Override\n            public int freq() {\n              return 0;\n            }\n\n            @Override\n            public int nextPosition() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int startOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public int endOffset() throws IOException {\n              return -1;\n            }\n\n            @Override\n            public BytesRef getPayload() throws IOException {\n              return null;\n            }\n\n            @Override\n            public int docID() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int nextDoc() {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public int advance(int target) {\n              return DocIdSetIterator.NO_MORE_DOCS;\n            }\n\n            @Override\n            public long cost() {\n              return 0;\n            }\n          };\n        }\n        atDoc = -1;\n      }\n\n      @Override\n      public float floatVal(int doc) {\n        try {\n          if (doc < lastDocRequested) {\n            // out-of-order access.... reset\n            reset();\n          }\n          else if (doc == lastDocRequested) {\n            return docScore;\n          }\n          \n          lastDocRequested = doc;\n\n          if (atDoc < doc) {\n            atDoc = docs.advance(doc);\n          }\n\n          if (atDoc > doc) {\n            // term doesn't match this document... either because we hit the\n            // end, or because the next doc is after this doc.\n            docScore =  defaultValues.floatVal(doc);\n            return docScore;\n          }\n\n          // a match!\n          int freq = docs.freq();\n          int numPayloadsSeen = 0;\n          float currentScore = 0;\n          for (int i=0; i < freq; i++) {\n            docs.nextPosition();\n            BytesRef payload = docs.getPayload();\n            if (payload != null) {\n              float payloadVal = decoder.computePayloadFactor(payload);\n\n              // payloadFunction = null represents \"first\"\n              if (payloadFunction == null) return payloadVal;\n\n              currentScore = payloadFunction.currentScore(doc, indexedField, docs.startOffset(), docs.endOffset(),\n                  numPayloadsSeen, currentScore, payloadVal);\n              numPayloadsSeen++;\n\n            }\n          }\n          docScore =  (numPayloadsSeen > 0) ? payloadFunction.docScore(doc, indexedField, numPayloadsSeen, currentScore) : defaultValues.floatVal(doc);\n          return docScore;\n        } catch (IOException e) {\n          throw new RuntimeException(\"caught exception in function \"+description()+\" : doc=\"+doc, e);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","23c0f0de44c893e0d072b4c26fc99206ce26687c"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["23c0f0de44c893e0d072b4c26fc99206ce26687c"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["340d2a56d051f2e4d6d9c707e2d5614d3d81adf8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"340d2a56d051f2e4d6d9c707e2d5614d3d81adf8":["a8e07078a2a2938dbc85aab616aa8b0c651a219c"],"a8e07078a2a2938dbc85aab616aa8b0c651a219c":["28288370235ed02234a64753cdbf0c6ec096304a"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"28288370235ed02234a64753cdbf0c6ec096304a":["23c0f0de44c893e0d072b4c26fc99206ce26687c","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"23c0f0de44c893e0d072b4c26fc99206ce26687c":["03d1c7f08294f7d7e9ecf082aa1459f38d77f277"],"03d1c7f08294f7d7e9ecf082aa1459f38d77f277":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","03d1c7f08294f7d7e9ecf082aa1459f38d77f277"],"340d2a56d051f2e4d6d9c707e2d5614d3d81adf8":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"a8e07078a2a2938dbc85aab616aa8b0c651a219c":["340d2a56d051f2e4d6d9c707e2d5614d3d81adf8"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"28288370235ed02234a64753cdbf0c6ec096304a":["a8e07078a2a2938dbc85aab616aa8b0c651a219c"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"23c0f0de44c893e0d072b4c26fc99206ce26687c":["e9017cf144952056066919f1ebc7897ff9bd71b1","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"03d1c7f08294f7d7e9ecf082aa1459f38d77f277":["23c0f0de44c893e0d072b4c26fc99206ce26687c"]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}