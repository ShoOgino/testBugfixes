{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest#streamLocalTests().mjava","commits":[{"id":"70d9c44f68e848648da304352cf7c045c33148f4","date":1557331987,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest#streamLocalTests().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This test verifies that setting a core into the stream context entries and streamContext.local = true causes the\n   * streaming expression to only consider data found on the local node.\n   */\n  @Test\n  public void streamLocalTests() throws Exception {\n\n    new UpdateRequest()\n        .add(id, \"0\", \"a_s\", \"hello0\", \"a_i\", \"0\", \"a_f\", \"0\")\n        .add(id, \"2\", \"a_s\", \"hello2\", \"a_i\", \"2\", \"a_f\", \"0\")\n        .add(id, \"3\", \"a_s\", \"hello3\", \"a_i\", \"3\", \"a_f\", \"3\")\n        .add(id, \"4\", \"a_s\", \"hello4\", \"a_i\", \"4\", \"a_f\", \"4\")\n        .add(id, \"1\", \"a_s\", \"hello1\", \"a_i\", \"1\", \"a_f\", \"1\")\n        .commit(cluster.getSolrClient(), COLLECTIONORALIAS);\n\n    StreamContext streamContext = new StreamContext();\n    streamContext.setLocal(true);\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    List<String> strings = zkStateReader.aliasesManager.getAliases().resolveAliases(COLLECTIONORALIAS);\n    String collName = strings.size() > 0 ? strings.get(0) : COLLECTIONORALIAS;\n      zkStateReader.forceUpdateCollection(collName);\n    DocCollection collection = zkStateReader.getClusterState().getCollectionOrNull(collName);\n    List<Replica> replicas = collection.getReplicas();\n    streamContext.getEntries().put(\"core\",replicas.get(random().nextInt(replicas.size())).getCoreName());\n    SolrClientCache solrClientCache = new SolrClientCache();\n    streamContext.setSolrClientCache(solrClientCache);\n    //Basic CloudSolrStream Test with Descending Sort\n\n    try {\n      SolrParams sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i\", \"sort\", \"a_i desc\");\n      CloudSolrStream stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      List<Tuple> tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 4, 3, 2, 1, 0);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 4, 1, 0);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples,  3, 2);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      //With Ascending Sort\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i\", \"sort\", \"a_i asc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 0, 1, 2, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      //Test compound sort\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i,a_f\", \"sort\", \"a_f asc,a_i desc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 2, 0, 1, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i,a_f\", \"sort\", \"a_f asc,a_i asc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 0, 2, 1, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n    } finally {\n      solrClientCache.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ba1b632c041956c93c41aa1143d16a567014891","date":1592328473,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest#streamLocalTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest#streamLocalTests().mjava","sourceNew":"  /**\n   * This test verifies that setting a core into the stream context entries and streamContext.local = true causes the\n   * streaming expression to only consider data found on the local node.\n   */\n  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void streamLocalTests() throws Exception {\n\n    new UpdateRequest()\n        .add(id, \"0\", \"a_s\", \"hello0\", \"a_i\", \"0\", \"a_f\", \"0\")\n        .add(id, \"2\", \"a_s\", \"hello2\", \"a_i\", \"2\", \"a_f\", \"0\")\n        .add(id, \"3\", \"a_s\", \"hello3\", \"a_i\", \"3\", \"a_f\", \"3\")\n        .add(id, \"4\", \"a_s\", \"hello4\", \"a_i\", \"4\", \"a_f\", \"4\")\n        .add(id, \"1\", \"a_s\", \"hello1\", \"a_i\", \"1\", \"a_f\", \"1\")\n        .commit(cluster.getSolrClient(), COLLECTIONORALIAS);\n\n    StreamContext streamContext = new StreamContext();\n    streamContext.setLocal(true);\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    List<String> strings = zkStateReader.aliasesManager.getAliases().resolveAliases(COLLECTIONORALIAS);\n    String collName = strings.size() > 0 ? strings.get(0) : COLLECTIONORALIAS;\n      zkStateReader.forceUpdateCollection(collName);\n    DocCollection collection = zkStateReader.getClusterState().getCollectionOrNull(collName);\n    List<Replica> replicas = collection.getReplicas();\n    streamContext.getEntries().put(\"core\",replicas.get(random().nextInt(replicas.size())).getCoreName());\n    SolrClientCache solrClientCache = new SolrClientCache();\n    streamContext.setSolrClientCache(solrClientCache);\n    //Basic CloudSolrStream Test with Descending Sort\n\n    try {\n      SolrParams sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i\", \"sort\", \"a_i desc\");\n      CloudSolrStream stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      List<Tuple> tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 4, 3, 2, 1, 0);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 4, 1, 0);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples,  3, 2);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      //With Ascending Sort\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i\", \"sort\", \"a_i asc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 0, 1, 2, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      //Test compound sort\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i,a_f\", \"sort\", \"a_f asc,a_i desc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 2, 0, 1, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i,a_f\", \"sort\", \"a_f asc,a_i asc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 0, 2, 1, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n    } finally {\n      solrClientCache.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * This test verifies that setting a core into the stream context entries and streamContext.local = true causes the\n   * streaming expression to only consider data found on the local node.\n   */\n  @Test\n  public void streamLocalTests() throws Exception {\n\n    new UpdateRequest()\n        .add(id, \"0\", \"a_s\", \"hello0\", \"a_i\", \"0\", \"a_f\", \"0\")\n        .add(id, \"2\", \"a_s\", \"hello2\", \"a_i\", \"2\", \"a_f\", \"0\")\n        .add(id, \"3\", \"a_s\", \"hello3\", \"a_i\", \"3\", \"a_f\", \"3\")\n        .add(id, \"4\", \"a_s\", \"hello4\", \"a_i\", \"4\", \"a_f\", \"4\")\n        .add(id, \"1\", \"a_s\", \"hello1\", \"a_i\", \"1\", \"a_f\", \"1\")\n        .commit(cluster.getSolrClient(), COLLECTIONORALIAS);\n\n    StreamContext streamContext = new StreamContext();\n    streamContext.setLocal(true);\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    List<String> strings = zkStateReader.aliasesManager.getAliases().resolveAliases(COLLECTIONORALIAS);\n    String collName = strings.size() > 0 ? strings.get(0) : COLLECTIONORALIAS;\n      zkStateReader.forceUpdateCollection(collName);\n    DocCollection collection = zkStateReader.getClusterState().getCollectionOrNull(collName);\n    List<Replica> replicas = collection.getReplicas();\n    streamContext.getEntries().put(\"core\",replicas.get(random().nextInt(replicas.size())).getCoreName());\n    SolrClientCache solrClientCache = new SolrClientCache();\n    streamContext.setSolrClientCache(solrClientCache);\n    //Basic CloudSolrStream Test with Descending Sort\n\n    try {\n      SolrParams sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i\", \"sort\", \"a_i desc\");\n      CloudSolrStream stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      List<Tuple> tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 4, 3, 2, 1, 0);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 4, 1, 0);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples,  3, 2);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      //With Ascending Sort\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i\", \"sort\", \"a_i asc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 0, 1, 2, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      //Test compound sort\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i,a_f\", \"sort\", \"a_f asc,a_i desc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 2, 0, 1, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n      sParams = mapParams(\"q\", \"*:*\", \"fl\", \"id,a_s,a_i,a_f\", \"sort\", \"a_f asc,a_i asc\");\n      stream = new CloudSolrStream(zkHost, COLLECTIONORALIAS, sParams);\n      stream.setStreamContext(streamContext);\n      tuples = getTuples(stream);\n\n      // note if hashing algo changes this might break\n      switch (tuples.size()) {\n        case 5: // 1 shard\n          assertOrder(tuples, 0, 2, 1, 3, 4);\n          break;\n        case 3: // 2 shards case 1 (randomized)\n          assertOrder(tuples, 0, 1, 4);\n          break;\n        case 2: // 2 shards case 2 (randomized)\n          assertOrder(tuples, 2, 3);\n          break;\n        default: // nope, no way, no how, never good.\n          fail(\"should have 3, 5 or 2 tuples, has hashing algorithm changed?\");\n      }\n\n    } finally {\n      solrClientCache.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ba1b632c041956c93c41aa1143d16a567014891":["70d9c44f68e848648da304352cf7c045c33148f4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ba1b632c041956c93c41aa1143d16a567014891"],"70d9c44f68e848648da304352cf7c045c33148f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"9ba1b632c041956c93c41aa1143d16a567014891":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70d9c44f68e848648da304352cf7c045c33148f4"],"70d9c44f68e848648da304352cf7c045c33148f4":["9ba1b632c041956c93c41aa1143d16a567014891"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}