{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","commits":[{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication.SearchThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if we got the new primary after crash and that primary is still catching up (replaying xlog):\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if we got the new primary after crash and that primary is still catching up (replaying xlog):\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // nocommit not anymore?\n          // This can be null if we got the new primary after crash and that primary is still catching up (replaying xlog):\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n          assertNotNull(\"version=\" + version, expectedAtLeastHitCount);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.out.writeVInt(expectedAtLeastHitCount);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if we got the new primary after crash and that primary is still catching up (replaying xlog):\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a8ec0889b27701f0ad90a25c95b75454e898cf3","date":1454871481,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if primary is flushing, has already refreshed its searcher, but is e.g. still notifying replicas and hasn't\n          // yet returned the version to us, in which case this searcher thread can see the version before the main thread has added it to\n          // versionToMarker:\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.out.writeVInt(expectedAtLeastHitCount);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // nocommit not anymore?\n          // This can be null if we got the new primary after crash and that primary is still catching up (replaying xlog):\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n          assertNotNull(\"version=\" + version, expectedAtLeastHitCount);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.out.writeVInt(expectedAtLeastHitCount);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fc4da33180d50cc1cad94d72b86d7d0459c1740","date":1454977102,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        boolean nodeIsPrimary = node == primary;\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n              if (nodeIsPrimary && version > lastPrimaryVersion) {\n                // It's possible a search request sees a new primary version because it's in the process of flushing, but then the primary\n                // crashes.  In this case we need to ensure new primary forces its version beyond this:\n                message(\"top: searcher: set lastPrimaryVersion=\" + lastPrimaryVersion + \" vs \" + version);\n                lastPrimaryVersion = version;\n              }\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if primary is flushing, has already refreshed its searcher, but is e.g. still notifying replicas and hasn't\n          // yet returned the version to us, in which case this searcher thread can see the version before the main thread has added it to\n          // versionToMarker:\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.out.writeVInt(expectedAtLeastHitCount);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if primary is flushing, has already refreshed its searcher, but is e.g. still notifying replicas and hasn't\n          // yet returned the version to us, in which case this searcher thread can see the version before the main thread has added it to\n          // versionToMarker:\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.out.writeVInt(expectedAtLeastHitCount);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        boolean nodeIsPrimary = node == primary;\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n              if (nodeIsPrimary && version > lastPrimaryVersion) {\n                // It's possible a search request sees a new primary version because it's in the process of flushing, but then the primary\n                // crashes.  In this case we need to ensure new primary forces its version beyond this:\n                message(\"top: searcher: set lastPrimaryVersion=\" + lastPrimaryVersion + \" vs \" + version);\n                lastPrimaryVersion = version;\n              }\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if primary is flushing, has already refreshed its searcher, but is e.g. still notifying replicas and hasn't\n          // yet returned the version to us, in which case this searcher thread can see the version before the main thread has added it to\n          // versionToMarker:\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.out.writeVInt(expectedAtLeastHitCount);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"0fc4da33180d50cc1cad94d72b86d7d0459c1740":["4a8ec0889b27701f0ad90a25c95b75454e898cf3"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0fc4da33180d50cc1cad94d72b86d7d0459c1740"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"]},"commit2Childs":{"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["0fc4da33180d50cc1cad94d72b86d7d0459c1740"],"0fc4da33180d50cc1cad94d72b86d7d0459c1740":["68496c2200e559fb7802f7575427b7a482659afb"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["4a8ec0889b27701f0ad90a25c95b75454e898cf3"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","68496c2200e559fb7802f7575427b7a482659afb"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}