{"path":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","commits":[{"id":"cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18","date":1339188570,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n        assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    AtomicReaderContext[] children = topReaderContext.leaves();\n    assertEquals(1, children.length);\n    DocValues docValues = children[0].reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":["ff266254aa2c0b84006f8f3088ee25337661554d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws CorruptIndexException, IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ced66195b26fdb1f77ee00e2a77ec6918dedd766","date":1344948886,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"211b1506e56f7860762fbd4698f6d1d1b57f672c","date":1344976996,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().size());\n    IndexReaderContext topReaderContext = reader.getTopReaderContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e2893fd5349134af382d33ccc3d84840394c6c1","date":1353682567,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":null,"sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[],Type[]).mjava","sourceNew":null,"sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values, Type[] sourceType)\n      throws IOException {\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    IndexReaderContext topReaderContext = reader.getContext();\n    List<AtomicReaderContext> leaves = topReaderContext.leaves();\n    assertEquals(1, leaves.size());\n    DocValues docValues = leaves.get(0).reader().docValues(\"promote\");\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);\n          break;\n        case 4:\n          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)\n                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);\n          break;\n        case 8:\n          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |\n                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |\n                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |\n                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          if (sourceType[id] == Type.FLOAT_32\n              || sourceType[id] == Type.FLOAT_64) {\n            assertEquals(msg, values[id],\n                Double.doubleToRawLongBits(directSource.getFloat(i)));\n          } else {\n            assertEquals(msg, values[id], directSource.getFloat(i), 0.0d);\n          }\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3c188105a9aae04f56c24996f98f8333fc825d2e":["fe33227f6805edab2036cbb80645cc4e2d1fa424"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18"],"6e2893fd5349134af382d33ccc3d84840394c6c1":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["211b1506e56f7860762fbd4698f6d1d1b57f672c","6e2893fd5349134af382d33ccc3d84840394c6c1"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"6e2893fd5349134af382d33ccc3d84840394c6c1":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["6e2893fd5349134af382d33ccc3d84840394c6c1","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","d4d69c535930b5cce125cff868d40f6373dc27d4"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cc8f931c07d7930ebee666cf6d69b1b6d9f9cd18"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","fe33227f6805edab2036cbb80645cc4e2d1fa424","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}