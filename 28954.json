{"path":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","commits":[{"id":"b5c559c875836474bafae7243263d93b1b1965db","date":1289581659,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // nocommit -- for sorted test, do our own Sort of the\n  // values and verify it's identical\n  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d84736c4614acce6720851cbd2c823d7cd516e4","date":1290551630,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(result.ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord,\n                  bytesRef).clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1, bytesRef);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx).utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx))\n              .utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue.bytesEquals(ss.getByOrd(result.ord)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord)\n                  .clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","date":1291128345,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(result.ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord,\n                  bytesRef).clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1, bytesRef);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(result.ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord,\n                  bytesRef).clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1, bytesRef);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(result.ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord,\n                  bytesRef).clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1, bytesRef);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      ValuesAttribute attr = bytesEnum.addAttribute(ValuesAttribute.class);\n      assertNotNull(\"attribute is null\", attr);\n      BytesRef ref = attr.bytes();\n      assertNotNull(\"BytesRef is null - enum not initialized to use bytes\",\n          attr);\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(result.ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord,\n                  bytesRef).clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1, bytesRef);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2fc2eb37a1f19e90850f787d9e085950ebfa04","date":1291597075,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      DocValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(result.ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord,\n                  bytesRef).clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1, bytesRef);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(result.ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord,\n                  bytesRef).clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1, bytesRef);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4034ca0f8f74fdf56e25be73822f2441fc1c1b46","date":1307111599,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      DocValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int lenMin, lenMax;\n    if (fixedSize) {\n      lenMin = lenMax = 3 + random.nextInt(7);\n    } else {\n      lenMin = 1;\n      lenMax = 15 + random.nextInt(6);\n    }\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomUnicodeString(random, lenMin, lenMax);\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      DocValuesEnum bytesEnum = r.getEnum();\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n          DocValues.SortedSource.LookupResult result = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(result.found);\n          assertEquals(ss.ord(idx), result.ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomUnicodeString(\n              random, lenMin, lenMax));\n          SortedSource.LookupResult result = ss.getByValue(bytesValue);\n          if (result.found) {\n            assert result.ord > 0;\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(result.ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), result.ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert result.ord >= 0;\n            if (result.ord == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (result.ord == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // random string fell between two of our values\n              final BytesRef before = (BytesRef) ss.getByOrd(result.ord,\n                  bytesRef).clone();\n              final BytesRef after = ss.getByOrd(result.ord + 1, bytesRef);\n              assertTrue(before.compareTo(bytesValue) < 0);\n              assertTrue(bytesValue.compareTo(after) < 0);\n\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41e5bbad683f7546e96f08ffe8bc50cf447f2586","date":1307113213,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      DocValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      DocValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"605b061fadf71aa6458c0005eaae83a98350c403","date":1307117658,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      DocValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b7a068f550e13e49517c6899cc3b94c8eeb72e5","date":1309354772,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 3 + random.nextInt(7);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc0b8069918917b33f361011899a1af0cdd2d462","date":1310039336,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9507caf22f292ac0e5e59f62db4275adf4511","date":1310107283,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1291e4568eb7d9463d751627596ef14baf4c1603","date":1310112572,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        s = ss = getSortedSource(r, comp);\n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes);\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp);\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17cc1e690c31c800f83860fbfd0423462962ef01","date":1314789725,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final AtomicLong trackBytes = new AtomicLong(0);\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e128967bca58657bc0039d4bfe631e63e81f1977","date":1317978310,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    final Comparator<BytesRef> comp = mode == Bytes.Mode.SORTED ? BytesRef\n        .getUTF8SortedAsUnicodeComparator() : null;\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, comp, fixedSize, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, comp, newIOContext(random));\n    for (int iter = 0; iter < 2; iter++) {\n      ValuesEnum bytesEnum = getEnum(r);\n      assertNotNull(\"enum is null\", bytesEnum);\n      BytesRef ref = bytesEnum.bytes();\n\n      for (int i = 0; i < 2; i++) {\n        final int idx = 2 * i;\n        assertEquals(\"doc: \" + idx, idx, bytesEnum.advance(idx));\n        String utf8String = ref.utf8ToString();\n        assertEquals(\"doc: \" + idx + \" lenLeft: \" + values[idx].length()\n            + \" lenRight: \" + utf8String.length(), values[idx], utf8String);\n      }\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));\n      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));\n\n      bytesEnum.close();\n    }\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r, random.nextBoolean() ? comp : null);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]));\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int numValues = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue);\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == numValues) {\n              final BytesRef lastRef = ss.getByOrd(numValues-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(comp.compare(before, bytesValue) < 0);\n              assertTrue(comp.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              final BytesRef before = (BytesRef) ss.getByOrd(insertIndex-1, bytesRef)\n              .clone();\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    IndexDocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      IndexDocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/codecs/lucene40/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValues#runTestBytes(Bytes.Mode,boolean).mjava","sourceNew":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)\n      throws IOException {\n\n    final BytesRef bytesRef = new BytesRef();\n\n    Directory dir = newDirectory();\n    final Counter trackBytes = Counter.newCounter();\n    Writer w = Bytes.getWriter(dir, \"test\", mode, fixedSize, COMP, trackBytes, newIOContext(random));\n    int maxDoc = 220;\n    final String[] values = new String[maxDoc];\n    final int fixedLength = 1 + atLeast(50);\n    for (int i = 0; i < 100; i++) {\n      final String s;\n      if (i > 0 && random.nextInt(5) <= 2) {\n        // use prior value\n        s = values[2 * random.nextInt(i)];\n      } else {\n        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));\n      }\n      values[2 * i] = s;\n\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);\n      w.add(2 * i, bytesRef);\n    }\n    w.finish(maxDoc);\n    assertEquals(0, trackBytes.get());\n\n    DocValues r = Bytes.getValues(dir, \"test\", mode, fixedSize, maxDoc, COMP, newIOContext(random));\n\n    // Verify we can load source twice:\n    for (int iter = 0; iter < 2; iter++) {\n      Source s;\n      DocValues.SortedSource ss;\n      if (mode == Bytes.Mode.SORTED) {\n        // default is unicode so we can simply pass null here\n        s = ss = getSortedSource(r);  \n      } else {\n        s = getSource(r);\n        ss = null;\n      }\n      for (int i = 0; i < 100; i++) {\n        final int idx = 2 * i;\n        assertNotNull(\"doc \" + idx + \"; value=\" + values[idx], s.getBytes(idx,\n            bytesRef));\n        assertEquals(\"doc \" + idx, values[idx], s.getBytes(idx, bytesRef)\n            .utf8ToString());\n        if (ss != null) {\n          assertEquals(\"doc \" + idx, values[idx], ss.getByOrd(ss.ord(idx),\n              bytesRef).utf8ToString());\n         int ord = ss\n              .getByValue(new BytesRef(values[idx]), new BytesRef());\n          assertTrue(ord >= 0);\n          assertEquals(ss.ord(idx), ord);\n        }\n      }\n\n      // Lookup random strings:\n      if (mode == Bytes.Mode.SORTED) {\n        final int valueCount = ss.getValueCount();\n        for (int i = 0; i < 1000; i++) {\n          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));\n          int ord = ss.getByValue(bytesValue, new BytesRef());\n          if (ord >= 0) {\n            assertTrue(bytesValue\n                .bytesEquals(ss.getByOrd(ord, bytesRef)));\n            int count = 0;\n            for (int k = 0; k < 100; k++) {\n              if (bytesValue.utf8ToString().equals(values[2 * k])) {\n                assertEquals(ss.ord(2 * k), ord);\n                count++;\n              }\n            }\n            assertTrue(count > 0);\n          } else {\n            assert ord < 0;\n            int insertIndex = (-ord)-1;\n            if (insertIndex == 0) {\n              final BytesRef firstRef = ss.getByOrd(1, bytesRef);\n              // random string was before our first\n              assertTrue(firstRef.compareTo(bytesValue) > 0);\n            } else if (insertIndex == valueCount) {\n              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);\n              // random string was after our last\n              assertTrue(lastRef.compareTo(bytesValue) < 0);\n            } else {\n              // TODO: I don't think this actually needs a deep copy?\n              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));\n              BytesRef after = ss.getByOrd(insertIndex, bytesRef);\n              assertTrue(COMP.compare(before, bytesValue) < 0);\n              assertTrue(COMP.compare(bytesValue, after) < 0);\n            }\n          }\n        }\n      }\n    }\n\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["2d84736c4614acce6720851cbd2c823d7cd516e4"],"3b7a068f550e13e49517c6899cc3b94c8eeb72e5":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"bc0b8069918917b33f361011899a1af0cdd2d462":["3b7a068f550e13e49517c6899cc3b94c8eeb72e5"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["e6e919043fa85ee891123768dd655a98edbbf63c","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","605b061fadf71aa6458c0005eaae83a98350c403"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["817d8435e9135b756f08ce6710ab0baac51bdf88","bc0b8069918917b33f361011899a1af0cdd2d462"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["f0b9507caf22f292ac0e5e59f62db4275adf4511","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["bc0b8069918917b33f361011899a1af0cdd2d462","1291e4568eb7d9463d751627596ef14baf4c1603"],"41e5bbad683f7546e96f08ffe8bc50cf447f2586":["4034ca0f8f74fdf56e25be73822f2441fc1c1b46"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"e6e919043fa85ee891123768dd655a98edbbf63c":["e128967bca58657bc0039d4bfe631e63e81f1977"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2e8d7ba2175f47e280231533f7d3016249cea88b"],"aa2fc2eb37a1f19e90850f787d9e085950ebfa04":["3bb13258feba31ab676502787ab2e1779f129b7a"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["b6f9be74ca7baaef11857ad002cad40419979516","3b7a068f550e13e49517c6899cc3b94c8eeb72e5"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","3b7a068f550e13e49517c6899cc3b94c8eeb72e5"],"b5c559c875836474bafae7243263d93b1b1965db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"17cc1e690c31c800f83860fbfd0423462962ef01":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"2d84736c4614acce6720851cbd2c823d7cd516e4":["b5c559c875836474bafae7243263d93b1b1965db"],"1291e4568eb7d9463d751627596ef14baf4c1603":["d083e83f225b11e5fdd900e83d26ddb385b6955c","bc0b8069918917b33f361011899a1af0cdd2d462"],"605b061fadf71aa6458c0005eaae83a98350c403":["41e5bbad683f7546e96f08ffe8bc50cf447f2586"],"4034ca0f8f74fdf56e25be73822f2441fc1c1b46":["aa2fc2eb37a1f19e90850f787d9e085950ebfa04"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["e6e919043fa85ee891123768dd655a98edbbf63c"],"e128967bca58657bc0039d4bfe631e63e81f1977":["17cc1e690c31c800f83860fbfd0423462962ef01"],"3bb13258feba31ab676502787ab2e1779f129b7a":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"]},"commit2Childs":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["3bb13258feba31ab676502787ab2e1779f129b7a"],"3b7a068f550e13e49517c6899cc3b94c8eeb72e5":["bc0b8069918917b33f361011899a1af0cdd2d462","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"bc0b8069918917b33f361011899a1af0cdd2d462":["f0b9507caf22f292ac0e5e59f62db4275adf4511","ddc4c914be86e34b54f70023f45a60fa7f04e929","1291e4568eb7d9463d751627596ef14baf4c1603"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["3b7a068f550e13e49517c6899cc3b94c8eeb72e5","b6f9be74ca7baaef11857ad002cad40419979516","a02058e0eaba4bbd5d05e6b06b9522c0acfd1655"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2e8d7ba2175f47e280231533f7d3016249cea88b","a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","b5c559c875836474bafae7243263d93b1b1965db","3bb13258feba31ab676502787ab2e1779f129b7a"],"b6f9be74ca7baaef11857ad002cad40419979516":["d083e83f225b11e5fdd900e83d26ddb385b6955c"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["5d004d0e0b3f65bb40da76d476d659d7888270e8","17cc1e690c31c800f83860fbfd0423462962ef01"],"41e5bbad683f7546e96f08ffe8bc50cf447f2586":["605b061fadf71aa6458c0005eaae83a98350c403"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e6e919043fa85ee891123768dd655a98edbbf63c":["d638301ad1cfcae567b681b893bc8781f0ee48a5","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"aa2fc2eb37a1f19e90850f787d9e085950ebfa04":["4034ca0f8f74fdf56e25be73822f2441fc1c1b46"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["1291e4568eb7d9463d751627596ef14baf4c1603"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["f0b9507caf22f292ac0e5e59f62db4275adf4511"],"b5c559c875836474bafae7243263d93b1b1965db":["2d84736c4614acce6720851cbd2c823d7cd516e4"],"2d84736c4614acce6720851cbd2c823d7cd516e4":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4"],"1291e4568eb7d9463d751627596ef14baf4c1603":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"17cc1e690c31c800f83860fbfd0423462962ef01":["e128967bca58657bc0039d4bfe631e63e81f1977"],"605b061fadf71aa6458c0005eaae83a98350c403":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"4034ca0f8f74fdf56e25be73822f2441fc1c1b46":["41e5bbad683f7546e96f08ffe8bc50cf447f2586"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"e128967bca58657bc0039d4bfe631e63e81f1977":["e6e919043fa85ee891123768dd655a98edbbf63c"],"3bb13258feba31ab676502787ab2e1779f129b7a":["aa2fc2eb37a1f19e90850f787d9e085950ebfa04"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}