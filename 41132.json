{"path":"lucene/sandbox/src/java/org/apache/lucene/rangetree/RangeTreeReader#intersect(long,long,SortedNumericDocValues,int).mjava","commits":[{"id":"8c12c43c449a172df0f2b122918f0f5fc0e9a470","date":1438415333,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/rangetree/RangeTreeReader#intersect(long,long,SortedNumericDocValues,int).mjava","pathOld":"/dev/null","sourceNew":"  public DocIdSet intersect(long minIncl, long maxIncl, SortedNumericDocValues sndv, int maxDoc) throws IOException {\n\n    if (minIncl > maxIncl) {\n      return DocIdSet.EMPTY;\n    }\n\n    if (minIncl > globalMaxValue || maxIncl < blockMinValues[0]) {\n      return DocIdSet.EMPTY;\n    }\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      minIncl, maxIncl,\n                                      sndv);\n\n    int startBlockIncl = Arrays.binarySearch(blockMinValues, minIncl);\n    if (startBlockIncl >= 0) {\n      // There can be dups here, when the same value is added many\n      // times.  Also, we need the first block whose min is < minIncl:\n      while (startBlockIncl > 0 && blockMinValues[startBlockIncl] == minIncl) {\n        startBlockIncl--;\n      }\n    } else {\n      startBlockIncl = Math.max(-startBlockIncl-2, 0);\n    }\n\n    int endBlockIncl = Arrays.binarySearch(blockMinValues, maxIncl);\n    if (endBlockIncl >= 0) {\n      // There can be dups here, when the same value is added many\n      // times.  Also, we need the first block whose max is > minIncl:\n      while (endBlockIncl < blockMinValues.length-1 && blockMinValues[endBlockIncl] == maxIncl) {\n        endBlockIncl++;\n      }\n    } else {\n      endBlockIncl = Math.max(-endBlockIncl-2, 0);\n    }\n\n    assert startBlockIncl <= endBlockIncl;\n\n    state.in.seek(blockFPs[startBlockIncl]);\n\n    //System.out.println(\"startBlockIncl=\" + startBlockIncl + \" endBlockIncl=\" + endBlockIncl);\n\n    // Rough estimate of how many hits we'll see.  Note that in the degenerate case\n    // (index same value many times) this could be a big over-estimate, but in the typical\n    // case it's good:\n    state.docs.grow(approxDocsPerBlock * (endBlockIncl - startBlockIncl + 1));\n\n    int hitCount = 0;\n    for (int block=startBlockIncl;block<=endBlockIncl;block++) {\n      boolean doFilter = blockMinValues[block] <= minIncl || block == blockMinValues.length-1 || blockMinValues[block+1] >= maxIncl;\n      //System.out.println(\"  block=\" + block + \" min=\" + blockMinValues[block] + \" doFilter=\" + doFilter);\n\n      int newCount;\n      if (doFilter) {\n        // We must filter each hit:\n        newCount = addSome(state);\n      } else {\n        newCount = addAll(state);\n      }\n\n      hitCount += newCount;\n    }\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return state.docs.build(hitCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/rangetree/RangeTreeReader#intersect(long,long,SortedNumericDocValues,int).mjava","sourceNew":null,"sourceOld":"  public DocIdSet intersect(long minIncl, long maxIncl, SortedNumericDocValues sndv, int maxDoc) throws IOException {\n\n    if (minIncl > maxIncl) {\n      return DocIdSet.EMPTY;\n    }\n\n    if (minIncl > globalMaxValue || maxIncl < blockMinValues[0]) {\n      return DocIdSet.EMPTY;\n    }\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      minIncl, maxIncl,\n                                      sndv);\n\n    int startBlockIncl = Arrays.binarySearch(blockMinValues, minIncl);\n    if (startBlockIncl >= 0) {\n      // There can be dups here, when the same value is added many\n      // times.  Also, we need the first block whose min is < minIncl:\n      while (startBlockIncl > 0 && blockMinValues[startBlockIncl] == minIncl) {\n        startBlockIncl--;\n      }\n    } else {\n      startBlockIncl = Math.max(-startBlockIncl-2, 0);\n    }\n\n    int endBlockIncl = Arrays.binarySearch(blockMinValues, maxIncl);\n    if (endBlockIncl >= 0) {\n      // There can be dups here, when the same value is added many\n      // times.  Also, we need the first block whose max is > minIncl:\n      while (endBlockIncl < blockMinValues.length-1 && blockMinValues[endBlockIncl] == maxIncl) {\n        endBlockIncl++;\n      }\n    } else {\n      endBlockIncl = Math.max(-endBlockIncl-2, 0);\n    }\n\n    assert startBlockIncl <= endBlockIncl;\n\n    state.in.seek(blockFPs[startBlockIncl]);\n\n    //System.out.println(\"startBlockIncl=\" + startBlockIncl + \" endBlockIncl=\" + endBlockIncl);\n\n    // Rough estimate of how many hits we'll see.  Note that in the degenerate case\n    // (index same value many times) this could be a big over-estimate, but in the typical\n    // case it's good:\n    state.docs.grow(approxDocsPerBlock * (endBlockIncl - startBlockIncl + 1));\n\n    int hitCount = 0;\n    for (int block=startBlockIncl;block<=endBlockIncl;block++) {\n      boolean doFilter = blockMinValues[block] <= minIncl || block == blockMinValues.length-1 || blockMinValues[block+1] >= maxIncl;\n      //System.out.println(\"  block=\" + block + \" min=\" + blockMinValues[block] + \" doFilter=\" + doFilter);\n\n      int newCount;\n      if (doFilter) {\n        // We must filter each hit:\n        newCount = addSome(state);\n      } else {\n        newCount = addAll(state);\n      }\n\n      hitCount += newCount;\n    }\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return state.docs.build(hitCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8c12c43c449a172df0f2b122918f0f5fc0e9a470":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["8c12c43c449a172df0f2b122918f0f5fc0e9a470"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"8c12c43c449a172df0f2b122918f0f5fc0e9a470":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c12c43c449a172df0f2b122918f0f5fc0e9a470"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}