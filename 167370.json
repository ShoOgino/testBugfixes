{"path":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","pathOld":"lucene/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","sourceNew":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported. */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    long i = b & 0x7FL;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    assert (b & 0x80) == 0;\n    return i | ((b & 0x7FL) << 56);\n  }\n\n","sourceOld":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported. */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    long i = b & 0x7FL;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    assert (b & 0x80) == 0;\n    return i | ((b & 0x7FL) << 56);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d91b7936af3081e704512ac1234340133e59904","date":1332109642,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","sourceNew":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported. */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    long i = b & 0x7FL;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 56;\n    if ((b & 0x80) == 0) return i;\n    throw new IOException(\"Invalid vLong detected (negative values disallowed)\");\n  }\n\n","sourceOld":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported. */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    long i = b & 0x7FL;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    assert (b & 0x80) == 0;\n    return i | ((b & 0x7FL) << 56);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"231a0ded093edb0044905980e2607acfc3f6a954","date":1333229599,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","sourceNew":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported. */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    long i = b & 0x7FL;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 56;\n    if (b >= 0) return i;\n    throw new IOException(\"Invalid vLong detected (negative values disallowed)\");\n  }\n\n","sourceOld":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported. */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    long i = b & 0x7FL;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if ((b & 0x80) == 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 56;\n    if ((b & 0x80) == 0) return i;\n    throw new IOException(\"Invalid vLong detected (negative values disallowed)\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e624b56e48bba276e76b66c9eb1bbb9994b0ffa","date":1335382601,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","sourceNew":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * <p>\n   * The format is described further in {@link DataOutput#writeVInt(int)}.\n   * \n   * @see DataOutput#writeVLong(long)\n   */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    long i = b & 0x7FL;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 56;\n    if (b >= 0) return i;\n    throw new IOException(\"Invalid vLong detected (negative values disallowed)\");\n  }\n\n","sourceOld":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported. */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    long i = b & 0x7FL;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 56;\n    if (b >= 0) return i;\n    throw new IOException(\"Invalid vLong detected (negative values disallowed)\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee0a782aba5788b03bbf2ba679d4f4b0ebc88493","date":1406810962,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/DataInput#readVLong().mjava","sourceNew":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * <p>\n   * The format is described further in {@link DataOutput#writeVInt(int)}.\n   * \n   * @see DataOutput#writeVLong(long)\n   */\n  public long readVLong() throws IOException {\n    return readVLong(false);\n  }\n\n","sourceOld":"  /** Reads a long stored in variable-length format.  Reads between one and\n   * nine bytes.  Smaller values take fewer bytes.  Negative numbers are not\n   * supported.\n   * <p>\n   * The format is described further in {@link DataOutput#writeVInt(int)}.\n   * \n   * @see DataOutput#writeVLong(long)\n   */\n  public long readVLong() throws IOException {\n    /* This is the original code of this method,\n     * but a Hotspot bug (see LUCENE-2975) corrupts the for-loop if\n     * readByte() is inlined. So the loop was unwinded!\n    byte b = readByte();\n    long i = b & 0x7F;\n    for (int shift = 7; (b & 0x80) != 0; shift += 7) {\n      b = readByte();\n      i |= (b & 0x7FL) << shift;\n    }\n    return i;\n    */\n    byte b = readByte();\n    if (b >= 0) return b;\n    long i = b & 0x7FL;\n    b = readByte();\n    i |= (b & 0x7FL) << 7;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 14;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 21;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 28;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 35;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 42;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 49;\n    if (b >= 0) return i;\n    b = readByte();\n    i |= (b & 0x7FL) << 56;\n    if (b >= 0) return i;\n    throw new IOException(\"Invalid vLong detected (negative values disallowed)\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"231a0ded093edb0044905980e2607acfc3f6a954":["7d91b7936af3081e704512ac1234340133e59904"],"ee0a782aba5788b03bbf2ba679d4f4b0ebc88493":["2e624b56e48bba276e76b66c9eb1bbb9994b0ffa"],"2e624b56e48bba276e76b66c9eb1bbb9994b0ffa":["231a0ded093edb0044905980e2607acfc3f6a954"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7d91b7936af3081e704512ac1234340133e59904":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ee0a782aba5788b03bbf2ba679d4f4b0ebc88493"]},"commit2Childs":{"231a0ded093edb0044905980e2607acfc3f6a954":["2e624b56e48bba276e76b66c9eb1bbb9994b0ffa"],"ee0a782aba5788b03bbf2ba679d4f4b0ebc88493":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2e624b56e48bba276e76b66c9eb1bbb9994b0ffa":["ee0a782aba5788b03bbf2ba679d4f4b0ebc88493"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["7d91b7936af3081e704512ac1234340133e59904"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7d91b7936af3081e704512ac1234340133e59904":["231a0ded093edb0044905980e2607acfc3f6a954"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}