{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsIntersectTermsEnumFrame#load(Output).mjava","commits":[{"id":"0cdf9cc6702d60334a616bd7db3ae91501d1dce7","date":1405858112,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsIntersectTermsEnumFrame#load(Output).mjava","pathOld":"/dev/null","sourceNew":"  void load(Output output) throws IOException {\n\n    // if (DEBUG) System.out.println(\"    load fp=\" + fp + \" fpOrig=\" + fpOrig + \" frameIndexData=\" + frameIndexData + \" trans=\" + (transitions.length != 0 ? transitions[0] : \"n/a\" + \" state=\" + state));\n\n    if (output != null && output.bytes != null && transitionCount != 0) {\n      BytesRef frameIndexData = output.bytes;\n\n      // Floor frame\n      if (floorData.length < frameIndexData.length) {\n        this.floorData = new byte[ArrayUtil.oversize(frameIndexData.length, 1)];\n      }\n      System.arraycopy(frameIndexData.bytes, frameIndexData.offset, floorData, 0, frameIndexData.length);\n      floorDataReader.reset(floorData, 0, frameIndexData.length);\n      final long code = floorDataReader.readVLong();\n      if ((code & OrdsBlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0) {\n        numFollowFloorBlocks = floorDataReader.readVInt();\n        nextFloorLabel = floorDataReader.readByte() & 0xff;\n\n        termOrd = termOrdOrig + floorDataReader.readVLong();\n\n        // if (DEBUG) System.out.println(\"    numFollowFloorBlocks=\" + numFollowFloorBlocks + \" nextFloorLabel=\" + nextFloorLabel);\n\n        // If current state is accept, we must process\n        // first block in case it has empty suffix:\n        if (!ite.runAutomaton.isAccept(state)) {\n          // Maybe skip floor blocks:\n          assert transitionIndex == 0: \"transitionIndex=\" + transitionIndex;\n          while (numFollowFloorBlocks != 0 && nextFloorLabel <= transition.min) {\n            fp = fpOrig + (floorDataReader.readVLong() >>> 1);\n            numFollowFloorBlocks--;\n            // if (DEBUG) System.out.println(\"    skip floor block!  nextFloorLabel=\" + (char) nextFloorLabel + \" vs target=\" + (char) transitions[0].getMin() + \" newFP=\" + fp + \" numFollowFloorBlocks=\" + numFollowFloorBlocks);\n            if (numFollowFloorBlocks != 0) {\n              nextFloorLabel = floorDataReader.readByte() & 0xff;\n              termOrd += floorDataReader.readVLong();\n            } else {\n              nextFloorLabel = 256;\n            }\n          }\n        }\n      }\n    }\n\n    ite.in.seek(fp);\n    int code = ite.in.readVInt();\n    entCount = code >>> 1;\n    assert entCount > 0;\n    isLastInFloor = (code & 1) != 0;\n\n    // term suffixes:\n    code = ite.in.readVInt();\n    isLeafBlock = (code & 1) != 0;\n    int numBytes = code >>> 1;\n    // if (DEBUG) System.out.println(\"      entCount=\" + entCount + \" lastInFloor?=\" + isLastInFloor + \" leafBlock?=\" + isLeafBlock + \" numSuffixBytes=\" + numBytes);\n    if (suffixBytes.length < numBytes) {\n      suffixBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(suffixBytes, 0, numBytes);\n    suffixesReader.reset(suffixBytes, 0, numBytes);\n\n    // stats\n    numBytes = ite.in.readVInt();\n    if (statBytes.length < numBytes) {\n      statBytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(statBytes, 0, numBytes);\n    statsReader.reset(statBytes, 0, numBytes);\n    metaDataUpto = 0;\n\n    termState.termBlockOrd = 0;\n    nextEnt = 0;\n         \n    // metadata\n    numBytes = ite.in.readVInt();\n    if (bytes == null) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n      bytesReader = new ByteArrayDataInput();\n    } else if (bytes.length < numBytes) {\n      bytes = new byte[ArrayUtil.oversize(numBytes, 1)];\n    }\n    ite.in.readBytes(bytes, 0, numBytes);\n    bytesReader.reset(bytes, 0, numBytes);\n\n    if (!isLastInFloor) {\n      // Sub-blocks of a single floor block are always\n      // written one after another -- tail recurse:\n      fpEnd = ite.in.getFilePointer();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"]},"commit2Childs":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}