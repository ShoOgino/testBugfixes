{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"/dev/null","sourceNew":"  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"698fd91cb8c785a590bd5c01480b332c10deb757","date":1455013336,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b844e2ae5435a8d4d925003c10027c25e26e02d","date":1455044345,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"/dev/null","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d97ba94eef1fc33c5451259a7aa2ac682646c1af","date":1488285427,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    if (indexCreatedVersion != null) {\n      // 7.0+ index\n      out.writeByte((byte) 1);\n      out.writeVInt(indexCreatedVersion.major);\n      out.writeVInt(indexCreatedVersion.minor);\n      out.writeVInt(indexCreatedVersion.bugfix);\n    } else {\n      // pre-7.0 index\n      out.writeByte((byte) 0);\n    }\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    if (indexCreatedVersion != null) {\n      // 7.0+ index\n      out.writeByte((byte) 1);\n      out.writeVInt(indexCreatedVersion.major);\n      out.writeVInt(indexCreatedVersion.minor);\n      out.writeVInt(indexCreatedVersion.bugfix);\n    } else {\n      // pre-7.0 index\n      out.writeByte((byte) 0);\n    }\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    if (indexCreatedVersion != null) {\n      // 7.0+ index\n      out.writeByte((byte) 1);\n      out.writeVInt(indexCreatedVersion.major);\n      out.writeVInt(indexCreatedVersion.minor);\n      out.writeVInt(indexCreatedVersion.bugfix);\n    } else {\n      // pre-7.0 index\n      out.writeByte((byte) 0);\n    }\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba","date":1499240590,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e73d8d559120669b47658108d818b637df5456ea","date":1499401413,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n      if (segmentID == null) {\n        out.writeByte((byte)0);\n      } else {\n        if (segmentID.length != StringHelper.ID_LENGTH) {\n          throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n        }\n        out.writeByte((byte)1);\n        out.writeBytes(segmentID, segmentID.length);\n      }\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0617d2d25b13b9a49450ea49ceb06123ebd6542a","date":1508865221,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version); \n    out.writeInt(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f2203cb8ae87188877cfbf6ad170c5738a0aad5","date":1528117512,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      int softDelCount = siPerCommit.getSoftDelCount();\n      if (softDelCount < 0 || softDelCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" softDelCount=\" + softDelCount);\n      }\n      out.writeInt(softDelCount);\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      int softDelCount = siPerCommit.getSoftDelCount();\n      if (softDelCount < 0 || softDelCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" softDelCount=\" + softDelCount);\n      }\n      out.writeInt(softDelCount);\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      int softDelCount = siPerCommit.getSoftDelCount();\n      if (softDelCount < 0 || softDelCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" softDelCount=\" + softDelCount);\n      }\n      out.writeInt(softDelCount);\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14654be3f7a82c9a3c52169e365baa55bfe64f66","date":1587212697,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,IndexOutput).mjava","sourceNew":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      int softDelCount = siPerCommit.getSoftDelCount();\n      if (softDelCount < 0 || softDelCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" softDelCount=\" + softDelCount);\n      }\n      out.writeInt(softDelCount);\n      // we ensure that there is a valid ID for this SCI just in case\n      // this is manually upgraded outside of IW\n      byte[] sciId = siPerCommit.getId();\n      if (sciId != null) {\n        out.writeByte((byte)1);\n        assert sciId.length == StringHelper.ID_LENGTH : \"invalid SegmentCommitInfo#id: \" + Arrays.toString(sciId);\n        out.writeBytes(sciId, 0, sciId.length);\n      } else {\n        out.writeByte((byte)0);\n      }\n\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","sourceOld":"  /** Write ourselves to the provided {@link IndexOutput} */\n  public void write(Directory directory, IndexOutput out) throws IOException {\n    CodecUtil.writeIndexHeader(out, \"segments\", VERSION_CURRENT, \n                               StringHelper.randomId(), Long.toString(generation, Character.MAX_RADIX));\n    out.writeVInt(Version.LATEST.major);\n    out.writeVInt(Version.LATEST.minor);\n    out.writeVInt(Version.LATEST.bugfix);\n    //System.out.println(Thread.currentThread().getName() + \": now write \" + out.getName() + \" with version=\" + version);\n\n    out.writeVInt(indexCreatedVersionMajor);\n\n    out.writeLong(version);\n    out.writeVLong(counter); // write counter\n    out.writeInt(size());\n\n    if (size() > 0) {\n\n      Version minSegmentVersion = null;\n\n      // We do a separate loop up front so we can write the minSegmentVersion before\n      // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n      for (SegmentCommitInfo siPerCommit : this) {\n        Version segmentVersion = siPerCommit.info.getVersion();\n        if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n          minSegmentVersion = segmentVersion;\n        }\n      }\n\n      out.writeVInt(minSegmentVersion.major);\n      out.writeVInt(minSegmentVersion.minor);\n      out.writeVInt(minSegmentVersion.bugfix);\n    }\n\n    // write infos\n    for (SegmentCommitInfo siPerCommit : this) {\n      SegmentInfo si = siPerCommit.info;\n      if (indexCreatedVersionMajor >= 7 && si.minVersion == null) {\n        throw new IllegalStateException(\"Segments must record minVersion if they have been created on or after Lucene 7: \" + si);\n      }\n      out.writeString(si.name);\n      byte segmentID[] = si.getId();\n      if (segmentID.length != StringHelper.ID_LENGTH) {\n        throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n      }\n      out.writeBytes(segmentID, segmentID.length);\n      out.writeString(si.getCodec().getName());\n      out.writeLong(siPerCommit.getDelGen());\n      int delCount = siPerCommit.getDelCount();\n      if (delCount < 0 || delCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n      }\n      out.writeInt(delCount);\n      out.writeLong(siPerCommit.getFieldInfosGen());\n      out.writeLong(siPerCommit.getDocValuesGen());\n      int softDelCount = siPerCommit.getSoftDelCount();\n      if (softDelCount < 0 || softDelCount > si.maxDoc()) {\n        throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" softDelCount=\" + softDelCount);\n      }\n      out.writeInt(softDelCount);\n      out.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n      final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n      out.writeInt(dvUpdatesFiles.size());\n      for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n        out.writeInt(e.getKey());\n        out.writeSetOfStrings(e.getValue());\n      }\n    }\n    out.writeMapOfStrings(userData);\n    CodecUtil.writeFooter(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"698fd91cb8c785a590bd5c01480b332c10deb757":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"0617d2d25b13b9a49450ea49ceb06123ebd6542a":["433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["698fd91cb8c785a590bd5c01480b332c10deb757"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["0617d2d25b13b9a49450ea49ceb06123ebd6542a","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2b844e2ae5435a8d4d925003c10027c25e26e02d"],"e73d8d559120669b47658108d818b637df5456ea":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["68496c2200e559fb7802f7575427b7a482659afb"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"f592209545c71895260367152601e9200399776d":["0617d2d25b13b9a49450ea49ceb06123ebd6542a","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"698fd91cb8c785a590bd5c01480b332c10deb757":["2b844e2ae5435a8d4d925003c10027c25e26e02d"],"433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba":["0617d2d25b13b9a49450ea49ceb06123ebd6542a","e73d8d559120669b47658108d818b637df5456ea"],"0617d2d25b13b9a49450ea49ceb06123ebd6542a":["b70042a8a492f7054d480ccdd2be9796510d4327","8f2203cb8ae87188877cfbf6ad170c5738a0aad5","f592209545c71895260367152601e9200399776d"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["68496c2200e559fb7802f7575427b7a482659afb"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"68496c2200e559fb7802f7575427b7a482659afb":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"e73d8d559120669b47658108d818b637df5456ea":[],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["e73d8d559120669b47658108d818b637df5456ea"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["14654be3f7a82c9a3c52169e365baa55bfe64f66","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":[],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["698fd91cb8c785a590bd5c01480b332c10deb757"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","e73d8d559120669b47658108d818b637df5456ea","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}