{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b48c161f84bef42b6b1a2efa87dc10deed2b3c06","date":1343344525,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 56: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 57: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 58: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 61: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 66: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 73: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 74: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 76: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 77: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 78: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 79: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 80: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 81: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 82: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 85: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 86: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 87: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 88: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 89: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 90: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 91: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 92: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 93: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 94: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 95: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 96: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 97: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 98: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 99: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 100: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 103: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 104: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 105: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 56: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 57: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 58: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 61: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 66: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 73: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 74: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 76: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 77: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 78: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 79: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 80: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 81: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 82: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 85: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 86: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 87: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 88: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 89: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 90: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 91: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 92: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 93: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 94: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 95: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 96: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 97: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 98: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 99: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 100: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 103: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 104: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 105: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 56: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 57: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 58: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 61: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 66: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 73: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 74: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 76: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 77: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 78: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 79: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 80: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 81: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 82: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 85: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 86: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 87: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 88: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 89: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 90: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 91: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 92: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 93: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 94: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 95: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 96: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 97: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 98: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 99: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 100: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 103: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 104: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 105: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46ebd94e5ce1e52e512f43684c9b68896ce5966f","date":1344273407,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 56: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 57: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 58: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 61: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 66: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 73: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 74: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 76: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 77: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 78: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 79: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 80: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 81: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 82: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 85: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 86: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 87: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 88: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 89: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 90: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 91: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 92: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 93: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 94: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 95: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 96: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 97: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 98: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 99: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 100: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 103: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 104: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 105: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 56: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 57: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 58: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 61: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 66: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 73: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 74: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 76: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 77: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 78: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 79: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 80: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 81: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 82: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 85: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 86: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 87: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 88: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 89: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 90: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 91: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 92: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 93: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 94: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 95: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 96: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 97: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 98: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 99: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 100: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 103: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 104: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 105: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 56: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 57: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 58: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 61: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 62: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 63: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 64: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 65: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 66: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 68: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 69: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 71: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 72: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 73: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 74: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 76: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 77: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 78: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 79: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 80: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 81: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 82: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 83: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 84: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 85: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 86: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 87: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 88: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 89: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 90: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 91: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 92: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 93: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 94: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 95: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 96: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 97: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 98: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 99: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 100: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 103: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 104: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 105: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 56: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 57: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 58: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 59: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 60: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 61: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 62: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 63: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 64: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 65: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 66: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 67: break;\n        case 15: \n          { \n          }\n        case 68: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 69: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 71: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 72: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 73: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 75: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 76: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 77: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 78: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 79: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 80: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 81: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 82: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 83: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 87: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 90: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 91: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 92: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 93: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 94: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 95: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 96: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 97: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 98: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 100: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 103: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 15: \n          { \n          }\n        case 54: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 55: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 56: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 57: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 58: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 59: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 60: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 61: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 62: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 63: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 64: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 65: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 66: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 67: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 68: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 69: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 70: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 72: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 73: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 75: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 76: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 77: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 78: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 79: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 80: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 81: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 82: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 83: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 84: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 85: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 86: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 87: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 88: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 89: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 90: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 91: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 92: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 93: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 94: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 95: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 96: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 97: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 98: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 99: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 100: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 102: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 103: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 104: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 105: break;\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["ab081a78869a616f9c93e5b2f3ec2f99c2f7f741"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab081a78869a616f9c93e5b2f3ec2f99c2f7f741","date":1397714897,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 56: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 57: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 58: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 59: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 60: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 61: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 62: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 63: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 64: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 65: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 66: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 67: break;\n        case 15: \n          { \n          }\n        case 68: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 69: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 71: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 72: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 73: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 75: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 76: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 77: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 78: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 79: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 80: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 81: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 82: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 83: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 32: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"--\" - this is not a comment\n      inputSegment.append(yytext());\n    } else {\n      yybegin(COMMENT);\n    }\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 87: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 90: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 91: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 92: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 93: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 94: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 95: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 96: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 97: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 98: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 47: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"[CDATA[\" - this is not a CDATA section\n      inputSegment.append(yytext());\n    } else {\n      // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n      cumulativeDiff += inputSegment.length() + yylength();\n      // position the correction at (already output length) [ + (substitution length) = 0 ]\n      addOffCorrectMap(outputCharCount, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(CDATA);\n    }\n          }\n        case 100: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 103: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 56: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 57: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 58: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 59: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 60: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 61: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 62: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 63: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 64: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 65: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 66: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 67: break;\n        case 15: \n          { \n          }\n        case 68: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 69: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 71: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 72: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 73: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 75: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 76: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 77: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 78: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 79: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 80: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 81: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 82: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 83: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 32: \n          { yybegin(COMMENT);\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 87: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 90: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 91: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 92: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 93: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 94: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 95: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 96: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 97: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 98: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 47: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(CDATA);\n          }\n        case 100: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 103: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f0c6d69031c318c402abfe2543736076e80a132","date":1404594729,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { outputSegment.append(yytext()); return outputSegment.nextChar();\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 56: break;\n        case 4: \n          { yypushback(yylength());\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 57: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 58: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 59: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 60: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 61: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 62: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 63: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 64: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 65: break;\n        case 13: \n          { inputSegment.append(yytext());\n          }\n        case 66: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 67: break;\n        case 15: \n          { \n          }\n        case 68: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 69: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 71: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 72: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 73: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 75: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 76: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 77: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 78: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 79: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 80: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 81: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 82: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 83: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 32: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"--\" - this is not a comment\n      inputSegment.append(yytext());\n    } else {\n      yybegin(COMMENT);\n    }\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 87: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 90: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 91: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 92: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 93: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 94: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 95: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 96: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 97: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 98: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 47: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"[CDATA[\" - this is not a CDATA section\n      inputSegment.append(yytext());\n    } else {\n      // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n      cumulativeDiff += inputSegment.length() + yylength();\n      // position the correction at (already output length) [ + (substitution length) = 0 ]\n      addOffCorrectMap(outputCharCount, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(CDATA);\n    }\n          }\n        case 100: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 103: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { return zzBuffer[zzStartRead];\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 56: break;\n        case 4: \n          { yypushback(1);\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 57: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 58: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 59: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 60: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 61: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 62: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 63: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 64: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 65: break;\n        case 13: \n          { inputSegment.append(zzBuffer[zzStartRead]);\n          }\n        case 66: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 67: break;\n        case 15: \n          { \n          }\n        case 68: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 69: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 71: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 72: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 73: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 75: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 76: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 77: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 78: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 79: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 80: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 81: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 82: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 83: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 32: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"--\" - this is not a comment\n      inputSegment.append(yytext());\n    } else {\n      yybegin(COMMENT);\n    }\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 87: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 90: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 91: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 92: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 93: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 94: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 95: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 96: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 97: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 98: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 47: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"[CDATA[\" - this is not a CDATA section\n      inputSegment.append(yytext());\n    } else {\n      // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n      cumulativeDiff += inputSegment.length() + yylength();\n      // position the correction at (already output length) [ + (substitution length) = 0 ]\n      addOffCorrectMap(outputCharCount, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(CDATA);\n    }\n          }\n        case 100: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 103: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c00ffa555aa637d932f7d491038cf9992403994","date":1408702746,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { if (yylength() == 1) {\n    return zzBuffer[zzStartRead];\n  } else {\n    outputSegment.append(yytext()); return outputSegment.nextChar();\n  }\n          }\n        case 55: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 56: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 57: break;\n        case 4: \n          { yypushback(yylength());\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 58: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 59: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 60: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 61: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 62: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 63: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 64: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 65: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 66: break;\n        case 13: \n          { inputSegment.append(yytext());\n          }\n        case 67: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 68: break;\n        case 15: \n          { \n          }\n        case 69: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 72: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 73: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 74: break;\n        case 21: \n          { if (yylength() == 1) {\n      return zzBuffer[zzStartRead];\n    } else {\n      outputSegment.append(yytext()); return outputSegment.nextChar();\n    }\n          }\n        case 75: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 76: break;\n        case 23: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 77: break;\n        case 24: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 78: break;\n        case 25: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 79: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 80: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 81: break;\n        case 28: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 82: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 83: break;\n        case 30: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 84: break;\n        case 31: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 85: break;\n        case 32: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 86: break;\n        case 33: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"--\" - this is not a comment\n      inputSegment.append(yytext());\n    } else {\n      yybegin(COMMENT);\n    }\n          }\n        case 87: break;\n        case 34: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 88: break;\n        case 35: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 89: break;\n        case 36: \n          { yybegin(SCRIPT);\n          }\n        case 90: break;\n        case 37: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 91: break;\n        case 38: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 92: break;\n        case 39: \n          { yybegin(restoreState);\n          }\n        case 93: break;\n        case 40: \n          { yybegin(STYLE);\n          }\n        case 94: break;\n        case 41: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 95: break;\n        case 42: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 96: break;\n        case 43: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 97: break;\n        case 44: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 98: break;\n        case 45: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 99: break;\n        case 46: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 100: break;\n        case 47: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 48: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"[CDATA[\" - this is not a CDATA section\n      inputSegment.append(yytext());\n    } else {\n      // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n      cumulativeDiff += inputSegment.length() + yylength();\n      // position the correction at (already output length) [ + (substitution length) = 0 ]\n      addOffCorrectMap(outputCharCount, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(CDATA);\n    }\n          }\n        case 102: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 103: break;\n        case 50: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 104: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 105: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 107: break;\n        case 54: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { outputSegment.append(yytext()); return outputSegment.nextChar();\n          }\n        case 54: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 55: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 56: break;\n        case 4: \n          { yypushback(yylength());\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 57: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 58: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 59: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 60: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 61: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 62: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 63: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 64: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 65: break;\n        case 13: \n          { inputSegment.append(yytext());\n          }\n        case 66: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 67: break;\n        case 15: \n          { \n          }\n        case 68: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 69: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 71: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 72: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 73: break;\n        case 21: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 74: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 75: break;\n        case 23: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 76: break;\n        case 24: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 77: break;\n        case 25: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 78: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 79: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 80: break;\n        case 28: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 81: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 82: break;\n        case 30: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 83: break;\n        case 31: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 84: break;\n        case 32: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"--\" - this is not a comment\n      inputSegment.append(yytext());\n    } else {\n      yybegin(COMMENT);\n    }\n          }\n        case 85: break;\n        case 33: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 86: break;\n        case 34: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 87: break;\n        case 35: \n          { yybegin(SCRIPT);\n          }\n        case 88: break;\n        case 36: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 89: break;\n        case 37: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 90: break;\n        case 38: \n          { yybegin(restoreState);\n          }\n        case 91: break;\n        case 39: \n          { yybegin(STYLE);\n          }\n        case 92: break;\n        case 40: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 93: break;\n        case 41: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 94: break;\n        case 42: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 95: break;\n        case 43: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 96: break;\n        case 44: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 97: break;\n        case 45: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 98: break;\n        case 46: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 99: break;\n        case 47: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"[CDATA[\" - this is not a CDATA section\n      inputSegment.append(yytext());\n    } else {\n      // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n      cumulativeDiff += inputSegment.length() + yylength();\n      // position the correction at (already output length) [ + (substitution length) = 0 ]\n      addOffCorrectMap(outputCharCount, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(CDATA);\n    }\n          }\n        case 100: break;\n        case 48: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 101: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 102: break;\n        case 50: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 103: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 104: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 105: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8c6c25f6bab8e32b731127f3516a593af8a3305","date":1546972429,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter#nextChar().mjava","sourceNew":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n            zzDoEOF();\n          {   return eofReturnValue;\n }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { if (yylength() == 1) {\n    return zzBuffer[zzStartRead];\n  } else {\n    outputSegment.append(yytext()); return outputSegment.nextChar();\n  }\n            } \n            // fall through\n          case 55: break;\n          case 2: \n            { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n            } \n            // fall through\n          case 56: break;\n          case 3: \n            { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n            } \n            // fall through\n          case 57: break;\n          case 4: \n            { yypushback(yylength());\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n            } \n            // fall through\n          case 58: break;\n          case 5: \n            { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n            } \n            // fall through\n          case 59: break;\n          case 6: \n            { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n            } \n            // fall through\n          case 60: break;\n          case 7: \n            { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n            } \n            // fall through\n          case 61: break;\n          case 8: \n            { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n            } \n            // fall through\n          case 62: break;\n          case 9: \n            { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n            } \n            // fall through\n          case 63: break;\n          case 10: \n            { inputSegment.append('!'); yybegin(BANG);\n            } \n            // fall through\n          case 64: break;\n          case 11: \n            { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n            } \n            // fall through\n          case 65: break;\n          case 12: \n            { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n            } \n            // fall through\n          case 66: break;\n          case 13: \n            { inputSegment.append(yytext());\n            } \n            // fall through\n          case 67: break;\n          case 14: \n            { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n            } \n            // fall through\n          case 68: break;\n          case 15: \n            { \n            } \n            // fall through\n          case 69: break;\n          case 16: \n            { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n            } \n            // fall through\n          case 70: break;\n          case 17: \n            { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n            } \n            // fall through\n          case 71: break;\n          case 18: \n            { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n            } \n            // fall through\n          case 72: break;\n          case 19: \n            { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n            } \n            // fall through\n          case 73: break;\n          case 20: \n            { inputSegment.write(zzBuffer, zzStartRead, yylength());\n            } \n            // fall through\n          case 74: break;\n          case 21: \n            { if (yylength() == 1) {\n      return zzBuffer[zzStartRead];\n    } else {\n      outputSegment.append(yytext()); return outputSegment.nextChar();\n    }\n            } \n            // fall through\n          case 75: break;\n          case 22: \n            { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n            } \n            // fall through\n          case 76: break;\n          case 23: \n            { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n            } \n            // fall through\n          case 77: break;\n          case 24: \n            { yybegin(restoreState); restoreState = previousRestoreState;\n            } \n            // fall through\n          case 78: break;\n          case 25: \n            { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n            } \n            // fall through\n          case 79: break;\n          case 26: \n            { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n            } \n            // fall through\n          case 80: break;\n          case 27: \n            { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n            } \n            // fall through\n          case 81: break;\n          case 28: \n            { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n            } \n            // fall through\n          case 82: break;\n          case 29: \n            { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n            } \n            // fall through\n          case 83: break;\n          case 30: \n            { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n            } \n            // fall through\n          case 84: break;\n          case 31: \n            { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n            } \n            // fall through\n          case 85: break;\n          case 32: \n            { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n            } \n            // fall through\n          case 86: break;\n          case 33: \n            { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"--\" - this is not a comment\n      inputSegment.append(yytext());\n    } else {\n      yybegin(COMMENT);\n    }\n            } \n            // fall through\n          case 87: break;\n          case 34: \n            { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n            } \n            // fall through\n          case 88: break;\n          case 35: \n            { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n            } \n            // fall through\n          case 89: break;\n          case 36: \n            { yybegin(SCRIPT);\n            } \n            // fall through\n          case 90: break;\n          case 37: \n            { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n            } \n            // fall through\n          case 91: break;\n          case 38: \n            { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n            } \n            // fall through\n          case 92: break;\n          case 39: \n            { yybegin(restoreState);\n            } \n            // fall through\n          case 93: break;\n          case 40: \n            { yybegin(STYLE);\n            } \n            // fall through\n          case 94: break;\n          case 41: \n            { yybegin(SCRIPT_COMMENT);\n            } \n            // fall through\n          case 95: break;\n          case 42: \n            { yybegin(STYLE_COMMENT);\n            } \n            // fall through\n          case 96: break;\n          case 43: \n            { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n            } \n            // fall through\n          case 97: break;\n          case 44: \n            { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n            } \n            // fall through\n          case 98: break;\n          case 45: \n            { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n            } \n            // fall through\n          case 99: break;\n          case 46: \n            { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n            } \n            // fall through\n          case 100: break;\n          case 47: \n            { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n            } \n            // fall through\n          case 101: break;\n          case 48: \n            { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"[CDATA[\" - this is not a CDATA section\n      inputSegment.append(yytext());\n    } else {\n      // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n      cumulativeDiff += inputSegment.length() + yylength();\n      // position the correction at (already output length) [ + (substitution length) = 0 ]\n      addOffCorrectMap(outputCharCount, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(CDATA);\n    }\n            } \n            // fall through\n          case 102: break;\n          case 49: \n            { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n            } \n            // fall through\n          case 103: break;\n          case 50: \n            { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n            } \n            // fall through\n          case 104: break;\n          case 51: \n            { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n            } \n            // fall through\n          case 105: break;\n          case 52: \n            { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n            } \n            // fall through\n          case 106: break;\n          case 53: \n            { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n            } \n            // fall through\n          case 107: break;\n          case 54: \n            { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n            } \n            // fall through\n          case 108: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  private int nextChar() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      // set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { if (yylength() == 1) {\n    return zzBuffer[zzStartRead];\n  } else {\n    outputSegment.append(yytext()); return outputSegment.nextChar();\n  }\n          }\n        case 55: break;\n        case 2: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('<');\n  yybegin(LEFT_ANGLE_BRACKET);\n          }\n        case 56: break;\n        case 3: \n          { inputStart = yychar;\n  inputSegment.clear();\n  inputSegment.append('&');\n  yybegin(AMPERSAND);\n          }\n        case 57: break;\n        case 4: \n          { yypushback(yylength());\n    outputSegment = inputSegment;\n    outputSegment.restart();\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 58: break;\n        case 5: \n          { inputSegment.append('#'); yybegin(NUMERIC_CHARACTER);\n          }\n        case 59: break;\n        case 6: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 7) { // 0x10FFFF = 1114111: max 7 decimal chars\n      String decimalCharRef = yytext();\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(decimalCharRef);\n      } catch(Exception e) {\n        assert false: \"Exception parsing code point '\" + decimalCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 60: break;\n        case 7: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - outputSegment.length();\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + outputSegment.length(), cumulativeDiff);\n    yybegin(YYINITIAL);\n    return outputSegment.nextChar();\n          }\n        case 61: break;\n        case 8: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 62: break;\n        case 9: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(START_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(START_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 63: break;\n        case 10: \n          { inputSegment.append('!'); yybegin(BANG);\n          }\n        case 64: break;\n        case 11: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    yybegin(LEFT_ANGLE_BRACKET_SPACE);\n          }\n        case 65: break;\n        case 12: \n          { inputSegment.append('/'); yybegin(LEFT_ANGLE_BRACKET_SLASH);\n          }\n        case 66: break;\n        case 13: \n          { inputSegment.append(yytext());\n          }\n        case 67: break;\n        case 14: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 68: break;\n        case 15: \n          { \n          }\n        case 69: break;\n        case 16: \n          { restoreState = SCRIPT_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 70: break;\n        case 17: \n          { restoreState = SCRIPT_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 71: break;\n        case 18: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_SUBSTITUTE);\n    }\n          }\n        case 72: break;\n        case 19: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n    if (null != escapedTags\n        && escapedTags.contains(zzBuffer, zzStartRead, yylength())) {\n      yybegin(END_TAG_TAIL_INCLUDE);\n    } else {\n      yybegin(END_TAG_TAIL_EXCLUDE);\n    }\n          }\n        case 73: break;\n        case 20: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n          }\n        case 74: break;\n        case 21: \n          { if (yylength() == 1) {\n      return zzBuffer[zzStartRead];\n    } else {\n      outputSegment.append(yytext()); return outputSegment.nextChar();\n    }\n          }\n        case 75: break;\n        case 22: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 76: break;\n        case 23: \n          { previousRestoreState = restoreState;\n    restoreState = SERVER_SIDE_INCLUDE;\n    yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 77: break;\n        case 24: \n          { yybegin(restoreState); restoreState = previousRestoreState;\n          }\n        case 78: break;\n        case 25: \n          { inputSegment.write(zzBuffer, zzStartRead, yylength());\n     outputSegment = inputSegment;\n     yybegin(YYINITIAL);\n     return outputSegment.nextChar();\n          }\n        case 79: break;\n        case 26: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_END_TAG_REPLACEMENT;\n          }\n        case 80: break;\n        case 27: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += inputSegment.length() + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    outputSegment = inputSegment;\n    yybegin(YYINITIAL);\n          }\n        case 81: break;\n        case 28: \n          { // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 1;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return BLOCK_LEVEL_START_TAG_REPLACEMENT;\n          }\n        case 82: break;\n        case 29: \n          { restoreState = STYLE_COMMENT; yybegin(SINGLE_QUOTED_STRING);\n          }\n        case 83: break;\n        case 30: \n          { restoreState = STYLE_COMMENT; yybegin(DOUBLE_QUOTED_STRING);\n          }\n        case 84: break;\n        case 31: \n          { int length = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, length);\n    entitySegment.clear();\n    char ch = entityValues.get(zzBuffer, zzStartRead, length).charValue();\n    entitySegment.append(ch);\n    outputSegment = entitySegment;\n    yybegin(CHARACTER_REFERENCE_TAIL);\n          }\n        case 85: break;\n        case 32: \n          { int matchLength = yylength();\n    inputSegment.write(zzBuffer, zzStartRead, matchLength);\n    if (matchLength <= 6) { // 10FFFF: max 6 hex chars\n      String hexCharRef\n          = new String(zzBuffer, zzStartRead + 1, matchLength - 1);\n      int codePoint = 0;\n      try {\n        codePoint = Integer.parseInt(hexCharRef, 16);\n      } catch(Exception e) {\n        assert false: \"Exception parsing hex code point '\" + hexCharRef + \"'\";\n      }\n      if (codePoint <= 0x10FFFF) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        if (codePoint >= Character.MIN_SURROGATE\n            && codePoint <= Character.MAX_SURROGATE) {\n          outputSegment.unsafeWrite(REPLACEMENT_CHARACTER);\n        } else {\n          outputSegment.setLength\n              (Character.toChars(codePoint, outputSegment.getArray(), 0));\n        }\n        yybegin(CHARACTER_REFERENCE_TAIL);\n      } else {\n        outputSegment = inputSegment;\n        yybegin(YYINITIAL);\n        return outputSegment.nextChar();\n      }\n    } else {\n      outputSegment = inputSegment;\n      yybegin(YYINITIAL);\n      return outputSegment.nextChar();\n    }\n          }\n        case 86: break;\n        case 33: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"--\" - this is not a comment\n      inputSegment.append(yytext());\n    } else {\n      yybegin(COMMENT);\n    }\n          }\n        case 87: break;\n        case 34: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_START_TAG_REPLACEMENT;\n    }\n          }\n        case 88: break;\n        case 35: \n          { // add (previously matched input length) + (this match length) [ - (substitution length) = 0]\n    cumulativeDiff += yychar - inputStart + yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n          }\n        case 89: break;\n        case 36: \n          { yybegin(SCRIPT);\n          }\n        case 90: break;\n        case 37: \n          { yybegin(YYINITIAL);\n    if (escapeBR) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      return outputSegment.nextChar();\n    } else {\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 1;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 1, cumulativeDiff);\n      inputSegment.reset();\n      return BR_END_TAG_REPLACEMENT;\n    }\n          }\n        case 91: break;\n        case 38: \n          { // add (this match length) [ - (substitution length) = 0 ]\n    cumulativeDiff += yylength();\n    // position the correction at (already output length) [ + (substitution length) = 0 ]\n    addOffCorrectMap(outputCharCount, cumulativeDiff);\n    yybegin(YYINITIAL);\n          }\n        case 92: break;\n        case 39: \n          { yybegin(restoreState);\n          }\n        case 93: break;\n        case 40: \n          { yybegin(STYLE);\n          }\n        case 94: break;\n        case 41: \n          { yybegin(SCRIPT_COMMENT);\n          }\n        case 95: break;\n        case 42: \n          { yybegin(STYLE_COMMENT);\n          }\n        case 96: break;\n        case 43: \n          { restoreState = COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 97: break;\n        case 44: \n          { restoreState = SCRIPT_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 98: break;\n        case 45: \n          { restoreState = STYLE_COMMENT; yybegin(SERVER_SIDE_INCLUDE);\n          }\n        case 99: break;\n        case 46: \n          { yybegin(STYLE);\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 100: break;\n        case 47: \n          { yybegin(SCRIPT);\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      inputStart += 1 + yylength();\n      return outputSegment.nextChar();\n    }\n          }\n        case 101: break;\n        case 48: \n          { if (inputSegment.length() > 2) { // Chars between \"<!\" and \"[CDATA[\" - this is not a CDATA section\n      inputSegment.append(yytext());\n    } else {\n      // add (previously matched input length) + (this match length) [ - (substitution length) = 0 ]\n      cumulativeDiff += inputSegment.length() + yylength();\n      // position the correction at (already output length) [ + (substitution length) = 0 ]\n      addOffCorrectMap(outputCharCount, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(CDATA);\n    }\n          }\n        case 102: break;\n        case 49: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position the offset correction at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSTYLE) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = STYLE_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 103: break;\n        case 50: \n          { inputSegment.clear();\n    yybegin(YYINITIAL);\n    // add (previously matched input length) -- current match and substitution handled below\n    cumulativeDiff += yychar - inputStart;\n    // position at (already output length) -- substitution handled below\n    int offsetCorrectionPos = outputCharCount;\n    int returnValue;\n    if (escapeSCRIPT) {\n      inputSegment.write(zzBuffer, zzStartRead, yylength());\n      outputSegment = inputSegment;\n      returnValue = outputSegment.nextChar();\n    } else {\n      // add (this match length) - (substitution length)\n      cumulativeDiff += yylength() - 1;\n      // add (substitution length)\n      ++offsetCorrectionPos;\n      returnValue = SCRIPT_REPLACEMENT;\n    }\n    addOffCorrectMap(offsetCorrectionPos, cumulativeDiff);\n    return returnValue;\n          }\n        case 104: break;\n        case 51: \n          { // Handle paired UTF-16 surrogates.\n    outputSegment = entitySegment;\n    outputSegment.clear();\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try {\n      outputSegment.unsafeWrite\n          ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(10, 14) + \"'\";\n    }\n    // add (previously matched input length) + (this match length) - (substitution length)\n    cumulativeDiff += inputSegment.length() + yylength() - 2;\n    // position the correction at (already output length) + (substitution length)\n    addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n    inputSegment.clear();\n    yybegin(YYINITIAL);\n    return highSurrogate;\n          }\n        case 105: break;\n        case 52: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    char lowSurrogate = '\\u0000';\n    try {\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(2, 6), 16);\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(2, 6) + \"'\";\n    }\n    try { // Low surrogates are in decimal range [56320, 57343]\n      lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing low surrogate '\"\n                  + surrogatePair.substring(9, 14) + \"'\";\n    }\n    if (Character.isLowSurrogate(lowSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      outputSegment.unsafeWrite(lowSurrogate);\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 106: break;\n        case 53: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      outputSegment = entitySegment;\n      outputSegment.clear();\n      try {\n        outputSegment.unsafeWrite\n            ((char)Integer.parseInt(surrogatePair.substring(10, 14), 16));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(10, 14) + \"'\";\n      }\n      // add (previously matched input length) + (this match length) - (substitution length)\n      cumulativeDiff += inputSegment.length() + yylength() - 2;\n      // position the correction at (already output length) + (substitution length)\n      addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n      inputSegment.clear();\n      yybegin(YYINITIAL);\n      return highSurrogate;\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 107: break;\n        case 54: \n          { // Handle paired UTF-16 surrogates.\n    String surrogatePair = yytext();\n    char highSurrogate = '\\u0000';\n    try { // High surrogates are in decimal range [55296, 56319]\n      highSurrogate = (char)Integer.parseInt(surrogatePair.substring(1, 6));\n    } catch(Exception e) { // should never happen\n      assert false: \"Exception parsing high surrogate '\"\n                  + surrogatePair.substring(1, 6) + \"'\";\n    }\n    if (Character.isHighSurrogate(highSurrogate)) {\n      char lowSurrogate = '\\u0000';\n      try { // Low surrogates are in decimal range [56320, 57343]\n        lowSurrogate = (char)Integer.parseInt(surrogatePair.substring(9, 14));\n      } catch(Exception e) { // should never happen\n        assert false: \"Exception parsing low surrogate '\"\n                    + surrogatePair.substring(9, 14) + \"'\";\n      }\n      if (Character.isLowSurrogate(lowSurrogate)) {\n        outputSegment = entitySegment;\n        outputSegment.clear();\n        outputSegment.unsafeWrite(lowSurrogate);\n        // add (previously matched input length) + (this match length) - (substitution length)\n        cumulativeDiff += inputSegment.length() + yylength() - 2;\n        // position the correction at (already output length) + (substitution length)\n        addOffCorrectMap(outputCharCount + 2, cumulativeDiff);\n        inputSegment.clear();\n        yybegin(YYINITIAL);\n        return highSurrogate;\n      }\n    }\n    yypushback(surrogatePair.length() - 1); // Consume only '#'\n    inputSegment.append('#');\n    yybegin(NUMERIC_CHARACTER);\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            zzDoEOF();\n              {   return eofReturnValue;\n }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8c6c25f6bab8e32b731127f3516a593af8a3305":["3c00ffa555aa637d932f7d491038cf9992403994"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","46ebd94e5ce1e52e512f43684c9b68896ce5966f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["b89678825b68eccaf09e6ab71675fc0b0af1e099","b48c161f84bef42b6b1a2efa87dc10deed2b3c06"],"b48c161f84bef42b6b1a2efa87dc10deed2b3c06":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"4f0c6d69031c318c402abfe2543736076e80a132":["ab081a78869a616f9c93e5b2f3ec2f99c2f7f741"],"46ebd94e5ce1e52e512f43684c9b68896ce5966f":["b48c161f84bef42b6b1a2efa87dc10deed2b3c06"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["b89678825b68eccaf09e6ab71675fc0b0af1e099","b48c161f84bef42b6b1a2efa87dc10deed2b3c06"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","46ebd94e5ce1e52e512f43684c9b68896ce5966f"],"3c00ffa555aa637d932f7d491038cf9992403994":["4f0c6d69031c318c402abfe2543736076e80a132"],"ab081a78869a616f9c93e5b2f3ec2f99c2f7f741":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b8c6c25f6bab8e32b731127f3516a593af8a3305"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["46ebd94e5ce1e52e512f43684c9b68896ce5966f"]},"commit2Childs":{"b8c6c25f6bab8e32b731127f3516a593af8a3305":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["aba371508186796cc6151d8223a5b4e16d02e26e","b48c161f84bef42b6b1a2efa87dc10deed2b3c06","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"b48c161f84bef42b6b1a2efa87dc10deed2b3c06":["aba371508186796cc6151d8223a5b4e16d02e26e","46ebd94e5ce1e52e512f43684c9b68896ce5966f","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"46ebd94e5ce1e52e512f43684c9b68896ce5966f":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"4f0c6d69031c318c402abfe2543736076e80a132":["3c00ffa555aa637d932f7d491038cf9992403994"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"3c00ffa555aa637d932f7d491038cf9992403994":["b8c6c25f6bab8e32b731127f3516a593af8a3305"],"ab081a78869a616f9c93e5b2f3ec2f99c2f7f741":["4f0c6d69031c318c402abfe2543736076e80a132"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["ab081a78869a616f9c93e5b2f3ec2f99c2f7f741"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}