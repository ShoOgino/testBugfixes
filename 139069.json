{"path":"lucene/core/src/test/org/apache/lucene/util/automaton/TestLightAutomaton#testRandomFinite().mjava","commits":[{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestLightAutomaton#testRandomFinite().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    // Some of the ops we do (stripping random byte, reverse) turn valid UTF8 into invalid if we allow non-ascii:\n    boolean isAscii = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: isAscii=\" + isAscii + \" numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString(isAscii)));\n    }\n\n    LightAutomaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(14)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString(isAscii));\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = BasicOperations.concatenateLight(BasicAutomata.makeStringLight(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString(isAscii));\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = BasicOperations.concatenateLight(a, BasicAutomata.makeStringLight(suffix.utf8ToString()));\n        }\n        break;\n\n        // nocommit sometimes concat a suffix accepting more than 1 term, and sometimes non-det\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = BasicOperations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString(isAscii)));\n          }\n          terms.addAll(newTerms);\n          LightAutomaton newA = unionTerms(newTerms);\n          a = BasicOperations.unionLight(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = BasicOperations.optionalLight(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(BasicOperations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            LightAutomaton a2 = unionTerms(toRemove);\n            a = BasicOperations.minusLight(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<LightAutomaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            LightAutomaton a2 = new LightAutomaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          LightAutomaton a2 = randomNoOp(BasicOperations.unionLight(as));\n          a = BasicOperations.minusLight(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<LightAutomaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            LightAutomaton a2 = new LightAutomaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          LightAutomaton a2 = BasicOperations.unionLight(as);\n          if (random().nextBoolean()) {\n            a2 = BasicOperations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperationsLight.minimize(a2);\n          }\n          a = BasicOperations.intersectionLight(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        if (VERBOSE) {\n          System.out.println(\"  op=reverse\");\n        }\n        a = SpecialOperations.reverse(a);\n        Set<BytesRef> newTerms = new HashSet<>();\n        for(BytesRef term : terms) {\n          newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n        }\n        terms = newTerms;\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        int min = random().nextInt(1000);\n        int max = min + random().nextInt(50);\n        // digits must be non-zero else we make cycle\n        int digits = Integer.toString(max).length();\n        if (VERBOSE) {\n          System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n        }\n        a = BasicOperations.unionLight(a, BasicAutomata.makeIntervalLight(min, max, digits));\n        StringBuilder b = new StringBuilder();\n        for(int i=0;i<digits;i++) {\n          b.append('0');\n        }\n        String prefix = b.toString();\n        for(int i=min;i<=max;i++) {\n          String s = Integer.toString(i);\n          if (s.length() < digits) {\n            // Left-fill with 0s\n            s = prefix.substring(s.length()) + s;\n          }\n          terms.add(new BytesRef(s));\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = BasicOperations.minusLight(a, BasicAutomata.makeEmptyStringLight());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = BasicOperations.unionLight(a, BasicAutomata.makeEmptyStringLight());\n        terms.add(new BytesRef());\n        break;\n      }\n\n      assertSame(terms, a);\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/automaton/TestAutomaton#testRandomFinite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/automaton/TestLightAutomaton#testRandomFinite().mjava","sourceNew":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    // Some of the ops we do (stripping random byte, reverse) turn valid UTF8 into invalid if we allow non-ascii:\n    boolean isAscii = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: isAscii=\" + isAscii + \" numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString(isAscii)));\n    }\n\n    Automaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(14)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString(isAscii));\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = Operations.concatenate(Automata.makeString(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString(isAscii));\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = Operations.concatenate(a, Automata.makeString(suffix.utf8ToString()));\n        }\n        break;\n\n        // nocommit sometimes concat a suffix accepting more than 1 term, and sometimes non-det\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = Operations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperations.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString(isAscii)));\n          }\n          terms.addAll(newTerms);\n          Automaton newA = unionTerms(newTerms);\n          a = Operations.union(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = Operations.optional(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(Operations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            Automaton a2 = unionTerms(toRemove);\n            a = Operations.minus(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<Automaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          Automaton a2 = randomNoOp(Operations.union(as));\n          a = Operations.minus(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<Automaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            Automaton a2 = new Automaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          Automaton a2 = Operations.union(as);\n          if (random().nextBoolean()) {\n            a2 = Operations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperations.minimize(a2);\n          }\n          a = Operations.intersection(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        if (VERBOSE) {\n          System.out.println(\"  op=reverse\");\n        }\n        a = Operations.reverse(a);\n        Set<BytesRef> newTerms = new HashSet<>();\n        for(BytesRef term : terms) {\n          newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n        }\n        terms = newTerms;\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        int min = random().nextInt(1000);\n        int max = min + random().nextInt(50);\n        // digits must be non-zero else we make cycle\n        int digits = Integer.toString(max).length();\n        if (VERBOSE) {\n          System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n        }\n        a = Operations.union(a, Automata.makeInterval(min, max, digits));\n        StringBuilder b = new StringBuilder();\n        for(int i=0;i<digits;i++) {\n          b.append('0');\n        }\n        String prefix = b.toString();\n        for(int i=min;i<=max;i++) {\n          String s = Integer.toString(i);\n          if (s.length() < digits) {\n            // Left-fill with 0s\n            s = prefix.substring(s.length()) + s;\n          }\n          terms.add(new BytesRef(s));\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = Operations.minus(a, Automata.makeEmptyString());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = Operations.union(a, Automata.makeEmptyString());\n        terms.add(new BytesRef());\n        break;\n      }\n\n      assertSame(terms, a);\n    }\n\n    assertSame(terms, a);\n  }\n\n","sourceOld":"  public void testRandomFinite() throws Exception {\n\n    int numTerms = atLeast(10);\n    int iters = atLeast(100);\n\n    // Some of the ops we do (stripping random byte, reverse) turn valid UTF8 into invalid if we allow non-ascii:\n    boolean isAscii = random().nextBoolean();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: isAscii=\" + isAscii + \" numTerms\" + numTerms + \" iters=\" + iters);\n    }\n\n    Set<BytesRef> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(new BytesRef(getRandomString(isAscii)));\n    }\n\n    LightAutomaton a = unionTerms(terms);\n    assertSame(terms, a);\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numTerms=\" + terms.size());\n        System.out.println(\"  terms:\");\n        for(BytesRef term : terms) {\n          System.out.println(\"    \" + term);\n        }\n      }\n      switch(random().nextInt(14)) {\n\n      case 0:\n        // concatenate prefix\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=concat prefix\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          BytesRef prefix = new BytesRef(getRandomString(isAscii));\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(prefix);\n            newTerm.append(term);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          boolean wasDeterministic1 = a.isDeterministic();\n          a = BasicOperations.concatenateLight(BasicAutomata.makeStringLight(prefix.utf8ToString()), a);\n          assertEquals(wasDeterministic1, a.isDeterministic());\n        }\n        break;\n\n      case 1:\n        // concatenate suffix\n        {\n          BytesRef suffix = new BytesRef(getRandomString(isAscii));\n          if (VERBOSE) {\n            System.out.println(\"  op=concat suffix \" + suffix);\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          for(BytesRef term : terms) {\n            BytesRef newTerm = BytesRef.deepCopyOf(term);\n            newTerm.append(suffix);\n            newTerms.add(newTerm);\n          }\n          terms = newTerms;\n          a = BasicOperations.concatenateLight(a, BasicAutomata.makeStringLight(suffix.utf8ToString()));\n        }\n        break;\n\n        // nocommit sometimes concat a suffix accepting more than 1 term, and sometimes non-det\n\n      case 2:\n        // determinize\n        if (VERBOSE) {\n          System.out.println(\"  op=determinize\");\n        }\n        a = BasicOperations.determinize(a);\n        assertTrue(a.isDeterministic());\n        break;\n\n      case 3:\n        if (VERBOSE) {\n          System.out.println(\"  op=minimize\");\n        }\n        // minimize\n        a = MinimizationOperationsLight.minimize(a);\n        break;\n\n      case 4:\n        // union\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=union\");\n          }\n          Set<BytesRef> newTerms = new HashSet<>();\n          int numNewTerms = random().nextInt(5);\n          while (newTerms.size() < numNewTerms) {\n            newTerms.add(new BytesRef(getRandomString(isAscii)));\n          }\n          terms.addAll(newTerms);\n          LightAutomaton newA = unionTerms(newTerms);\n          a = BasicOperations.unionLight(a, newA);\n        }\n        break;\n\n      case 5:\n        // optional\n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=optional\");\n          }\n          a = BasicOperations.optionalLight(a);\n          terms.add(new BytesRef());\n        }\n        break;\n\n      case 6:\n        // minus finite \n        {\n          if (VERBOSE) {\n            System.out.println(\"  op=minus finite\");\n          }\n          if (terms.size() > 0) {\n            RandomAcceptedStrings rasl = new RandomAcceptedStrings(BasicOperations.removeDeadStates(a));\n            Set<BytesRef> toRemove = new HashSet<>();\n            int numToRemove = TestUtil.nextInt(random(), 1, (terms.size()+1)/2);\n            while (toRemove.size() < numToRemove) {\n              int[] ints = rasl.getRandomAcceptedString(random());\n              BytesRef term = new BytesRef(UnicodeUtil.newString(ints, 0, ints.length));\n              if (toRemove.contains(term) == false) {\n                toRemove.add(term);\n              }\n            }\n            for(BytesRef term : toRemove) {\n              boolean removed = terms.remove(term);\n              assertTrue(removed);\n            }\n            LightAutomaton a2 = unionTerms(toRemove);\n            a = BasicOperations.minusLight(a, a2);\n          }\n        }\n        break;\n\n      case 7:\n        {\n          // minus infinite\n          List<LightAutomaton> as = new ArrayList<>();\n          int count = TestUtil.nextInt(random(), 1, 5);\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"  op=minus infinite prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we remove <prefix>* from a\n            LightAutomaton a2 = new LightAutomaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            Iterator<BytesRef> it = terms.iterator();\n            while (it.hasNext()) {\n              BytesRef term = it.next();\n              if (term.length > 0 && (term.bytes[term.offset] & 0xFF) == prefix) {\n                it.remove();\n              }\n            }\n          }\n          LightAutomaton a2 = randomNoOp(BasicOperations.unionLight(as));\n          a = BasicOperations.minusLight(a, a2);\n        }\n        break;\n\n      case 8:\n        {\n          int count = TestUtil.nextInt(random(), 10, 20);\n          if (VERBOSE) {\n            System.out.println(\"  op=intersect infinite count=\" + count);\n          }\n          // intersect infinite\n          List<LightAutomaton> as = new ArrayList<>();\n\n          Set<Integer> prefixes = new HashSet<>();\n          while(prefixes.size() < count) {\n            int prefix = random().nextInt(128);\n            prefixes.add(prefix);\n          }\n          if (VERBOSE) {\n            System.out.println(\"  prefixes=\" + prefixes);\n          }\n\n          for(int prefix : prefixes) {\n            // prefix is a leading ascii byte; we retain <prefix>* in a\n            LightAutomaton a2 = new LightAutomaton();\n            int init = a2.createState();\n            int state = a2.createState();\n            a2.addTransition(init, state, prefix);\n            a2.setAccept(state, true);\n            a2.addTransition(state, state, Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);\n            a2.finishState();\n            as.add(a2);\n            prefixes.add(prefix);\n          }\n\n          LightAutomaton a2 = BasicOperations.unionLight(as);\n          if (random().nextBoolean()) {\n            a2 = BasicOperations.determinize(a2);\n          } else if (random().nextBoolean()) {\n            a2 = MinimizationOperationsLight.minimize(a2);\n          }\n          a = BasicOperations.intersectionLight(a, a2);\n\n          Iterator<BytesRef> it = terms.iterator();\n          while (it.hasNext()) {\n            BytesRef term = it.next();\n            if (term.length == 0 || prefixes.contains(term.bytes[term.offset]&0xff) == false) {\n              if (VERBOSE) {\n                System.out.println(\"  drop term=\" + term);\n              }\n              it.remove();\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"  keep term=\" + term);\n              }\n            }\n          }\n        }        \n        break;\n\n      case 9:\n        // reverse\n        if (VERBOSE) {\n          System.out.println(\"  op=reverse\");\n        }\n        a = SpecialOperations.reverse(a);\n        Set<BytesRef> newTerms = new HashSet<>();\n        for(BytesRef term : terms) {\n          newTerms.add(new BytesRef(new StringBuilder(term.utf8ToString()).reverse().toString()));\n        }\n        terms = newTerms;\n        break;\n\n      case 10:\n        if (VERBOSE) {\n          System.out.println(\"  op=randomNoOp\");\n        }\n        a = randomNoOp(a);\n        break;\n\n      case 11:\n        // interval\n        int min = random().nextInt(1000);\n        int max = min + random().nextInt(50);\n        // digits must be non-zero else we make cycle\n        int digits = Integer.toString(max).length();\n        if (VERBOSE) {\n          System.out.println(\"  op=union interval min=\" + min + \" max=\" + max + \" digits=\" + digits);\n        }\n        a = BasicOperations.unionLight(a, BasicAutomata.makeIntervalLight(min, max, digits));\n        StringBuilder b = new StringBuilder();\n        for(int i=0;i<digits;i++) {\n          b.append('0');\n        }\n        String prefix = b.toString();\n        for(int i=min;i<=max;i++) {\n          String s = Integer.toString(i);\n          if (s.length() < digits) {\n            // Left-fill with 0s\n            s = prefix.substring(s.length()) + s;\n          }\n          terms.add(new BytesRef(s));\n        }\n        break;\n\n      case 12:\n        if (VERBOSE) {\n          System.out.println(\"  op=remove the empty string\");\n        }\n        a = BasicOperations.minusLight(a, BasicAutomata.makeEmptyStringLight());\n        terms.remove(new BytesRef());\n        break;\n\n      case 13:\n        if (VERBOSE) {\n          System.out.println(\"  op=add the empty string\");\n        }\n        a = BasicOperations.unionLight(a, BasicAutomata.makeEmptyStringLight());\n        terms.add(new BytesRef());\n        break;\n      }\n\n      assertSame(terms, a);\n    }\n\n    assertSame(terms, a);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}