{"path":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":null,"sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1805a9b39f81f70b33c67bd84a1d672c896ceca0","date":1271009061,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":["409850dbbdb6e3184a228ed61332c3fee211f481"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd00dd91853514614379b0e680d65bd19cac0f30","date":1283087816,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            CommonParams.DEBUG_QUERY, \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc5f1032a8e94a7109e4d9848e0d1661b040e5df","date":1283919365,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            CommonParams.DEBUG_QUERY, \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef02613bb5b67b98ca5caf41e8d6e016a0158923","date":1283980033,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n   // query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key=a/b/c}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":["8c19c480d77a53905bbd65f04e90fa35925c0f9b","8c19c480d77a53905bbd65f04e90fa35925c0f9b","8c19c480d77a53905bbd65f04e90fa35925c0f9b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b251fe1c921fcd21c43703b7483d1a223c67042","date":1283983459,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key=a/b/c}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n   // query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key=a/b/c}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"935577224abfd14a41ed9633bd1529925063d934","date":1283990440,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key=a/b/c}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":["233e7c9621e6f7b43e697f71a00597ff92a34888"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"233e7c9621e6f7b43e697f71a00597ff92a34888","date":1284061177,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":["935577224abfd14a41ed9633bd1529925063d934"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","date":1292210954,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"771281b4c7dc712b48ba338b970b49007ca402a1","date":1295480908,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9001fdb834e467ef899e41c747c42b27b4d45099","date":1296775304,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55e80c3a6a9734c50aa4fa3bf2f240690e12ba42","date":1298586575,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",10, \"facet.limit\",1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2dfd60688653855da1a42cd89a1df4e6738ac079","date":1298618289,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",10, \"facet.limit\",1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",10, \"facet.limit\",1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1c5c000a4f7db9f84794088342aa428d80dfa37","date":1303079085,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",10, \"facet.limit\",1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":["55e80c3a6a9734c50aa4fa3bf2f240690e12ba42","1161f19bd84204b140d97fea16ff621e86ce7ab4","a1ab02b73dc61b51bca98e09b5b72926c4580ecb","e5a95ce1d7a3779af6db59b6b39d3b89172d7445","9eeefc9a351a2910959c41bf241877a3d60eec37","409850dbbdb6e3184a228ed61332c3fee211f481","5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0833d477d790b0926422e7ac018b1bcee73ad5bd","date":1303334953,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":["b678a63236fcc43012cd10e2892116ee88baee04","b678a63236fcc43012cd10e2892116ee88baee04","b678a63236fcc43012cd10e2892116ee88baee04","8c19c480d77a53905bbd65f04e90fa35925c0f9b","8c19c480d77a53905bbd65f04e90fa35925c0f9b","8c19c480d77a53905bbd65f04e90fa35925c0f9b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d493718201f0d0c54c773fb323d87bbd2fbffe41","date":1303546048,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",10, \"facet.limit\",1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",10, \"facet.limit\",1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",10, \"facet.limit\",1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    int backupStress = stress; // make a copy so we can restore\n\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\", \n           tdate_a, \"2010-04-20T11:00:00Z\",\n           tdate_b, \"2009-08-20T11:00:00Z\",\n           \"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\", \n           tdate_a, \"2010-05-02T11:00:00Z\",\n           tdate_b, \"2009-11-02T11:00:00Z\");\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\", \n           tdate_a, \"2010-05-03T11:00:00Z\");\n    indexr(id,4, i1, -100 ,tlong, 101,\n           t1,\"the quick fox jumped over the lazy dog\", \n           tdate_a, \"2010-05-03T11:00:00Z\",\n           tdate_b, \"2010-05-03T11:00:00Z\");\n    indexr(id,5, i1, 500, tlong, 500 ,\n           t1,\"the quick fox jumped way over the lazy dog\", \n           tdate_a, \"2010-05-05T11:00:00Z\");\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,\n           tdate_b, \"2010-01-05T11:00:00Z\",\n           t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,\n           t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,\n           t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,\n           t1,\"no eggs on wall, lesson learned\", \n           oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",\"{!func}add(\"+i1+\",5)\"+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",\"n_tl1 desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n    // test that a single NOW value is propagated to all shards... if that is true\n    // then the primary sort should always be a tie and then the secondary should always decide\n    query(\"q\",\"{!func}ms(NOW)\", \"sort\",\"score desc,\"+i1+\" desc\",\"fl\",\"id\");    \n\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // simple date facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date.other\", \"all\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // date facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.date\",tdate_a, \n          \"facet.date\",tdate_b, \n          \"facet.date.other\", \"all\", \n          \"f.\"+tdate_b+\".facet.date.start\",\"2009-05-01T11:00:00Z\", \n          \"f.\"+tdate_b+\".facet.date.gap\",\"+3MONTHS\", \n          \"facet.date.start\",\"2010-05-01T11:00:00Z\", \n          \"facet.date.gap\",\"+1DAY\", \n          \"facet.date.end\",\"2010-05-20T11:00:00Z\");\n\n    // simple range facet on one field\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"facet.range.end\",900);\n\n    // range facet on multiple fields\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \n          \"facet.range\",tlong, \n          \"facet.range\",i1, \n          \"f.\"+i1+\".facet.range.start\",300, \n          \"f.\"+i1+\".facet.range.gap\",87, \n          \"facet.range.end\",900,\n          \"facet.range.start\",200, \n          \"facet.range.gap\",100, \n          \"f.\"+tlong+\".facet.range.end\",900);\n\n    stress=0;  // turn off stress... we want to tex max combos in min time\n    for (int i=0; i<25*RANDOM_MULTIPLIER; i++) {\n      String f = fieldNames[random.nextInt(fieldNames.length)];\n      if (random.nextBoolean()) f = t1;  // the text field is a really interesting one to facet on (and it's multi-valued too)\n\n      // we want a random query and not just *:* so we'll get zero counts in facets also\n      // TODO: do a better random query\n      String q = random.nextBoolean() ? \"*:*\" : \"id:(1 3 5 7 9 11 13) OR id:[100 TO \" + random.nextInt(50) + \"]\";\n\n      int nolimit = random.nextBoolean() ? -1 : 10000;  // these should be equivalent\n\n      // if limit==-1, we should always get exact matches\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"count\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.limit\",nolimit, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(5), \"facet.offset\",random.nextInt(10));\n      // for index sort, we should get exact results for mincount <= 1\n      query(\"q\",q, \"rows\",0, \"facet\",\"true\", \"facet.field\",f, \"facet.sort\",\"index\", \"facet.mincount\",random.nextInt(2), \"facet.offset\",random.nextInt(10), \"facet.limit\",random.nextInt(11)-1);\n    }\n    stress = backupStress;  // restore stress\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    /*** TODO: the failure may come back in \"exception\"\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      TestCase.fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n    ***/\n\n    // Try to get better coverage for refinement queries by turning off over requesting.\n    // This makes it much more likely that we may not get the top facet values and hence\n    // we turn of that checking.\n    handle.put(\"facet_fields\", SKIPVAL);    \n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    // check a complex key name\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a b/c \\\\' \\\\} foo'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    query(\"q\",\"*:*\", \"rows\",0, \"facet\",\"true\", \"facet.field\",\"{!key='$a'}\"+t1,\"facet.limit\",5, \"facet.shard.limit\",5);\n    handle.remove(\"facet_fields\");\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // test debugging\n    handle.put(\"explain\", UNORDERED);\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG_QUERY, \"true\");\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.TIMING);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.RESULTS);\n    query(\"q\", \"id:[1 TO 5]\", CommonParams.DEBUG, CommonParams.QUERY);\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    // query(\"q\",\"matchesnothing\",\"fl\",\"*,score\", \"debugQuery\", \"true\");\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ef02613bb5b67b98ca5caf41e8d6e016a0158923":["fc5f1032a8e94a7109e4d9848e0d1661b040e5df"],"c26f00b574427b55127e869b935845554afde1fa":["0833d477d790b0926422e7ac018b1bcee73ad5bd","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1805a9b39f81f70b33c67bd84a1d672c896ceca0","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":["2dfd60688653855da1a42cd89a1df4e6738ac079","0833d477d790b0926422e7ac018b1bcee73ad5bd"],"55e80c3a6a9734c50aa4fa3bf2f240690e12ba42":["9001fdb834e467ef899e41c747c42b27b4d45099"],"233e7c9621e6f7b43e697f71a00597ff92a34888":["935577224abfd14a41ed9633bd1529925063d934"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","9001fdb834e467ef899e41c747c42b27b4d45099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2dfd60688653855da1a42cd89a1df4e6738ac079":["bde51b089eb7f86171eb3406e38a274743f9b7ac","55e80c3a6a9734c50aa4fa3bf2f240690e12ba42"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["e79a6d080bdd5b2a8f56342cf571b5476de04180","9001fdb834e467ef899e41c747c42b27b4d45099"],"d1c5c000a4f7db9f84794088342aa428d80dfa37":["55e80c3a6a9734c50aa4fa3bf2f240690e12ba42"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"935577224abfd14a41ed9633bd1529925063d934":["5b251fe1c921fcd21c43703b7483d1a223c67042"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","0833d477d790b0926422e7ac018b1bcee73ad5bd"],"1805a9b39f81f70b33c67bd84a1d672c896ceca0":["1da8d55113b689b06716246649de6f62430f15c0"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["233e7c9621e6f7b43e697f71a00597ff92a34888","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","771281b4c7dc712b48ba338b970b49007ca402a1"],"771281b4c7dc712b48ba338b970b49007ca402a1":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"cd00dd91853514614379b0e680d65bd19cac0f30":["1805a9b39f81f70b33c67bd84a1d672c896ceca0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a3776dccca01c11e7046323cfad46a3b4a471233"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["29ef99d61cda9641b6250bf9567329a6e65f901d","55e80c3a6a9734c50aa4fa3bf2f240690e12ba42"],"9001fdb834e467ef899e41c747c42b27b4d45099":["771281b4c7dc712b48ba338b970b49007ca402a1"],"5b251fe1c921fcd21c43703b7483d1a223c67042":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"fc5f1032a8e94a7109e4d9848e0d1661b040e5df":["cd00dd91853514614379b0e680d65bd19cac0f30"],"a3776dccca01c11e7046323cfad46a3b4a471233":["55e80c3a6a9734c50aa4fa3bf2f240690e12ba42","0833d477d790b0926422e7ac018b1bcee73ad5bd"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["233e7c9621e6f7b43e697f71a00597ff92a34888"],"0833d477d790b0926422e7ac018b1bcee73ad5bd":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["0833d477d790b0926422e7ac018b1bcee73ad5bd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"ef02613bb5b67b98ca5caf41e8d6e016a0158923":["5b251fe1c921fcd21c43703b7483d1a223c67042"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"d493718201f0d0c54c773fb323d87bbd2fbffe41":[],"55e80c3a6a9734c50aa4fa3bf2f240690e12ba42":["2dfd60688653855da1a42cd89a1df4e6738ac079","d1c5c000a4f7db9f84794088342aa428d80dfa37","d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233"],"233e7c9621e6f7b43e697f71a00597ff92a34888":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"1da8d55113b689b06716246649de6f62430f15c0":["1805a9b39f81f70b33c67bd84a1d672c896ceca0"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"2dfd60688653855da1a42cd89a1df4e6738ac079":["d493718201f0d0c54c773fb323d87bbd2fbffe41"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["2dfd60688653855da1a42cd89a1df4e6738ac079"],"d1c5c000a4f7db9f84794088342aa428d80dfa37":["0833d477d790b0926422e7ac018b1bcee73ad5bd"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"935577224abfd14a41ed9633bd1529925063d934":["233e7c9621e6f7b43e697f71a00597ff92a34888"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"1805a9b39f81f70b33c67bd84a1d672c896ceca0":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd00dd91853514614379b0e680d65bd19cac0f30"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"771281b4c7dc712b48ba338b970b49007ca402a1":["e79a6d080bdd5b2a8f56342cf571b5476de04180","9001fdb834e467ef899e41c747c42b27b4d45099"],"cd00dd91853514614379b0e680d65bd19cac0f30":["fc5f1032a8e94a7109e4d9848e0d1661b040e5df"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"fc5f1032a8e94a7109e4d9848e0d1661b040e5df":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"9001fdb834e467ef899e41c747c42b27b4d45099":["55e80c3a6a9734c50aa4fa3bf2f240690e12ba42","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"5b251fe1c921fcd21c43703b7483d1a223c67042":["935577224abfd14a41ed9633bd1529925063d934"],"a3776dccca01c11e7046323cfad46a3b4a471233":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","ab5cb6a74aefb78aa0569857970b9151dfe2e787","771281b4c7dc712b48ba338b970b49007ca402a1"],"0833d477d790b0926422e7ac018b1bcee73ad5bd":["c26f00b574427b55127e869b935845554afde1fa","d493718201f0d0c54c773fb323d87bbd2fbffe41","135621f3a0670a9394eb563224a3b76cc4dddc0f","a3776dccca01c11e7046323cfad46a3b4a471233","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d493718201f0d0c54c773fb323d87bbd2fbffe41","135621f3a0670a9394eb563224a3b76cc4dddc0f","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}