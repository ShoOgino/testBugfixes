{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(BKDTreeLeafNodes).mjava","commits":[{"id":"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce","date":1589215155,"type":1,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(BKDTreeLeafNodes).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(long[],byte[]).mjava","sourceNew":"  /** Packs the two arrays, representing a semi-balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(BKDTreeLeafNodes leafNodes) throws IOException {\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafNodes, 0l, blocks, lastSplitValues, new boolean[numIndexDims], false,\n        0, leafNodes.numLeaves());\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","sourceOld":"  /** Packs the two arrays, representing a semi-balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n    int numLeaves = leafBlockFPs.length;\n    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree.\n    // In this case the leaf nodes may straddle the two bottom\n    // levels of the binary tree:\n    int lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);\n    int leavesFullLevel = 1 << lastFullLevel;\n    int leavesPartialLevel = 2 * (numLeaves - leavesFullLevel);\n    if (leavesPartialLevel != 0) {\n      // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n      // at read-time, so that we can still delta code them on disk at write:\n      long[] newLeafBlockFPs = new long[numLeaves];\n      System.arraycopy(leafBlockFPs, leavesPartialLevel, newLeafBlockFPs, 0, numLeaves - leavesPartialLevel);\n      System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, numLeaves - leavesPartialLevel, leavesPartialLevel);\n      leafBlockFPs = newLeafBlockFPs;\n    }\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numIndexDims], false);\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(BKDTreeLeafNodes).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#packIndex(BKDTreeLeafNodes).mjava","sourceNew":"  /** Packs the two arrays, representing a semi-balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(BKDTreeLeafNodes leafNodes) throws IOException {\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[config.bytesPerDim * config.numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafNodes, 0l, blocks, lastSplitValues, new boolean[config.numIndexDims], false,\n        0, leafNodes.numLeaves());\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","sourceOld":"  /** Packs the two arrays, representing a semi-balanced binary tree, into a compact byte[] structure. */\n  private byte[] packIndex(BKDTreeLeafNodes leafNodes) throws IOException {\n    /** Reused while packing the index */\n    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();\n\n    // This is the \"file\" we append the byte[] to:\n    List<byte[]> blocks = new ArrayList<>();\n    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];\n    //System.out.println(\"\\npack index\");\n    int totalSize = recursePackIndex(writeBuffer, leafNodes, 0l, blocks, lastSplitValues, new boolean[numIndexDims], false,\n        0, leafNodes.numLeaves());\n\n    // Compact the byte[] blocks into single byte index:\n    byte[] index = new byte[totalSize];\n    int upto = 0;\n    for(byte[] block : blocks) {\n      System.arraycopy(block, 0, index, upto, block.length);\n      upto += block.length;\n    }\n    assert upto == totalSize;\n\n    return index;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["125e5eeb7e933deec0cc0510c2368fe1ec7c36ce"],"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["125e5eeb7e933deec0cc0510c2368fe1ec7c36ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}