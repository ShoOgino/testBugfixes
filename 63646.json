{"path":"solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc#getShardHLL(int).mjava","commits":[{"id":"2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008","date":1431878853,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc#getShardHLL(int).mjava","pathOld":"/dev/null","sourceNew":"  private Object getShardHLL(int slot) throws IOException {\n    FixedBitSet ords = arr[slot];\n    if (ords == null) return null;  // TODO: when we get to refinements, may be useful to return something???\n\n    HLL hll = factory.getHLL();\n    long maxOrd = ords.length();\n    Hash.LongPair hashResult = new Hash.LongPair();\n    for(int ord=-1; ++ord < maxOrd;) {\n      ord = ords.nextSetBit(ord);\n      if (ord == DocIdSetIterator.NO_MORE_DOCS) break;\n      BytesRef val = lookupOrd(ord);\n      // way to avoid recomputing hash across slots?  Prob not worth space\n      Hash.murmurhash3_x64_128(val.bytes, val.offset, val.length, 0, hashResult);\n      // idea: if the set is small enough, just send the hashes?  We can add at the top\n      // level or even just do a hash table at the top level.\n      hll.addRaw(hashResult.val1);\n    }\n\n    SimpleOrderedMap map = new SimpleOrderedMap();\n    map.add(\"hll\", hll.toBytes());\n    return map;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["18ca6b9479f06cd09b5a995e14aa915de062c29e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"18ca6b9479f06cd09b5a995e14aa915de062c29e","date":1483653744,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc#getShardHLL(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc#getShardHLL(int).mjava","sourceNew":"  private Object getShardHLL(int slot) throws IOException {\n    FixedBitSet ords = arr[slot];\n    if (ords == null) return HLLAgg.NO_VALUES;\n\n    HLL hll = factory.getHLL();\n    long maxOrd = ords.length();\n    Hash.LongPair hashResult = new Hash.LongPair();\n    for(int ord=-1; ++ord < maxOrd;) {\n      ord = ords.nextSetBit(ord);\n      if (ord == DocIdSetIterator.NO_MORE_DOCS) break;\n      BytesRef val = lookupOrd(ord);\n      // way to avoid recomputing hash across slots?  Prob not worth space\n      Hash.murmurhash3_x64_128(val.bytes, val.offset, val.length, 0, hashResult);\n      // idea: if the set is small enough, just send the hashes?  We can add at the top\n      // level or even just do a hash table at the top level.\n      hll.addRaw(hashResult.val1);\n    }\n\n    SimpleOrderedMap map = new SimpleOrderedMap();\n    map.add(\"hll\", hll.toBytes());\n    return map;\n  }\n\n","sourceOld":"  private Object getShardHLL(int slot) throws IOException {\n    FixedBitSet ords = arr[slot];\n    if (ords == null) return null;  // TODO: when we get to refinements, may be useful to return something???\n\n    HLL hll = factory.getHLL();\n    long maxOrd = ords.length();\n    Hash.LongPair hashResult = new Hash.LongPair();\n    for(int ord=-1; ++ord < maxOrd;) {\n      ord = ords.nextSetBit(ord);\n      if (ord == DocIdSetIterator.NO_MORE_DOCS) break;\n      BytesRef val = lookupOrd(ord);\n      // way to avoid recomputing hash across slots?  Prob not worth space\n      Hash.murmurhash3_x64_128(val.bytes, val.offset, val.length, 0, hashResult);\n      // idea: if the set is small enough, just send the hashes?  We can add at the top\n      // level or even just do a hash table at the top level.\n      hll.addRaw(hashResult.val1);\n    }\n\n    SimpleOrderedMap map = new SimpleOrderedMap();\n    map.add(\"hll\", hll.toBytes());\n    return map;\n  }\n\n","bugFix":["2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"491c9672ec42582fe43960452dbd37f1c80fe0f0","date":1483739222,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc#getShardHLL(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc#getShardHLL(int).mjava","sourceNew":"  private Object getShardHLL(int slot) throws IOException {\n    FixedBitSet ords = arr[slot];\n    if (ords == null) return HLLAgg.NO_VALUES;\n\n    HLL hll = factory.getHLL();\n    long maxOrd = ords.length();\n    Hash.LongPair hashResult = new Hash.LongPair();\n    for(int ord=-1; ++ord < maxOrd;) {\n      ord = ords.nextSetBit(ord);\n      if (ord == DocIdSetIterator.NO_MORE_DOCS) break;\n      BytesRef val = lookupOrd(ord);\n      // way to avoid recomputing hash across slots?  Prob not worth space\n      Hash.murmurhash3_x64_128(val.bytes, val.offset, val.length, 0, hashResult);\n      // idea: if the set is small enough, just send the hashes?  We can add at the top\n      // level or even just do a hash table at the top level.\n      hll.addRaw(hashResult.val1);\n    }\n\n    SimpleOrderedMap map = new SimpleOrderedMap();\n    map.add(\"hll\", hll.toBytes());\n    return map;\n  }\n\n","sourceOld":"  private Object getShardHLL(int slot) throws IOException {\n    FixedBitSet ords = arr[slot];\n    if (ords == null) return null;  // TODO: when we get to refinements, may be useful to return something???\n\n    HLL hll = factory.getHLL();\n    long maxOrd = ords.length();\n    Hash.LongPair hashResult = new Hash.LongPair();\n    for(int ord=-1; ++ord < maxOrd;) {\n      ord = ords.nextSetBit(ord);\n      if (ord == DocIdSetIterator.NO_MORE_DOCS) break;\n      BytesRef val = lookupOrd(ord);\n      // way to avoid recomputing hash across slots?  Prob not worth space\n      Hash.murmurhash3_x64_128(val.bytes, val.offset, val.length, 0, hashResult);\n      // idea: if the set is small enough, just send the hashes?  We can add at the top\n      // level or even just do a hash table at the top level.\n      hll.addRaw(hashResult.val1);\n    }\n\n    SimpleOrderedMap map = new SimpleOrderedMap();\n    map.add(\"hll\", hll.toBytes());\n    return map;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc#getShardHLL(int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/UniqueSlotAcc#getShardHLL(int).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  private Object getShardHLL(int slot) throws IOException {\n    FixedBitSet ords = arr[slot];\n    if (ords == null) return HLLAgg.NO_VALUES;\n\n    HLL hll = factory.getHLL();\n    long maxOrd = ords.length();\n    Hash.LongPair hashResult = new Hash.LongPair();\n    for(int ord=-1; ++ord < maxOrd;) {\n      ord = ords.nextSetBit(ord);\n      if (ord == DocIdSetIterator.NO_MORE_DOCS) break;\n      BytesRef val = lookupOrd(ord);\n      // way to avoid recomputing hash across slots?  Prob not worth space\n      Hash.murmurhash3_x64_128(val.bytes, val.offset, val.length, 0, hashResult);\n      // idea: if the set is small enough, just send the hashes?  We can add at the top\n      // level or even just do a hash table at the top level.\n      hll.addRaw(hashResult.val1);\n    }\n\n    SimpleOrderedMap map = new SimpleOrderedMap();\n    map.add(\"hll\", hll.toBytes());\n    return map;\n  }\n\n","sourceOld":"  private Object getShardHLL(int slot) throws IOException {\n    FixedBitSet ords = arr[slot];\n    if (ords == null) return HLLAgg.NO_VALUES;\n\n    HLL hll = factory.getHLL();\n    long maxOrd = ords.length();\n    Hash.LongPair hashResult = new Hash.LongPair();\n    for(int ord=-1; ++ord < maxOrd;) {\n      ord = ords.nextSetBit(ord);\n      if (ord == DocIdSetIterator.NO_MORE_DOCS) break;\n      BytesRef val = lookupOrd(ord);\n      // way to avoid recomputing hash across slots?  Prob not worth space\n      Hash.murmurhash3_x64_128(val.bytes, val.offset, val.length, 0, hashResult);\n      // idea: if the set is small enough, just send the hashes?  We can add at the top\n      // level or even just do a hash table at the top level.\n      hll.addRaw(hashResult.val1);\n    }\n\n    SimpleOrderedMap map = new SimpleOrderedMap();\n    map.add(\"hll\", hll.toBytes());\n    return map;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["18ca6b9479f06cd09b5a995e14aa915de062c29e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"18ca6b9479f06cd09b5a995e14aa915de062c29e":["2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008"],"491c9672ec42582fe43960452dbd37f1c80fe0f0":["2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008","18ca6b9479f06cd09b5a995e14aa915de062c29e"]},"commit2Childs":{"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008"],"2ddd9456ddbc1edc62d5a14a84ad0e4fcd74a008":["18ca6b9479f06cd09b5a995e14aa915de062c29e","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"18ca6b9479f06cd09b5a995e14aa915de062c29e":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"491c9672ec42582fe43960452dbd37f1c80fe0f0":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}