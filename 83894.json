{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet).mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#doPivots(NamedList[Integer],String,String,Deque[String],DocSet).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under teh specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n      String field, String subField, Deque<String> fnames,Deque<String> vnames,DocSet docs) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-useable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset) );\n          }\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to do all the pivots\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, Deque<String> fnames,\n                                             DocSet docs) throws IOException\n  {\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= minMatch) {\n\n        // may be null when using facet.missing\n        final String fieldValue = kv.getKey(); \n\n        // don't reuse the same BytesRef each time since we will be \n        // constructing Term objects used in TermQueries that may be cached.\n        BytesRefBuilder termval = null;\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          termval = new BytesRefBuilder();\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n        \n        if( subField == null ) {\n          values.add( pivot );\n        }\n        else {\n          DocSet subset = null;\n          if ( null == termval ) {\n            DocSet hasVal = searcher.getDocSet\n              (new TermRangeQuery(field, null, null, false, false));\n            subset = docs.andNot(hasVal);\n          } else {\n            Query query = new TermQuery(new Term(field, termval.get()));\n            subset = searcher.getDocSet(query, docs);\n          }\n          super.docs = subset;//used by getTermCounts()\n\n          NamedList<Integer> nl = this.getTermCounts(subField);\n          if (nl.size() >= minMatch) {\n            pivot.add( \"pivot\", doPivots( nl, subField, nextField, fnames, subset) );\n            values.add( pivot ); // only add response if there are some counts\n          }\n        }\n      }\n    }\n    \n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":5,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under teh specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-useable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          // for pivots, we *always* include requested stats - even if 'empty'\n          pivot.add(\"stats\", StatsComponent.convertToResponse(true, stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to compute all the pivot counts for the values under teh specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n      String field, String subField, Deque<String> fnames,Deque<String> vnames,DocSet docs) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-useable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset) );\n          }\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"]},"commit2Childs":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}