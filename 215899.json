{"path":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","commits":[{"id":"0f080986da691a3bba7b757f43ab72cdc82b57ce","date":1273069619,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n\t}\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcbc12aa8147f5203ca283e7252ba4280d6ffd16","date":1305663400,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n\t}\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n\t}\n\n","bugFix":["f79c103683b18eae3b9f62a8c61e675d8984b092"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n\t}\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n\t}\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n    }\n    return newTarget;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/shingle/ShingleFilter#getNextToken(InputWindowToken).mjava","sourceNew":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n\t}\n\n","sourceOld":"  /**\n   * <p>Get the next token from the input stream.\n   * <p>If the next token has <code>positionIncrement > 1</code>,\n   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are\n   * inserted first.\n   * @param target Where to put the new token; if null, a new instance is created.\n   * @return On success, the populated token; null otherwise\n   * @throws IOException if the input stream has a problem\n   */\n  private InputWindowToken getNextToken(InputWindowToken target) \n    throws IOException {\n    InputWindowToken newTarget = target;\n    if (numFillerTokensToInsert > 0) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      // A filler token occupies no space\n      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), \n                                    newTarget.offsetAtt.startOffset());\n      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n      newTarget.isFiller = true;\n      --numFillerTokensToInsert;\n    } else if (isNextInputStreamToken) {\n      if (null == target) {\n        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());\n      } else {\n        nextInputStreamToken.copyTo(target.attSource);\n      }\n      isNextInputStreamToken = false;\n      newTarget.isFiller = false;\n    } else if (!exhausted && input.incrementToken()) {\n      if (null == target) {\n        newTarget = new InputWindowToken(cloneAttributes());\n      } else {\n        this.copyTo(target.attSource);\n      }\n      if (posIncrAtt.getPositionIncrement() > 1) {\n        // Each output shingle must contain at least one input token, \n        // so no more than (maxShingleSize - 1) filler tokens will be inserted.\n        numFillerTokensToInsert \n          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);\n        // Save the current token as the next input stream token\n        if (null == nextInputStreamToken) {\n          nextInputStreamToken = cloneAttributes();\n        } else {\n          this.copyTo(nextInputStreamToken);\n        }\n        isNextInputStreamToken = true;\n        // A filler token occupies no space\n        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());\n        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);\n        newTarget.isFiller = true;\n        --numFillerTokensToInsert;\n      } else {\n        newTarget.isFiller = false;\n      }\n    } else {\n      newTarget = null;\n      exhausted = true;\n    }\n    return newTarget;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fcbc12aa8147f5203ca283e7252ba4280d6ffd16":["0f080986da691a3bba7b757f43ab72cdc82b57ce"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["fcbc12aa8147f5203ca283e7252ba4280d6ffd16"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["0f080986da691a3bba7b757f43ab72cdc82b57ce","fcbc12aa8147f5203ca283e7252ba4280d6ffd16"],"a3776dccca01c11e7046323cfad46a3b4a471233":["0f080986da691a3bba7b757f43ab72cdc82b57ce","fcbc12aa8147f5203ca283e7252ba4280d6ffd16"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"fcbc12aa8147f5203ca283e7252ba4280d6ffd16":["b89678825b68eccaf09e6ab71675fc0b0af1e099","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f080986da691a3bba7b757f43ab72cdc82b57ce"],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["fcbc12aa8147f5203ca283e7252ba4280d6ffd16","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}