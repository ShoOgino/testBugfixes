{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,CloudConfig,String,String,int,int,int,Object,SolrCloudManager).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,CloudConfig,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, CloudConfig cloudConfig, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, cloudConfig, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,String,String,int,int,int,Object,SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#getNodesForNewReplicas(ClusterState,CloudConfig,String,String,int,int,int,Object,SolrCloudManager).mjava","sourceNew":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","sourceOld":"  // Only called from addReplica (and by extension createShard) (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if the AssignStrategy\n  // can't allocate valid positions.\n  @SuppressWarnings({\"unchecked\"})\n  public static List<ReplicaPosition> getNodesForNewReplicas(ClusterState clusterState, CloudConfig cloudConfig, String collectionName,\n                                                          String shard, int nrtReplicas, int tlogReplicas, int pullReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager) throws IOException, InterruptedException, AssignmentException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , nrtReplicas : {} , tlogReplicas: {} , pullReplicas: {} , createNodeSet {}\"\n        , shard, nrtReplicas, tlogReplicas, pullReplicas, createNodeSet);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List<String>) createNodeSet;\n    } else {\n      // deduplicate\n      createNodeList = createNodeSet == null ? null : new ArrayList<>(new LinkedHashSet<>(StrUtils.splitSmart((String) createNodeSet, \",\", true)));\n    }\n\n    // produces clear message when down nodes are the root cause, without this the user just\n    // gets a log message of detail about the nodes that are up, and a message that policies could not\n    // be satisfied which then requires study to diagnose the issue.\n    checkLiveNodes(createNodeList,clusterState);\n\n    AssignRequest assignRequest = new AssignRequestBuilder()\n        .forCollection(collectionName)\n        .forShard(Collections.singletonList(shard))\n        .assignNrtReplicas(nrtReplicas)\n        .assignTlogReplicas(tlogReplicas)\n        .assignPullReplicas(pullReplicas)\n        .onNodes(createNodeList)\n        .build();\n    AssignStrategyFactory assignStrategyFactory = new AssignStrategyFactory(cloudManager);\n    AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, cloudConfig, coll);\n    return assignStrategy.assign(cloudManager, assignRequest);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}