{"path":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random);\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random, 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random, 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random);\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random, 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random, 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random().nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random());\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random().nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random(), 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random().nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random(), 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random().nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random().nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random().nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random);\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random, 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random, 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random().nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = TestUtil.randomUnicodeString(random());\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random().nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += TestUtil.nextInt(random(), 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random().nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += TestUtil.nextInt(random(), 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random().nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random().nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random().nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random().nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random());\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random().nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random(), 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random().nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random(), 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random().nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random().nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random().nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random().nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = TestUtil.randomUnicodeString(random());\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random().nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += TestUtil.nextInt(random(), 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random().nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += TestUtil.nextInt(random(), 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random().nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random().nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random().nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random().nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = TestUtil.randomUnicodeString(random());\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random().nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += TestUtil.nextInt(random(), 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random().nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += TestUtil.nextInt(random(), 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random().nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random().nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random().nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}