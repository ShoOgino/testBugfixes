{"path":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString().mjava","commits":[{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum#nextString().mjava","sourceNew":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Increments the byte buffer to the next String in binary order after s that will not put\n   * the machine into a reject state. If such a string does not exist, returns\n   * false.\n   * \n   * The correctness of this method depends upon the automaton being deterministic,\n   * and having no transitions to dead states.\n   * \n   * @return true if more possible solutions exist for the DFA\n   */\n  private boolean nextString() {\n    int state;\n    int pos = 0;\n    savedStates.grow(seekBytesRef.length+1);\n    final int[] states = savedStates.ints;\n    states[0] = runAutomaton.getInitialState();\n    \n    while (true) {\n      curGen++;\n      linear = false;\n      // walk the automaton until a character is rejected.\n      for (state = states[pos]; pos < seekBytesRef.length; pos++) {\n        visited[state] = curGen;\n        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);\n        if (nextState == -1)\n          break;\n        states[pos+1] = nextState;\n        // we found a loop, record it for faster enumeration\n        if (!finite && !linear && visited[nextState] == curGen) {\n          setLinear(pos);\n        }\n        state = nextState;\n      }\n\n      // take the useful portion, and the last non-reject state, and attempt to\n      // append characters that will match.\n      if (nextString(state, pos)) {\n        return true;\n      } else { /* no more solutions exist from this useful portion, backtrack */\n        if ((pos = backtrack(pos)) < 0) /* no more solutions at all */\n          return false;\n        final int newState = runAutomaton.step(states[pos], seekBytesRef.bytes[pos] & 0xff);\n        if (newState >= 0 && runAutomaton.isAccept(newState))\n          /* String is good to go as-is */\n          return true;\n        /* else advance further */\n        // TODO: paranoia? if we backtrack thru an infinite DFA, the loop detection is important!\n        // for now, restart from scratch for all infinite DFAs \n        if (!finite) pos = 0;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}