{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"/dev/null","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n    if (newestLogOnStartup == null) return null;\n\n    if (!newestLogOnStartup.try_incref()) return null;   // log file was already closed\n\n    // now that we've incremented the reference, the log shouldn't go away.\n    try {\n      if (newestLogOnStartup.endsWithCommit()) {\n        newestLogOnStartup.decref();\n        return null;\n      }\n    } catch (IOException e) {\n      log.error(\"Error inspecting tlog \" + newestLogOnStartup);\n      newestLogOnStartup.decref();\n      return null;\n    }\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<RecoveryInfo>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(newestLogOnStartup, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    return cs.submit(replayer, recoveryInfo);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"/dev/null","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n    if (newestLogOnStartup == null) return null;\n\n    if (!newestLogOnStartup.try_incref()) return null;   // log file was already closed\n\n    // now that we've incremented the reference, the log shouldn't go away.\n    try {\n      if (newestLogOnStartup.endsWithCommit()) {\n        newestLogOnStartup.decref();\n        return null;\n      }\n    } catch (IOException e) {\n      log.error(\"Error inspecting tlog \" + newestLogOnStartup);\n      newestLogOnStartup.decref();\n      return null;\n    }\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<RecoveryInfo>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(newestLogOnStartup, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    return cs.submit(replayer, recoveryInfo);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"/dev/null","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n    if (newestLogOnStartup == null) return null;\n\n    if (!newestLogOnStartup.try_incref()) return null;   // log file was already closed\n\n    // now that we've incremented the reference, the log shouldn't go away.\n    try {\n      if (newestLogOnStartup.endsWithCommit()) {\n        newestLogOnStartup.decref();\n        return null;\n      }\n    } catch (IOException e) {\n      log.error(\"Error inspecting tlog \" + newestLogOnStartup);\n      newestLogOnStartup.decref();\n      return null;\n    }\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<RecoveryInfo>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(newestLogOnStartup, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    return cs.submit(replayer, recoveryInfo);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a9e81d464930e5664da049442e2630d4b9b00d5","date":1330726364,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<TransactionLog>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<RecoveryInfo>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n    if (newestLogOnStartup == null) return null;\n\n    if (!newestLogOnStartup.try_incref()) return null;   // log file was already closed\n\n    // now that we've incremented the reference, the log shouldn't go away.\n    try {\n      if (newestLogOnStartup.endsWithCommit()) {\n        newestLogOnStartup.decref();\n        return null;\n      }\n    } catch (IOException e) {\n      log.error(\"Error inspecting tlog \" + newestLogOnStartup);\n      newestLogOnStartup.decref();\n      return null;\n    }\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<RecoveryInfo>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(newestLogOnStartup, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    return cs.submit(replayer, recoveryInfo);\n\n  }\n\n","bugFix":null,"bugIntro":["215ff2055badad52b893ffdd6250cf36560086f3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<TransactionLog>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<RecoveryInfo>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n    if (newestLogOnStartup == null) return null;\n\n    if (!newestLogOnStartup.try_incref()) return null;   // log file was already closed\n\n    // now that we've incremented the reference, the log shouldn't go away.\n    try {\n      if (newestLogOnStartup.endsWithCommit()) {\n        newestLogOnStartup.decref();\n        return null;\n      }\n    } catch (IOException e) {\n      log.error(\"Error inspecting tlog \" + newestLogOnStartup);\n      newestLogOnStartup.decref();\n      return null;\n    }\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<RecoveryInfo>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(newestLogOnStartup, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    return cs.submit(replayer, recoveryInfo);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<TransactionLog>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<RecoveryInfo>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"215ff2055badad52b893ffdd6250cf36560086f3","date":1408135847,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","bugFix":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9da6af0d6e0b9ee92e3adbfd2796792453afbef","date":1472233199,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"72b93de9124049bdac1d82afb795dd2a463b5b37","date":1484151664,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n\n      // The deleteByQueries and oldDeletes lists\n      // would've been populated by items from the logs themselves (which we\n      // will replay now). So lets clear them out here before the replay.\n      deleteByQueries.clear();\n      oldDeletes.clear();\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n\n      // The deleteByQueries and oldDeletes lists\n      // would've been populated by items from the logs themselves (which we\n      // will replay now). So lets clear them out here before the replay.\n      deleteByQueries.clear();\n      oldDeletes.clear();\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#recoverFromLog().mjava","sourceNew":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog {}\", ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n\n      // The deleteByQueries and oldDeletes lists\n      // would've been populated by items from the logs themselves (which we\n      // will replay now). So lets clear them out here before the replay.\n      deleteByQueries.clear();\n      oldDeletes.clear();\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","sourceOld":"  public Future<RecoveryInfo> recoverFromLog() {\n    recoveryInfo = new RecoveryInfo();\n\n    List<TransactionLog> recoverLogs = new ArrayList<>(1);\n    for (TransactionLog ll : newestLogsOnStartup) {\n      if (!ll.try_incref()) continue;\n\n      try {\n        if (ll.endsWithCommit()) {\n          ll.closeOutput();\n          ll.decref();\n          continue;\n        }\n      } catch (IOException e) {\n        log.error(\"Error inspecting tlog \" + ll, e);\n        ll.closeOutput();\n        ll.decref();\n        continue;\n      }\n\n      recoverLogs.add(ll);\n    }\n\n    if (recoverLogs.isEmpty()) return null;\n\n    ExecutorCompletionService<RecoveryInfo> cs = new ExecutorCompletionService<>(recoveryExecutor);\n    LogReplayer replayer = new LogReplayer(recoverLogs, false);\n\n    versionInfo.blockUpdates();\n    try {\n      state = State.REPLAYING;\n\n      // The deleteByQueries and oldDeletes lists\n      // would've been populated by items from the logs themselves (which we\n      // will replay now). So lets clear them out here before the replay.\n      deleteByQueries.clear();\n      oldDeletes.clear();\n    } finally {\n      versionInfo.unblockUpdates();\n    }\n\n    // At this point, we are guaranteed that any new updates coming in will see the state as \"replaying\"\n\n    return cs.submit(replayer, recoveryInfo);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d9da6af0d6e0b9ee92e3adbfd2796792453afbef":["215ff2055badad52b893ffdd6250cf36560086f3"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1a9e81d464930e5664da049442e2630d4b9b00d5"],"740d649f013f07efbeb73ca854f106c60166e7c0":["72b93de9124049bdac1d82afb795dd2a463b5b37"],"215ff2055badad52b893ffdd6250cf36560086f3":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","1a9e81d464930e5664da049442e2630d4b9b00d5"],"1a9e81d464930e5664da049442e2630d4b9b00d5":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"72b93de9124049bdac1d82afb795dd2a463b5b37":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","72b93de9124049bdac1d82afb795dd2a463b5b37"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["215ff2055badad52b893ffdd6250cf36560086f3","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["215ff2055badad52b893ffdd6250cf36560086f3","d9da6af0d6e0b9ee92e3adbfd2796792453afbef"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"]},"commit2Childs":{"d9da6af0d6e0b9ee92e3adbfd2796792453afbef":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["215ff2055badad52b893ffdd6250cf36560086f3"],"215ff2055badad52b893ffdd6250cf36560086f3":["d9da6af0d6e0b9ee92e3adbfd2796792453afbef","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"1a9e81d464930e5664da049442e2630d4b9b00d5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"72b93de9124049bdac1d82afb795dd2a463b5b37":["740d649f013f07efbeb73ca854f106c60166e7c0","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["72b93de9124049bdac1d82afb795dd2a463b5b37","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1a9e81d464930e5664da049442e2630d4b9b00d5","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}