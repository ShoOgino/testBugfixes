{"path":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets#testRandomFloats().mjava","commits":[{"id":"ce7aff7772c162c15d520e31af46c555f60d5c3b","date":1385135519,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      SimpleFacetsCollector sfc = new SimpleFacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new RangeFacetCounts(\"field\", sfc, ranges);\n      SimpleFacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        FloatRange range = ranges[rangeID];\n\n        // Test drill-down:\n        SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector fc = FacetsCollector.create(new RangeAccumulator(new RangeFacetRequest<FloatRange>(\"field\", ranges)));\n      s.search(new MatchAllDocsQuery(), fc);\n      List<FacetResult> results = fc.getFacetResults();\n      assertEquals(1, results.size());\n      List<FacetResultNode> nodes = results.get(0).getFacetResultNode().subResults;\n      assertEquals(numRange, nodes.size());\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        FacetResultNode subNode = nodes.get(rangeID);\n        assertEquals(\"field/r\" + rangeID, subNode.label.toString('/'));\n        assertEquals(expectedCounts[rangeID], (int) subNode.value);\n\n        FloatRange range = (FloatRange) ((RangeFacetRequest<?>) results.get(0).getFacetRequest()).ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacets#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector sfc = new FacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new RangeFacetCounts(\"field\", sfc, ranges);\n      FacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        FloatRange range = ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      SimpleFacetsCollector sfc = new SimpleFacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new RangeFacetCounts(\"field\", sfc, ranges);\n      SimpleFacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        FloatRange range = ranges[rangeID];\n\n        // Test drill-down:\n        SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["ce7aff7772c162c15d520e31af46c555f60d5c3b"],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ce7aff7772c162c15d520e31af46c555f60d5c3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"21d36d0db865f7b84026b447bec653469a6e66df":[],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["21d36d0db865f7b84026b447bec653469a6e66df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["21d36d0db865f7b84026b447bec653469a6e66df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}