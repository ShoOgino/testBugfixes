{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","commits":[{"id":"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d","date":1525873214,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, -1, -1);\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 1, -1, -1);\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f2203cb8ae87188877cfbf6ad170c5738a0aad5","date":1528117512,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","sourceNew":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, 0, -1, -1);\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 0, 1, -1, -1);\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","sourceOld":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, -1, -1);\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 1, -1, -1);\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","sourceNew":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, 0, -1, -1);\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 0, 1, -1, -1);\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","sourceOld":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, -1, -1);\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 1, -1, -1);\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","sourceNew":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, 0, -1, -1);\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 0, 1, -1, -1);\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","sourceOld":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, -1, -1);\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 1, -1, -1);\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14654be3f7a82c9a3c52169e365baa55bfe64f66","date":1587212697,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseLiveDocsFormatTestCase#testSerialization(int,int,boolean).mjava","sourceNew":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, 0, -1, -1, StringHelper.randomId());\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 0, 1, -1, -1, StringHelper.randomId());\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","sourceOld":"  private void testSerialization(int maxDoc, int numLiveDocs, boolean fixedBitSet) throws IOException {\n    final Codec codec = Codec.getDefault();\n    final LiveDocsFormat format = codec.liveDocsFormat();\n\n    final FixedBitSet liveDocs = new FixedBitSet(maxDoc);\n    if (numLiveDocs > maxDoc / 2) {\n      liveDocs.set(0, maxDoc);\n      for (int i = 0; i < maxDoc - numLiveDocs; ++i) {\n        int clearBit;\n        do {\n          clearBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(clearBit) == false);\n        liveDocs.clear(clearBit);\n      }\n    } else {\n      for (int i = 0; i < numLiveDocs; ++i) {\n        int setBit;\n        do {\n          setBit = random().nextInt(maxDoc);\n        } while (liveDocs.get(setBit));\n        liveDocs.set(setBit);\n      }\n    }\n\n    final Bits bits;\n    if (fixedBitSet) {\n      bits = liveDocs;\n    } else {\n      // Make sure the impl doesn't only work with a FixedBitSet\n      bits = new Bits() {\n\n        @Override\n        public boolean get(int index) {\n          return liveDocs.get(index);\n        }\n\n        @Override\n        public int length() {\n          return liveDocs.length();\n        }\n\n      };\n    }\n\n    final Directory dir = newDirectory();\n    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, Version.LATEST, \"foo\", maxDoc, random().nextBoolean(),\n        codec, Collections.emptyMap(), StringHelper.randomId(), Collections.emptyMap(), null);\n    SegmentCommitInfo sci = new SegmentCommitInfo(si, 0, 0, 0, -1, -1);\n    format.writeLiveDocs(bits, dir, sci, maxDoc - numLiveDocs, IOContext.DEFAULT);\n\n    sci = new SegmentCommitInfo(si, maxDoc - numLiveDocs, 0, 1, -1, -1);\n    final Bits bits2 = format.readLiveDocs(dir, sci, IOContext.READONCE);\n    assertEquals(maxDoc, bits2.length());\n    for (int i = 0; i < maxDoc; ++i) {\n      assertEquals(bits.get(i), bits2.get(i));\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"14654be3f7a82c9a3c52169e365baa55bfe64f66":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d"],"f592209545c71895260367152601e9200399776d":["fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["14654be3f7a82c9a3c52169e365baa55bfe64f66"]},"commit2Childs":{"14654be3f7a82c9a3c52169e365baa55bfe64f66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d":["b70042a8a492f7054d480ccdd2be9796510d4327","8f2203cb8ae87188877cfbf6ad170c5738a0aad5","f592209545c71895260367152601e9200399776d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["14654be3f7a82c9a3c52169e365baa55bfe64f66","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}