{"path":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","commits":[{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will abort all\n   * running merges and return right away\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n    if (doClose)\n      closeInternal(waitForMerges);\n    else\n      // Another thread beat us to it (is actually doing the\n      // close), so we will block until that other thread\n      // has finished closing\n      waitForClose();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["346d5897e4c4e77ed5dbd31f7730ff30973d5971","c619aff1490fbcbfb8aee81049da5e5120a986d6","25a69ca6651c6c39154826d22ee7a0b606cb5d8c","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"346d5897e4c4e77ed5dbd31f7730ff30973d5971","date":1198317988,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","sourceNew":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n    if (doClose)\n      closeInternal(waitForMerges);\n    else\n      // Another thread beat us to it (is actually doing the\n      // close), so we will block until that other thread\n      // has finished closing\n      waitForClose();\n  }\n\n","sourceOld":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will abort all\n   * running merges and return right away\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n    if (doClose)\n      closeInternal(waitForMerges);\n    else\n      // Another thread beat us to it (is actually doing the\n      // close), so we will block until that other thread\n      // has finished closing\n      waitForClose();\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63","date":1204234542,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","sourceNew":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n    boolean doClose;\n\n    // If any methods have hit OutOfMemoryError, then abort\n    // on close, in case the internal state of IndexWriter\n    // or DocumentsWriter is corrupt\n    if (hitOOM)\n      abort();\n\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n    if (doClose)\n      closeInternal(waitForMerges);\n    else\n      // Another thread beat us to it (is actually doing the\n      // close), so we will block until that other thread\n      // has finished closing\n      waitForClose();\n  }\n\n","sourceOld":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n    boolean doClose;\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n    if (doClose)\n      closeInternal(waitForMerges);\n    else\n      // Another thread beat us to it (is actually doing the\n      // close), so we will block until that other thread\n      // has finished closing\n      waitForClose();\n  }\n\n","bugFix":null,"bugIntro":["c619aff1490fbcbfb8aee81049da5e5120a986d6","25a69ca6651c6c39154826d22ee7a0b606cb5d8c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c619aff1490fbcbfb8aee81049da5e5120a986d6","date":1217432296,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","sourceNew":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // If any methods have hit OutOfMemoryError, then abort\n    // on close, in case the internal state of IndexWriter\n    // or DocumentsWriter is corrupt\n    if (hitOOM) {\n      rollback();\n      return;\n    }\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      closeInternal(waitForMerges);\n  }\n\n","sourceOld":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n    boolean doClose;\n\n    // If any methods have hit OutOfMemoryError, then abort\n    // on close, in case the internal state of IndexWriter\n    // or DocumentsWriter is corrupt\n    if (hitOOM)\n      abort();\n\n    synchronized(this) {\n      // Ensure that only one thread actually gets to do the closing:\n      if (!closing) {\n        doClose = true;\n        closing = true;\n      } else\n        doClose = false;\n    }\n    if (doClose)\n      closeInternal(waitForMerges);\n    else\n      // Another thread beat us to it (is actually doing the\n      // close), so we will block until that other thread\n      // has finished closing\n      waitForClose();\n  }\n\n","bugFix":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63","b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":["25a69ca6651c6c39154826d22ee7a0b606cb5d8c","f241b963c5bcd6c2293a928059dd2d64988a6042"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25a69ca6651c6c39154826d22ee7a0b606cb5d8c","date":1225195699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","sourceNew":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose()) {\n      // If any methods have hit OutOfMemoryError, then abort\n      // on close, in case the internal state of IndexWriter\n      // or DocumentsWriter is corrupt\n      if (hitOOM)\n        rollbackInternal();\n      else\n        closeInternal(waitForMerges);\n    }\n  }\n\n","sourceOld":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // If any methods have hit OutOfMemoryError, then abort\n    // on close, in case the internal state of IndexWriter\n    // or DocumentsWriter is corrupt\n    if (hitOOM) {\n      rollback();\n      return;\n    }\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose())\n      closeInternal(waitForMerges);\n  }\n\n","bugFix":["c619aff1490fbcbfb8aee81049da5e5120a986d6","01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63","b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"bugIntro":["f241b963c5bcd6c2293a928059dd2d64988a6042"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9665d17707cc21b1db995118ff36129723139ab","date":1225384420,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","sourceNew":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose()) {\n      // If any methods have hit OutOfMemoryError, then abort\n      // on close, in case the internal state of IndexWriter\n      // or DocumentsWriter is corrupt\n      if (hitOOM)\n        rollbackInternal();\n      else\n        closeInternal(waitForMerges);\n    }\n  }\n\n","sourceOld":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose()) {\n      // If any methods have hit OutOfMemoryError, then abort\n      // on close, in case the internal state of IndexWriter\n      // or DocumentsWriter is corrupt\n      if (hitOOM)\n        rollbackInternal();\n      else\n        closeInternal(waitForMerges);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba5dc21307a06a4fa823dcd50d57110f69eb424a","date":1236775380,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","sourceNew":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer, again.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: it is dangerous to always call\n   * close(false), especially when IndexWriter is not open\n   * for very long, because this can result in \"merge\n   * starvation\" whereby long merges will never have a\n   * chance to finish.  This will cause too many segments in\n   * your index over time.</p>\n   *\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose()) {\n      // If any methods have hit OutOfMemoryError, then abort\n      // on close, in case the internal state of IndexWriter\n      // or DocumentsWriter is corrupt\n      if (hitOOM)\n        rollbackInternal();\n      else\n        closeInternal(waitForMerges);\n    }\n  }\n\n","sourceOld":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose()) {\n      // If any methods have hit OutOfMemoryError, then abort\n      // on close, in case the internal state of IndexWriter\n      // or DocumentsWriter is corrupt\n      if (hitOOM)\n        rollbackInternal();\n      else\n        closeInternal(waitForMerges);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#close(boolean).mjava","sourceNew":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer, again.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: it is dangerous to always call\n   * close(false), especially when IndexWriter is not open\n   * for very long, because this can result in \"merge\n   * starvation\" whereby long merges will never have a\n   * chance to finish.  This will cause too many segments in\n   * your index over time.</p>\n   *\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose()) {\n      // If any methods have hit OutOfMemoryError, then abort\n      // on close, in case the internal state of IndexWriter\n      // or DocumentsWriter is corrupt\n      if (hitOOM)\n        rollbackInternal();\n      else\n        closeInternal(waitForMerges);\n    }\n  }\n\n","sourceOld":"  /**\n   * Closes the index with or without waiting for currently\n   * running merges to finish.  This is only meaningful when\n   * using a MergeScheduler that runs merges in background\n   * threads.\n   *\n   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   * you should immediately close the writer, again.  See <a\n   * href=\"#OOME\">above</a> for details.</p>\n   *\n   * <p><b>NOTE</b>: it is dangerous to always call\n   * close(false), especially when IndexWriter is not open\n   * for very long, because this can result in \"merge\n   * starvation\" whereby long merges will never have a\n   * chance to finish.  This will cause too many segments in\n   * your index over time.</p>\n   *\n   * @param waitForMerges if true, this call will block\n   * until all merges complete; else, it will ask all\n   * running merges to abort, wait until those merges have\n   * finished (which should be at most a few seconds), and\n   * then return.\n   */\n  public void close(boolean waitForMerges) throws CorruptIndexException, IOException {\n\n    // Ensure that only one thread actually gets to do the closing:\n    if (shouldClose()) {\n      // If any methods have hit OutOfMemoryError, then abort\n      // on close, in case the internal state of IndexWriter\n      // or DocumentsWriter is corrupt\n      if (hitOOM)\n        rollbackInternal();\n      else\n        closeInternal(waitForMerges);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e9665d17707cc21b1db995118ff36129723139ab":["25a69ca6651c6c39154826d22ee7a0b606cb5d8c"],"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba5dc21307a06a4fa823dcd50d57110f69eb424a":["e9665d17707cc21b1db995118ff36129723139ab"],"c619aff1490fbcbfb8aee81049da5e5120a986d6":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63"],"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"25a69ca6651c6c39154826d22ee7a0b606cb5d8c":["c619aff1490fbcbfb8aee81049da5e5120a986d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["ba5dc21307a06a4fa823dcd50d57110f69eb424a"]},"commit2Childs":{"e9665d17707cc21b1db995118ff36129723139ab":["ba5dc21307a06a4fa823dcd50d57110f69eb424a"],"346d5897e4c4e77ed5dbd31f7730ff30973d5971":["01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["346d5897e4c4e77ed5dbd31f7730ff30973d5971"],"ba5dc21307a06a4fa823dcd50d57110f69eb424a":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c619aff1490fbcbfb8aee81049da5e5120a986d6":["25a69ca6651c6c39154826d22ee7a0b606cb5d8c"],"01deb9e9fb9dbd5fddce32a5fcd952bbb611fe63":["c619aff1490fbcbfb8aee81049da5e5120a986d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"25a69ca6651c6c39154826d22ee7a0b606cb5d8c":["e9665d17707cc21b1db995118ff36129723139ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}