{"path":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","commits":[{"id":"106069d345c14ee5c76f0ea76397b02a656f883c","date":1411998064,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Integer call() throws Exception {\n      HttpSolrServer solr = new HttpSolrServer(coreUrl);\n      int remoteVersion = -1;\n      try {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrServer.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      } finally {\n        solr.shutdown();\n      }\n\n      return remoteVersion;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Integer call() throws Exception {\n      HttpSolrServer solr = new HttpSolrServer(coreUrl);\n      int remoteVersion = -1;\n      try {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrServer.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      } finally {\n        solr.shutdown();\n      }\n\n      return remoteVersion;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","sourceNew":"    @Override\n    public Integer call() throws Exception {\n      HttpSolrClient solr = new HttpSolrClient(coreUrl);\n      int remoteVersion = -1;\n      try {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      } finally {\n        solr.shutdown();\n      }\n\n      return remoteVersion;\n    }\n\n","sourceOld":"    @Override\n    public Integer call() throws Exception {\n      HttpSolrServer solr = new HttpSolrServer(coreUrl);\n      int remoteVersion = -1;\n      try {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrServer.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      } finally {\n        solr.shutdown();\n      }\n\n      return remoteVersion;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","sourceNew":"    @Override\n    public Integer call() throws Exception {\n      int remoteVersion = -1;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return remoteVersion;\n    }\n\n","sourceOld":"    @Override\n    public Integer call() throws Exception {\n      HttpSolrClient solr = new HttpSolrClient(coreUrl);\n      int remoteVersion = -1;\n      try {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      } finally {\n        solr.shutdown();\n      }\n\n      return remoteVersion;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","sourceNew":"    @Override\n    public Integer call() throws Exception {\n      int remoteVersion = -1;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return remoteVersion;\n    }\n\n","sourceOld":"    @Override\n    public Integer call() throws Exception {\n      int remoteVersion = -1;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return remoteVersion;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","sourceNew":"    @Override\n    public Integer call() throws Exception {\n      int remoteVersion = -1;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return remoteVersion;\n    }\n\n","sourceOld":"    @Override\n    public Integer call() throws Exception {\n      int remoteVersion = -1;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return remoteVersion;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/ManagedIndexSchema.GetZkSchemaVersionCallable#call().mjava","sourceNew":"    @Override\n    public Integer call() throws Exception {\n      int remoteVersion = -1;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica {} returned schema version {} and has not applied schema version {}\"\n                  , coreUrl, remoteVersion, expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from {} due to: \", coreUrl, e);\n            }\n          }\n        }\n      }\n      return remoteVersion;\n    }\n\n","sourceOld":"    @Override\n    public Integer call() throws Exception {\n      int remoteVersion = -1;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (remoteVersion == -1 || remoteVersion < expectedZkVersion) {\n          try {\n            HttpSolrClient.HttpUriRequestResponse mrr = solr.httpUriRequest(this);\n            NamedList<Object> zkversionResp = mrr.future.get();\n            if (zkversionResp != null)\n              remoteVersion = (Integer)zkversionResp.get(\"zkversion\");\n\n            if (remoteVersion < expectedZkVersion) {\n              // rather than waiting and re-polling, let's be proactive and tell the replica\n              // to refresh its schema from ZooKeeper, if that fails, then the\n              //Thread.sleep(1000); // slight delay before requesting version again\n              log.error(\"Replica \"+coreUrl+\" returned schema version \"+\n                  remoteVersion+\" and has not applied schema version \"+expectedZkVersion);\n            }\n\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return remoteVersion;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["cc3b13b430571c2e169f98fe38e1e7666f88522d","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","106069d345c14ee5c76f0ea76397b02a656f883c"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["106069d345c14ee5c76f0ea76397b02a656f883c"],"106069d345c14ee5c76f0ea76397b02a656f883c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9df8125ba9193a2e2e285ed92157810b1952a244"],"9df8125ba9193a2e2e285ed92157810b1952a244":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"]},"commit2Childs":{"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9a47902d6207303f5ed3e7aaca62ca33433af66","106069d345c14ee5c76f0ea76397b02a656f883c"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["9df8125ba9193a2e2e285ed92157810b1952a244"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"106069d345c14ee5c76f0ea76397b02a656f883c":["d9a47902d6207303f5ed3e7aaca62ca33433af66","bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9df8125ba9193a2e2e285ed92157810b1952a244":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["d9a47902d6207303f5ed3e7aaca62ca33433af66","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}