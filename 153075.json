{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","commits":[{"id":"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2","date":1346834651,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","sourceNew":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitions.length) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            assert state.transitionUpto < state.transitions.length: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length;\n            state.transitionMin = state.transitions[state.transitionUpto].getMin();\n            state.transitionMax = state.transitions[state.transitionUpto].getMax();\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitions = compiledAutomaton.sortedTransitions[nextState];\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitions.length) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            assert state.transitionUpto < state.transitions.length: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length;\n            state.transitionMin = state.transitions[state.transitionUpto].getMin();\n            state.transitionMax = state.transitions[state.transitionUpto].getMax();\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitions = compiledAutomaton.sortedTransitions[nextState];\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","sourceNew":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitionCount) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            compiledAutomaton.lightAutomaton.getNextTransition(state.transition);\n            assert state.transitionUpto < state.transitionCount: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitionCount;\n            state.transitionMin = state.transition.min;\n            state.transitionMax = state.transition.max;\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(nextState);\n            compiledAutomaton.lightAutomaton.initTransition(nextState, states[stateUpto].transition);\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitions.length) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            assert state.transitionUpto < state.transitions.length: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length;\n            state.transitionMin = state.transitions[state.transitionUpto].getMin();\n            state.transitionMax = state.transitions[state.transitionUpto].getMax();\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitions = compiledAutomaton.sortedTransitions[nextState];\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","sourceNew":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitionCount) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            compiledAutomaton.automaton.getNextTransition(state.transition);\n            assert state.transitionUpto < state.transitionCount: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitionCount;\n            state.transitionMin = state.transition.min;\n            state.transitionMax = state.transition.max;\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n            compiledAutomaton.automaton.initTransition(nextState, states[stateUpto].transition);\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitionCount) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            compiledAutomaton.lightAutomaton.getNextTransition(state.transition);\n            assert state.transitionUpto < state.transitionCount: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitionCount;\n            state.transitionMin = state.transition.min;\n            state.transitionMax = state.transition.max;\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitionCount = compiledAutomaton.lightAutomaton.getNumTransitions(nextState);\n            compiledAutomaton.lightAutomaton.initTransition(nextState, states[stateUpto].transition);\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","sourceNew":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitionCount) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            compiledAutomaton.automaton.getNextTransition(state.transition);\n            assert state.transitionUpto < state.transitionCount: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitionCount;\n            state.transitionMin = state.transition.min;\n            state.transitionMax = state.transition.max;\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n            compiledAutomaton.automaton.initTransition(nextState, states[stateUpto].transition);\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitions.length) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            assert state.transitionUpto < state.transitions.length: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length;\n            state.transitionMin = state.transitions[state.transitionUpto].getMin();\n            state.transitionMax = state.transitions[state.transitionUpto].getMax();\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitions = compiledAutomaton.sortedTransitions[nextState];\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#next().mjava","sourceNew":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n\n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitionCount) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            compiledAutomaton.automaton.getNextTransition(state.transition);\n            assert state.transitionUpto < state.transitionCount: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitionCount;\n            state.transitionMin = state.transition.min;\n            state.transitionMax = state.transition.max;\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n            compiledAutomaton.automaton.initTransition(nextState, states[stateUpto].transition);\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n\n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","sourceOld":"      @Override\n      public BytesRef next() {\n        // if (DEBUG) {\n        //   System.out.println(\"\\nIE.next\");\n        // }\n\n        termOrd++;\n        int skipUpto = 0;\n\n        if (termOrd == 0 && termOffsets[1] == 0) {\n          // Special-case empty string:\n          assert stateUpto == 0;\n          // if (DEBUG) {\n          //   System.out.println(\"  visit empty string\");\n          // }\n          if (runAutomaton.isAccept(states[0].state)) {\n            scratch.bytes = termBytes;\n            scratch.offset = 0;\n            scratch.length = 0;\n            return scratch;\n          }\n          termOrd++;\n        }\n\n        nextTerm:\n\n        while (true) {\n          // if (DEBUG) {\n          //   System.out.println(\"  cycle termOrd=\" + termOrd + \" stateUpto=\" + stateUpto + \" skipUpto=\" + skipUpto);\n          // }\n          if (termOrd == terms.length) {\n            // if (DEBUG) {\n            //   System.out.println(\"  return END\");\n            // }\n            return null;\n          }\n\n          final State state = states[stateUpto];\n          if (termOrd == state.changeOrd) {\n            // Pop:\n            // if (DEBUG) {\n            //   System.out.println(\"  pop stateUpto=\" + stateUpto);\n            // }\n            stateUpto--;\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)).utf8ToString());\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix pop \" + new BytesRef(terms[termOrd].term, 0, Math.min(stateUpto, terms[termOrd].term.length)));\n              }\n            }\n            */\n\n            continue;\n          }\n\n          final int termOffset = termOffsets[termOrd];\n          final int termLength = termOffsets[termOrd+1] - termOffset;\n          final int skipOffset = skipOffsets[termOrd];\n          final int numSkips = skipOffsets[termOrd+1] - skipOffset;\n\n          // if (DEBUG) {\n          //   System.out.println(\"  term=\" + new BytesRef(termBytes, termOffset, termLength).utf8ToString() + \" skips=\" + Arrays.toString(skips));\n          // }\n        \n          assert termOrd < state.changeOrd;\n\n          assert stateUpto <= termLength: \"term.length=\" + termLength + \"; stateUpto=\" + stateUpto;\n          final int label = termBytes[termOffset+stateUpto] & 0xFF;\n\n          while (label > state.transitionMax) {\n            //System.out.println(\"  label=\" + label + \" vs max=\" + state.transitionMax + \" transUpto=\" + state.transitionUpto + \" vs \" + state.transitions.length);\n            state.transitionUpto++;\n            if (state.transitionUpto == state.transitionCount) {\n              // We've exhausted transitions leaving this\n              // state; force pop+next/skip now:\n              //System.out.println(\"forcepop: stateUpto=\" + stateUpto);\n              if (stateUpto == 0) {\n                termOrd = terms.length;\n                return null;\n              } else {\n                assert state.changeOrd > termOrd;\n                // if (DEBUG) {\n                //   System.out.println(\"  jumpend \" + (state.changeOrd - termOrd));\n                // }\n                //System.out.println(\"  jump to termOrd=\" + states[stateUpto].changeOrd + \" vs \" + termOrd);\n                termOrd = states[stateUpto].changeOrd;\n                skipUpto = 0;\n                stateUpto--;\n              }\n              continue nextTerm;\n            }\n            compiledAutomaton.automaton.getNextTransition(state.transition);\n            assert state.transitionUpto < state.transitionCount: \" state.transitionUpto=\" + state.transitionUpto + \" vs \" + state.transitionCount;\n            state.transitionMin = state.transition.min;\n            state.transitionMax = state.transition.max;\n            assert state.transitionMin >= 0;\n            assert state.transitionMin <= 255;\n            assert state.transitionMax >= 0;\n            assert state.transitionMax <= 255;\n          }\n\n          /*\n          if (DEBUG) {\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + (char) label + \"(\" + label + \") term=\" + new BytesRef(terms[termOrd].term).utf8ToString() + \" trans \" +\n                               (char) state.transitionMin + \"(\" + state.transitionMin + \")\" + \"-\" + (char) state.transitionMax + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n            System.out.println(\"    check ord=\" + termOrd + \" term[\" + stateUpto + \"]=\" + Integer.toHexString(label) + \"(\" + label + \") term=\" + new BytesRef(termBytes, termOffset, termLength) + \" trans \" +\n                               Integer.toHexString(state.transitionMin) + \"(\" + state.transitionMin + \")\" + \"-\" + Integer.toHexString(state.transitionMax) + \"(\" + state.transitionMax + \") nextChange=+\" + (state.changeOrd - termOrd) + \" skips=\" + (skips == null ? \"null\" : Arrays.toString(skips)));\n          }\n          */\n\n          final int targetLabel = state.transitionMin;\n\n          if ((termBytes[termOffset+stateUpto] & 0xFF) < targetLabel) {\n            // if (DEBUG) {\n            //   System.out.println(\"    do bin search\");\n            // }\n            //int startTermOrd = termOrd;\n            int low = termOrd+1;\n            int high = state.changeOrd-1;\n            while (true) {\n              if (low > high) {\n                // Label not found\n                termOrd = low;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int mid = (low + high) >>> 1;\n              int cmp = (termBytes[termOffsets[mid] + stateUpto] & 0xFF) - targetLabel;\n              // if (DEBUG) {\n              //   System.out.println(\"      bin: check label=\" + (char) (termBytes[termOffsets[low] + stateUpto] & 0xFF) + \" ord=\" + mid);\n              // }\n              if (cmp < 0) {\n                low = mid+1;\n              } else if (cmp > 0) {\n                high = mid - 1;\n              } else {\n                // Label found; walk backwards to first\n                // occurrence:\n                while (mid > termOrd && (termBytes[termOffsets[mid-1] + stateUpto] & 0xFF) == targetLabel) {\n                  mid--;\n                }\n                termOrd = mid;\n                // if (DEBUG) {\n                //   System.out.println(\"      advanced by \" + (termOrd - startTermOrd));\n                // }\n                //System.out.println(\"  jump \" + (termOrd - startTermOrd));\n                skipUpto = 0;\n                continue nextTerm;\n              }\n            }\n          }\n\n          int nextState = runAutomaton.step(states[stateUpto].state, label);\n\n          if (nextState == -1) {\n            // Skip\n            // if (DEBUG) {\n            //   System.out.println(\"  automaton doesn't accept; skip\");\n            // }\n            if (skipUpto < numSkips) {\n              // if (DEBUG) {\n              //   System.out.println(\"  jump \" + (skips[skipOffset+skipUpto]-1 - termOrd));\n              // }\n              termOrd = skips[skipOffset+skipUpto];\n            } else {\n              termOrd++;\n            }\n            skipUpto = 0;\n          } else if (skipUpto < numSkips) {\n            // Push:\n            // if (DEBUG) {\n            //   System.out.println(\"  push\");\n            // }\n            /*\n            if (DEBUG) {\n              try {\n                //System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1).utf8ToString());\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              } catch (ArrayIndexOutOfBoundsException aioobe) {\n                System.out.println(\"    prefix push \" + new BytesRef(term, 0, stateUpto+1));\n              }\n            }\n            */\n\n            grow();\n            stateUpto++;\n            states[stateUpto].state = nextState;\n            states[stateUpto].changeOrd = skips[skipOffset + skipUpto++];\n            states[stateUpto].transitionCount = compiledAutomaton.automaton.getNumTransitions(nextState);\n            compiledAutomaton.automaton.initTransition(nextState, states[stateUpto].transition);\n            states[stateUpto].transitionUpto = -1;\n            states[stateUpto].transitionMax = -1;\n            \n            if (stateUpto == termLength) {\n              // if (DEBUG) {\n              //   System.out.println(\"  term ends after push\");\n              // }\n              if (runAutomaton.isAccept(nextState)) {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton accepts: return\");\n                // }\n                scratch.bytes = termBytes;\n                scratch.offset = termOffsets[termOrd];\n                scratch.length = termOffsets[1+termOrd] - scratch.offset;\n                // if (DEBUG) {\n                //   System.out.println(\"  ret \" + scratch.utf8ToString());\n                // }\n                return scratch;\n              } else {\n                // if (DEBUG) {\n                //   System.out.println(\"  automaton rejects: nextTerm\");\n                // }\n                termOrd++;\n                skipUpto = 0;\n              }\n            }\n          } else {\n            // Run the non-indexed tail of this term:\n\n            // TODO: add assert that we don't inc too many times\n\n            if (compiledAutomaton.commonSuffixRef != null) {\n              //System.out.println(\"suffix \" + compiledAutomaton.commonSuffixRef.utf8ToString());\n              assert compiledAutomaton.commonSuffixRef.offset == 0;\n              if (termLength < compiledAutomaton.commonSuffixRef.length) {\n                termOrd++;\n                skipUpto = 0;\n                continue nextTerm;\n              }\n              int offset = termOffset + termLength - compiledAutomaton.commonSuffixRef.length;\n              for(int suffix=0;suffix<compiledAutomaton.commonSuffixRef.length;suffix++) {\n                if (termBytes[offset + suffix] != compiledAutomaton.commonSuffixRef.bytes[suffix]) {\n                  termOrd++;\n                  skipUpto = 0;\n                  continue nextTerm;\n                }\n              }\n            }\n\n            int upto = stateUpto+1;\n            while (upto < termLength) {\n              nextState = runAutomaton.step(nextState, termBytes[termOffset+upto] & 0xFF);\n              if (nextState == -1) {\n                termOrd++;\n                skipUpto = 0;\n                // if (DEBUG) {\n                //   System.out.println(\"  nomatch tail; next term\");\n                // }\n                continue nextTerm;\n              }\n              upto++;\n            }\n\n            if (runAutomaton.isAccept(nextState)) {\n              scratch.bytes = termBytes;\n              scratch.offset = termOffsets[termOrd];\n              scratch.length = termOffsets[1+termOrd] - scratch.offset;\n              // if (DEBUG) {\n              //   System.out.println(\"  match tail; return \" + scratch.utf8ToString());\n              //   System.out.println(\"  ret2 \" + scratch.utf8ToString());\n              // }\n              return scratch;\n            } else {\n              termOrd++;\n              skipUpto = 0;\n              // if (DEBUG) {\n              //   System.out.println(\"  nomatch tail; next term\");\n              // }\n            }\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"5c84485629d80d203608e8975a1139de9933cc38":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"51f5280f31484820499077f41fcdfe92d527d9dc":["5c84485629d80d203608e8975a1139de9933cc38"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["51f5280f31484820499077f41fcdfe92d527d9dc"]},"commit2Childs":{"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["51f5280f31484820499077f41fcdfe92d527d9dc"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"51f5280f31484820499077f41fcdfe92d527d9dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}