{"path":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase#cancelElection().mjava","commits":[{"id":"ba33781da68babcaa5828121b443d3eb5c9d8480","date":1590595589,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase#cancelElection().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase[ElectionContext]#cancelElection().mjava","sourceNew":"  @Override\n  public void cancelElection() throws InterruptedException, KeeperException {\n    super.cancelElection();\n    synchronized (lock) {\n      if (leaderZkNodeParentVersion != null) {\n        // no problem\n        // no problem\n        try {\n          // We need to be careful and make sure we *only* delete our own leader registration node.\n          // We do this by using a multi and ensuring the parent znode of the leader registration node\n          // matches the version we expect - there is a setData call that increments the parent's znode\n          // version whenever a leader registers.\n          log.debug(\"Removing leader registration node on cancel: {} {}\", leaderPath, leaderZkNodeParentVersion);\n          List<Op> ops = new ArrayList<>(2);\n          ops.add(Op.check(new Path(leaderPath).getParent().toString(), leaderZkNodeParentVersion));\n          ops.add(Op.delete(leaderPath, -1));\n          zkClient.multi(ops, true);\n        } catch (InterruptedException e) {\n          throw e;\n        } catch (IllegalArgumentException e) {\n          SolrException.log(log, e);\n        }\n        leaderZkNodeParentVersion = null;\n      } else {\n        log.info(\"No version found for ephemeral leader parent node, won't remove previous leader registration.\");\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cancelElection() throws InterruptedException, KeeperException {\n    super.cancelElection();\n    synchronized (lock) {\n      if (leaderZkNodeParentVersion != null) {\n        try {\n          // We need to be careful and make sure we *only* delete our own leader registration node.\n          // We do this by using a multi and ensuring the parent znode of the leader registration node\n          // matches the version we expect - there is a setData call that increments the parent's znode\n          // version whenever a leader registers.\n          log.debug(\"Removing leader registration node on cancel: {} {}\", leaderPath, leaderZkNodeParentVersion);\n          List<Op> ops = new ArrayList<>(2);\n          ops.add(Op.check(new Path(leaderPath).getParent().toString(), leaderZkNodeParentVersion));\n          ops.add(Op.delete(leaderPath, -1));\n          zkClient.multi(ops, true);\n        } catch (KeeperException.NoNodeException nne) {\n          // no problem\n          log.debug(\"No leader registration node found to remove: {}\", leaderPath);\n        } catch (KeeperException.BadVersionException bve) {\n          log.info(\"Cannot remove leader registration node because the current registered node is not ours: {}\", leaderPath);\n          // no problem\n        } catch (InterruptedException e) {\n          throw e;\n        } catch (Exception e) {\n          SolrException.log(log, e);\n        }\n        leaderZkNodeParentVersion = null;\n      } else {\n        log.info(\"No version found for ephemeral leader parent node, won't remove previous leader registration.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3adc4d119a7deba35b2721853853464857d9d0a9","date":1594608068,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase#cancelElection().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase#cancelElection().mjava","sourceNew":"  @Override\n  public void cancelElection() throws InterruptedException, KeeperException {\n    super.cancelElection();\n    synchronized (lock) {\n      if (leaderZkNodeParentVersion != null) {\n        // no problem\n        // no problem\n        try {\n          // We need to be careful and make sure we *only* delete our own leader registration node.\n          // We do this by using a multi and ensuring the parent znode of the leader registration node\n          // matches the version we expect - there is a setData call that increments the parent's znode\n          // version whenever a leader registers.\n          log.debug(\"Removing leader registration node on cancel: {} {}\", leaderPath, leaderZkNodeParentVersion);\n          List<Op> ops = new ArrayList<>(2);\n          ops.add(Op.check(Paths.get(leaderPath).getParent().toString(), leaderZkNodeParentVersion));\n          ops.add(Op.delete(leaderPath, -1));\n          zkClient.multi(ops, true);\n        } catch (InterruptedException e) {\n          throw e;\n        } catch (IllegalArgumentException e) {\n          SolrException.log(log, e);\n        }\n        leaderZkNodeParentVersion = null;\n      } else {\n        log.info(\"No version found for ephemeral leader parent node, won't remove previous leader registration.\");\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cancelElection() throws InterruptedException, KeeperException {\n    super.cancelElection();\n    synchronized (lock) {\n      if (leaderZkNodeParentVersion != null) {\n        // no problem\n        // no problem\n        try {\n          // We need to be careful and make sure we *only* delete our own leader registration node.\n          // We do this by using a multi and ensuring the parent znode of the leader registration node\n          // matches the version we expect - there is a setData call that increments the parent's znode\n          // version whenever a leader registers.\n          log.debug(\"Removing leader registration node on cancel: {} {}\", leaderPath, leaderZkNodeParentVersion);\n          List<Op> ops = new ArrayList<>(2);\n          ops.add(Op.check(new Path(leaderPath).getParent().toString(), leaderZkNodeParentVersion));\n          ops.add(Op.delete(leaderPath, -1));\n          zkClient.multi(ops, true);\n        } catch (InterruptedException e) {\n          throw e;\n        } catch (IllegalArgumentException e) {\n          SolrException.log(log, e);\n        }\n        leaderZkNodeParentVersion = null;\n      } else {\n        log.info(\"No version found for ephemeral leader parent node, won't remove previous leader registration.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d12cb2880d9de40cdf8dfb8398beedbe238e1b3f","date":1594861381,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase#cancelElection().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase#cancelElection().mjava","sourceNew":"  @Override\n  public void cancelElection() throws InterruptedException, KeeperException {\n    super.cancelElection();\n    synchronized (lock) {\n      if (leaderZkNodeParentVersion != null) {\n        // no problem\n        // no problem\n        try {\n          // We need to be careful and make sure we *only* delete our own leader registration node.\n          // We do this by using a multi and ensuring the parent znode of the leader registration node\n          // matches the version we expect - there is a setData call that increments the parent's znode\n          // version whenever a leader registers.\n          log.debug(\"Removing leader registration node on cancel: {} {}\", leaderPath, leaderZkNodeParentVersion);\n          List<Op> ops = new ArrayList<>(2);\n          // Fails on Windows if you use nio Paths.get here\n          ops.add(Op.check(new Path(leaderPath).getParent().toString(), leaderZkNodeParentVersion));\n          ops.add(Op.delete(leaderPath, -1));\n          zkClient.multi(ops, true);\n        } catch (InterruptedException e) {\n          throw e;\n        } catch (IllegalArgumentException e) {\n          SolrException.log(log, e);\n        }\n        leaderZkNodeParentVersion = null;\n      } else {\n        log.info(\"No version found for ephemeral leader parent node, won't remove previous leader registration.\");\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cancelElection() throws InterruptedException, KeeperException {\n    super.cancelElection();\n    synchronized (lock) {\n      if (leaderZkNodeParentVersion != null) {\n        // no problem\n        // no problem\n        try {\n          // We need to be careful and make sure we *only* delete our own leader registration node.\n          // We do this by using a multi and ensuring the parent znode of the leader registration node\n          // matches the version we expect - there is a setData call that increments the parent's znode\n          // version whenever a leader registers.\n          log.debug(\"Removing leader registration node on cancel: {} {}\", leaderPath, leaderZkNodeParentVersion);\n          List<Op> ops = new ArrayList<>(2);\n          ops.add(Op.check(Paths.get(leaderPath).getParent().toString(), leaderZkNodeParentVersion));\n          ops.add(Op.delete(leaderPath, -1));\n          zkClient.multi(ops, true);\n        } catch (InterruptedException e) {\n          throw e;\n        } catch (IllegalArgumentException e) {\n          SolrException.log(log, e);\n        }\n        leaderZkNodeParentVersion = null;\n      } else {\n        log.info(\"No version found for ephemeral leader parent node, won't remove previous leader registration.\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1b4e25416a41abd13d1febb3eebf589cbc71e5ae"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b4e25416a41abd13d1febb3eebf589cbc71e5ae","date":1595017101,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase#cancelElection().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase#cancelElection().mjava","sourceNew":"  @Override\n  public void cancelElection() throws InterruptedException, KeeperException {\n    super.cancelElection();\n    synchronized (lock) {\n      if (leaderZkNodeParentVersion != null) {\n        // no problem\n        // no problem\n        try {\n          // We need to be careful and make sure we *only* delete our own leader registration node.\n          // We do this by using a multi and ensuring the parent znode of the leader registration node\n          // matches the version we expect - there is a setData call that increments the parent's znode\n          // version whenever a leader registers.\n          log.debug(\"Removing leader registration node on cancel: {} {}\", leaderPath, leaderZkNodeParentVersion);\n          List<Op> ops = new ArrayList<>(2);\n          String parent = ZkMaintenanceUtils.getZkParent(leaderPath);\n          ops.add(Op.check(parent, leaderZkNodeParentVersion));\n          ops.add(Op.delete(leaderPath, -1));\n          zkClient.multi(ops, true);\n        } catch (InterruptedException e) {\n          throw e;\n        } catch (IllegalArgumentException e) {\n          SolrException.log(log, e);\n        }\n        leaderZkNodeParentVersion = null;\n      } else {\n        log.info(\"No version found for ephemeral leader parent node, won't remove previous leader registration.\");\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void cancelElection() throws InterruptedException, KeeperException {\n    super.cancelElection();\n    synchronized (lock) {\n      if (leaderZkNodeParentVersion != null) {\n        // no problem\n        // no problem\n        try {\n          // We need to be careful and make sure we *only* delete our own leader registration node.\n          // We do this by using a multi and ensuring the parent znode of the leader registration node\n          // matches the version we expect - there is a setData call that increments the parent's znode\n          // version whenever a leader registers.\n          log.debug(\"Removing leader registration node on cancel: {} {}\", leaderPath, leaderZkNodeParentVersion);\n          List<Op> ops = new ArrayList<>(2);\n          // Fails on Windows if you use nio Paths.get here\n          ops.add(Op.check(new Path(leaderPath).getParent().toString(), leaderZkNodeParentVersion));\n          ops.add(Op.delete(leaderPath, -1));\n          zkClient.multi(ops, true);\n        } catch (InterruptedException e) {\n          throw e;\n        } catch (IllegalArgumentException e) {\n          SolrException.log(log, e);\n        }\n        leaderZkNodeParentVersion = null;\n      } else {\n        log.info(\"No version found for ephemeral leader parent node, won't remove previous leader registration.\");\n      }\n    }\n  }\n\n","bugFix":["d12cb2880d9de40cdf8dfb8398beedbe238e1b3f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3adc4d119a7deba35b2721853853464857d9d0a9":["ba33781da68babcaa5828121b443d3eb5c9d8480"],"1b4e25416a41abd13d1febb3eebf589cbc71e5ae":["d12cb2880d9de40cdf8dfb8398beedbe238e1b3f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ba33781da68babcaa5828121b443d3eb5c9d8480":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1b4e25416a41abd13d1febb3eebf589cbc71e5ae"],"d12cb2880d9de40cdf8dfb8398beedbe238e1b3f":["3adc4d119a7deba35b2721853853464857d9d0a9"]},"commit2Childs":{"3adc4d119a7deba35b2721853853464857d9d0a9":["d12cb2880d9de40cdf8dfb8398beedbe238e1b3f"],"1b4e25416a41abd13d1febb3eebf589cbc71e5ae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ba33781da68babcaa5828121b443d3eb5c9d8480"],"ba33781da68babcaa5828121b443d3eb5c9d8480":["3adc4d119a7deba35b2721853853464857d9d0a9"],"d12cb2880d9de40cdf8dfb8398beedbe238e1b3f":["1b4e25416a41abd13d1febb3eebf589cbc71e5ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}