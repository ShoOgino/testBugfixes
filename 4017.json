{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","commits":[{"id":"e2fe60a17a7a0cfd101b1169acf089221bc6c166","date":1412767493,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoWriter#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeHeader(output, Lucene50SegmentInfoFormat.CODEC_NAME, Lucene50SegmentInfoFormat.VERSION_CURRENT);\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      byte[] id = si.getId();\n      if (id.length != StringHelper.ID_LENGTH) {\n        throw new IllegalArgumentException(\"invalid id, got=\" + StringHelper.idToString(id));\n      }\n      output.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","sourceOld":"  /** Save a single segment's info. */\n  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeHeader(output, Lucene50SegmentInfoFormat.CODEC_NAME, Lucene50SegmentInfoFormat.VERSION_CURRENT);\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      byte[] id = si.getId();\n      if (id.length != StringHelper.ID_LENGTH) {\n        throw new IllegalArgumentException(\"invalid id, got=\" + StringHelper.idToString(id));\n      }\n      output.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoWriter#write(Directory,SegmentInfo,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeHeader(output, Lucene50SegmentInfoFormat.CODEC_NAME, Lucene50SegmentInfoFormat.VERSION_CURRENT);\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      byte[] id = si.getId();\n      if (id.length != StringHelper.ID_LENGTH) {\n        throw new IllegalArgumentException(\"invalid id, got=\" + StringHelper.idToString(id));\n      }\n      output.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","sourceOld":"  /** Save a single segment's info. */\n  @Override\n  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeHeader(output, Lucene50SegmentInfoFormat.CODEC_NAME, Lucene50SegmentInfoFormat.VERSION_CURRENT);\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeString(version.toString());\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      byte[] id = si.getId();\n      if (id.length != StringHelper.ID_LENGTH) {\n        throw new IllegalArgumentException(\"invalid id, got=\" + StringHelper.idToString(id));\n      }\n      output.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6a824e51ae7d416179b0164bf6693668d68abc0","date":1413927602,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // NOTE: we encode ID in the segment header, for format consistency with all other per-segment files\n      CodecUtil.writeSegmentHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeHeader(output, Lucene50SegmentInfoFormat.CODEC_NAME, Lucene50SegmentInfoFormat.VERSION_CURRENT);\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      byte[] id = si.getId();\n      if (id.length != StringHelper.ID_LENGTH) {\n        throw new IllegalArgumentException(\"invalid id, got=\" + StringHelper.idToString(id));\n      }\n      output.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // NOTE: we encode ID in the segment header, for format consistency with all other per-segment files\n      CodecUtil.writeSegmentHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeHeader(output, Lucene50SegmentInfoFormat.CODEC_NAME, Lucene50SegmentInfoFormat.VERSION_CURRENT);\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      byte[] id = si.getId();\n      if (id.length != StringHelper.ID_LENGTH) {\n        throw new IllegalArgumentException(\"invalid id, got=\" + StringHelper.idToString(id));\n      }\n      output.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac","date":1417363109,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    boolean success = false;\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      CodecUtil.writeFooter(output);\n      success = true;\n    } finally {\n      if (!success) {\n        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?\n        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8521d944f9dfb45692ec28235dbf116d47ef69ba","date":1417535150,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      output.writeStringStringMap(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79700663e164dece87bed4adfd3e28bab6cb1385","date":1425241849,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      output.writeStringStringMap(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"299a2348fa24151d150182211b6208a38e5e3450","date":1425304608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      output.writeStringStringMap(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.getDocCount());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeStringStringMap(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeStringSet(files);\n      output.writeStringStringMap(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f8973f28b29873ff0d7a016e562c9036ae649a9","date":1428098193,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a3e0383956f06bd282a3e3aa2b353326e159802","date":1436383320,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    si.addFile(fileName);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    // nocommit indexSort\n    if (si.getIndexSort() != null) {\n      throw new IllegalArgumentException(\"teach me to write indexSort\");\n    }\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8","date":1462567286,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene50/Lucene50RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    // nocommit indexSort\n    if (si.getIndexSort() != null) {\n      throw new IllegalArgumentException(\"teach me to write indexSort\");\n    }\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n    // nocommit indexSort\n    if (si.getIndexSort() != null) {\n      throw new IllegalArgumentException(\"teach me to write indexSort\");\n    }\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene50/Lucene50RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    assert si.getIndexSort() == null;\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene50/Lucene50RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    assert si.getIndexSort() == null;\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene50/Lucene50RWSegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    assert si.getIndexSort() == null;\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene50SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene50SegmentInfoFormat.CODEC_NAME, \n                                   Lucene50SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e2fe60a17a7a0cfd101b1169acf089221bc6c166":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e2fe60a17a7a0cfd101b1169acf089221bc6c166"],"a6a824e51ae7d416179b0164bf6693668d68abc0":["55980207f1977bd1463465de1659b821347e2fa8"],"b0267c69e2456a3477a1ad785723f2135da3117e":["79700663e164dece87bed4adfd3e28bab6cb1385"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["a6a824e51ae7d416179b0164bf6693668d68abc0"],"0ad30c6a479e764150a3316e57263319775f1df2":["3a3e0383956f06bd282a3e3aa2b353326e159802","3d33e731a93d4b57e662ff094f64f94a745422d4"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["b0267c69e2456a3477a1ad785723f2135da3117e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3a3e0383956f06bd282a3e3aa2b353326e159802","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["3a3e0383956f06bd282a3e3aa2b353326e159802","0ad30c6a479e764150a3316e57263319775f1df2"],"8521d944f9dfb45692ec28235dbf116d47ef69ba":["474b77fc1ee62c3fc1c73ceb19cc975cb03667ac"],"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["8521d944f9dfb45692ec28235dbf116d47ef69ba","b0267c69e2456a3477a1ad785723f2135da3117e"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["3a3e0383956f06bd282a3e3aa2b353326e159802"],"3a3e0383956f06bd282a3e3aa2b353326e159802":["3f8973f28b29873ff0d7a016e562c9036ae649a9"],"b06445ae1731e049327712db0454e5643ca9b7fe":["299a2348fa24151d150182211b6208a38e5e3450","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"79700663e164dece87bed4adfd3e28bab6cb1385":["8521d944f9dfb45692ec28235dbf116d47ef69ba"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["e2fe60a17a7a0cfd101b1169acf089221bc6c166","3384e6013a93e4d11b7d75388693f8d0388602bf"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["3a3e0383956f06bd282a3e3aa2b353326e159802","fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"299a2348fa24151d150182211b6208a38e5e3450":["8521d944f9dfb45692ec28235dbf116d47ef69ba","79700663e164dece87bed4adfd3e28bab6cb1385"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"commit2Childs":{"e2fe60a17a7a0cfd101b1169acf089221bc6c166":["55980207f1977bd1463465de1659b821347e2fa8","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"55980207f1977bd1463465de1659b821347e2fa8":["a6a824e51ae7d416179b0164bf6693668d68abc0"],"a6a824e51ae7d416179b0164bf6693668d68abc0":["3384e6013a93e4d11b7d75388693f8d0388602bf"],"b0267c69e2456a3477a1ad785723f2135da3117e":["3f8973f28b29873ff0d7a016e562c9036ae649a9","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["3a3e0383956f06bd282a3e3aa2b353326e159802"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8521d944f9dfb45692ec28235dbf116d47ef69ba":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","79700663e164dece87bed4adfd3e28bab6cb1385","299a2348fa24151d150182211b6208a38e5e3450"],"474b77fc1ee62c3fc1c73ceb19cc975cb03667ac":["8521d944f9dfb45692ec28235dbf116d47ef69ba"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"3a3e0383956f06bd282a3e3aa2b353326e159802":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e2fe60a17a7a0cfd101b1169acf089221bc6c166","55980207f1977bd1463465de1659b821347e2fa8"],"79700663e164dece87bed4adfd3e28bab6cb1385":["b0267c69e2456a3477a1ad785723f2135da3117e","299a2348fa24151d150182211b6208a38e5e3450"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["474b77fc1ee62c3fc1c73ceb19cc975cb03667ac"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"299a2348fa24151d150182211b6208a38e5e3450":["b06445ae1731e049327712db0454e5643ca9b7fe"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}