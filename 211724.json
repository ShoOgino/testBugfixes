{"path":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","commits":[{"id":"a760e2135dfe20a04dea360873d4de1c6a0280bb","date":1430762855,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCUtils.clearMDC();\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (cores.isZooKeeperAware()) {\n      MDC.put(NODE_NAME_PROP, cores.getZkController().getNodeName());\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      setContext();\n      \n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        case FORWARD:\n          return FORWARD;\n        case PASSTHROUGH:\n          return PASSTHROUGH;\n        case RETRY:\n          return RETRY;\n        case RETURN:\n          return RETURN;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n    // Otherwise let the webapp handle the request\n\n    return Action.PASSTHROUGH;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3570e776df3671c1bce4f54b07bf03ca5a2c23de"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c20741794ad4aa48bd6159a3acda5b436fd5d165","date":1430940607,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCUtils.clearMDC();\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (cores.isZooKeeperAware()) {\n      MDC.put(NODE_NAME_PROP, cores.getZkController().getNodeName());\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      setContext();\n      \n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCUtils.clearMDC();\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (cores.isZooKeeperAware()) {\n      MDC.put(NODE_NAME_PROP, cores.getZkController().getNodeName());\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      setContext();\n      \n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        case FORWARD:\n          return FORWARD;\n        case PASSTHROUGH:\n          return PASSTHROUGH;\n        case RETRY:\n          return RETRY;\n        case RETURN:\n          return RETURN;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n    // Otherwise let the webapp handle the request\n\n    return Action.PASSTHROUGH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00e1c8e1340d9e31d2c6bee5f72d9040ce569049","date":1431584404,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCUtils.clearMDC();\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (cores.isZooKeeperAware()) {\n      MDC.put(NODE_NAME_PROP, cores.getZkController().getNodeName());\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      // TODO: There should be a better way to ignore the static files.\n      if (cores.getAuthorizationPlugin() != null &&\n          !(req.getRequestURI().endsWith(\".html\") \n              || req.getRequestURI().endsWith(\".png\")\n              || req.getRequestURI().endsWith(\".ico\")\n              || req.getRequestURI().endsWith(\".css\")\n          )) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCUtils.clearMDC();\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (cores.isZooKeeperAware()) {\n      MDC.put(NODE_NAME_PROP, cores.getZkController().getNodeName());\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      setContext();\n      \n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["cac08ebda61657f2bd130dc94173456fef381a30","587eef0a5c30792658ddb8ea8c5281f2ce417fa1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cac08ebda61657f2bd130dc94173456fef381a30","date":1431669054,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCUtils.clearMDC();\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (cores.isZooKeeperAware()) {\n      MDC.put(NODE_NAME_PROP, cores.getZkController().getNodeName());\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCUtils.clearMDC();\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (cores.isZooKeeperAware()) {\n      MDC.put(NODE_NAME_PROP, cores.getZkController().getNodeName());\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      // TODO: There should be a better way to ignore the static files.\n      if (cores.getAuthorizationPlugin() != null &&\n          !(req.getRequestURI().endsWith(\".html\") \n              || req.getRequestURI().endsWith(\".png\")\n              || req.getRequestURI().endsWith(\".ico\")\n              || req.getRequestURI().endsWith(\".css\")\n          )) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","bugFix":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCUtils.clearMDC();\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (cores.isZooKeeperAware()) {\n      MDC.put(NODE_NAME_PROP, cores.getZkController().getNodeName());\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3a34dae868734612eb6329aa0ef754f30bd2036","date":1438783154,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["587eef0a5c30792658ddb8ea8c5281f2ce417fa1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bdcb86c29922edae9a14852e636303bc52df094","date":1438887454,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["587eef0a5c30792658ddb8ea8c5281f2ce417fa1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e76c7a05748b87468b5ccbcf325482013e002a3d","date":1448547807,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.info(context.toString());\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["587eef0a5c30792658ddb8ea8c5281f2ce417fa1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b9e52dc3261e61fb422a343ba4e6df9a9fab88e6","date":1448994587,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["587eef0a5c30792658ddb8ea8c5281f2ce417fa1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            SolrDispatchFilter.log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fcf710a8fcd590cf55c855d422c7a10fce3e6117","date":1485842253,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a10d4a0423ccdc7c84efa89beeef9a56c01d0e1","date":1546418643,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq,  new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["16a1bbda4a49d74d4c9df2eba45b180565fffeab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"16a1bbda4a49d74d4c9df2eba45b180565fffeab","date":1546677088,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq,  new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":["5a10d4a0423ccdc7c84efa89beeef9a56c01d0e1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12ddd922ea96c1d0ea68a68506b6984a246cfb22","date":1554385731,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n          if (shouldAudit(EventType.REJECTED)) {\n            cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, req, context));\n          }\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          if (shouldAudit(EventType.UNAUTHORIZED)) {\n            cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.UNAUTHORIZED, req, context));\n          }\n          return RETURN;\n        }\n        if (shouldAudit(EventType.AUTHORIZED)) {\n          cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHORIZED, req, context));\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          return RETURN;\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["587eef0a5c30792658ddb8ea8c5281f2ce417fa1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbaf96cfda5422c42955ce34344f0e01839894ea","date":1559675051,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n          if (shouldAudit(EventType.REJECTED)) {\n            cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, req, context));\n          }\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          if (shouldAudit(EventType.UNAUTHORIZED)) {\n            cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.UNAUTHORIZED, req, context));\n          }\n          return RETURN;\n        }\n        if (shouldAudit(EventType.AUTHORIZED)) {\n          cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHORIZED, req, context));\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n          if (shouldAudit(EventType.REJECTED)) {\n            cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, req, context));\n          }\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          if (shouldAudit(EventType.UNAUTHORIZED)) {\n            cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.UNAUTHORIZED, req, context));\n          }\n          return RETURN;\n        }\n        if (shouldAudit(EventType.AUTHORIZED)) {\n          cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHORIZED, req, context));\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"587eef0a5c30792658ddb8ea8c5281f2ce417fa1","date":1563182021,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n      /* Authorize the request if\n       1. Authorization is enabled, and\n       2. The requested resource is not a known static file\n        */\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()) {\n        AuthorizationContext context = getAuthCtx();\n        log.debug(\"AuthorizationContext : {}\", context);\n        AuthorizationResponse authResponse = cores.getAuthorizationPlugin().authorize(context);\n        if (authResponse.statusCode == AuthorizationResponse.PROMPT.statusCode) {\n          Map<String, String> headers = (Map) getReq().getAttribute(AuthenticationPlugin.class.getName());\n          if (headers != null) {\n            for (Map.Entry<String, String> e : headers.entrySet()) response.setHeader(e.getKey(), e.getValue());\n          }\n          log.debug(\"USER_REQUIRED \"+req.getHeader(\"Authorization\")+\" \"+ req.getUserPrincipal());\n          if (shouldAudit(EventType.REJECTED)) {\n            cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.REJECTED, req, context));\n          }\n        }\n        if (!(authResponse.statusCode == HttpStatus.SC_ACCEPTED) && !(authResponse.statusCode == HttpStatus.SC_OK)) {\n          log.info(\"USER_REQUIRED auth header {} context : {} \", req.getHeader(\"Authorization\"), context);\n          sendError(authResponse.statusCode,\n              \"Unauthorized request, Response code: \" + authResponse.statusCode);\n          if (shouldAudit(EventType.UNAUTHORIZED)) {\n            cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.UNAUTHORIZED, req, context));\n          }\n          return RETURN;\n        }\n        if (shouldAudit(EventType.AUTHORIZED)) {\n          cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.AUTHORIZED, req, context));\n        }\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":["b9e52dc3261e61fb422a343ba4e6df9a9fab88e6","b3a34dae868734612eb6329aa0ef754f30bd2036","12ddd922ea96c1d0ea68a68506b6984a246cfb22","6bdcb86c29922edae9a14852e636303bc52df094","00e1c8e1340d9e31d2c6bee5f72d9040ce569049","e76c7a05748b87468b5ccbcf325482013e002a3d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba52b298388110adda4c077defc2ab02b2b3fcc7","date":1563183607,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse(), action));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp, action));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse()));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse(), action));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp, action));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse(), action));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp, action));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    } finally {\n      MDCLoggingContext.clear();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4","date":1592286410,"type":3,"author":"Nazerke Seidan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse(), action));\n          mustClearSolrRequestInfo = true;\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp, action));\n            mustClearSolrRequestInfo = true;\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse(), action));\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp, action));\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3570e776df3671c1bce4f54b07bf03ca5a2c23de","date":1593033351,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#call().mjava","sourceNew":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse(), action));\n          mustClearSolrRequestInfo = true;\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp, action));\n            mustClearSolrRequestInfo = true;\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * This method processes the request.\n   */\n  public Action call() throws IOException {\n    MDCLoggingContext.reset();\n    Span activeSpan = GlobalTracer.getTracer().activeSpan();\n    if (activeSpan != null) {\n      MDCLoggingContext.setTracerId(activeSpan.context().toTraceId());\n    }\n\n    MDCLoggingContext.setNode(cores);\n\n    if (cores == null) {\n      sendError(503, \"Server is shutting down or failed to initialize\");\n      return RETURN;\n    }\n\n    if (solrDispatchFilter.abortErrorMessage != null) {\n      sendError(500, solrDispatchFilter.abortErrorMessage);\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, getReq()));\n      }\n      return RETURN;\n    }\n\n    try {\n      init();\n\n      // Perform authorization here, if:\n      //    (a) Authorization is enabled, and\n      //    (b) The requested resource is not a known static file\n      //    (c) And this request should be handled by this node (see NOTE below)\n      // NOTE: If the query is to be handled by another node, then let that node do the authorization.\n      // In case of authentication using BasicAuthPlugin, for example, the internode request\n      // is secured using PKI authentication and the internode request here will contain the\n      // original user principal as a payload/header, using which the receiving node should be\n      // able to perform the authorization.\n      if (cores.getAuthorizationPlugin() != null && shouldAuthorize()\n          && !(action == REMOTEQUERY || action == FORWARD)) {\n        Action authorizationAction = authorize();\n        if (authorizationAction != null) return authorizationAction;\n      }\n\n      HttpServletResponse resp = response;\n      switch (action) {\n        case ADMIN:\n          handleAdminRequest();\n          return RETURN;\n        case REMOTEQUERY:\n          SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, new SolrQueryResponse(), action));\n          mustClearSolrRequestInfo = true;\n          remoteQuery(coreUrl + path, resp);\n          return RETURN;\n        case PROCESS:\n          final Method reqMethod = Method.getMethod(req.getMethod());\n          HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n          // unless we have been explicitly told not to, do cache validation\n          // if we fail cache validation, execute the query\n          if (config.getHttpCachingConfig().isNever304() ||\n              !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n            SolrQueryResponse solrRsp = new SolrQueryResponse();\n              /* even for HEAD requests, we need to execute the handler to\n               * ensure we don't get an error (and to make sure the correct\n               * QueryResponseWriter is selected and we get the correct\n               * Content-Type)\n               */\n            SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp, action));\n            mustClearSolrRequestInfo = true;\n            execute(solrRsp);\n            if (shouldAudit()) {\n              EventType eventType = solrRsp.getException() == null ? EventType.COMPLETED : EventType.ERROR;\n              if (shouldAudit(eventType)) {\n                cores.getAuditLoggerPlugin().doAudit(\n                    new AuditEvent(eventType, req, getAuthCtx(), solrReq.getRequestTimer().getTime(), solrRsp.getException()));\n              }\n            }\n            HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n            Iterator<Map.Entry<String, String>> headers = solrRsp.httpHeaders();\n            while (headers.hasNext()) {\n              Map.Entry<String, String> entry = headers.next();\n              resp.addHeader(entry.getKey(), entry.getValue());\n            }\n            QueryResponseWriter responseWriter = getResponseWriter();\n            if (invalidStates != null) solrReq.getContext().put(CloudSolrClient.STATE_VERSION, invalidStates);\n            writeResponse(solrRsp, responseWriter, reqMethod);\n          }\n          return RETURN;\n        default: return action;\n      }\n    } catch (Throwable ex) {\n      if (shouldAudit(EventType.ERROR)) {\n        cores.getAuditLoggerPlugin().doAudit(new AuditEvent(EventType.ERROR, ex, req));\n      }\n      sendError(ex);\n      // walk the the entire cause chain to search for an Error\n      Throwable t = ex;\n      while (t != null) {\n        if (t instanceof Error) {\n          if (t != ex) {\n            log.error(\"An Error was wrapped in another exception - please report complete stacktrace on SOLR-6161\", ex);\n          }\n          throw (Error) t;\n        }\n        t = t.getCause();\n      }\n      return RETURN;\n    }\n\n  }\n\n","bugFix":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6bdcb86c29922edae9a14852e636303bc52df094":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"b9e52dc3261e61fb422a343ba4e6df9a9fab88e6":["e76c7a05748b87468b5ccbcf325482013e002a3d"],"3570e776df3671c1bce4f54b07bf03ca5a2c23de":["a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["16a1bbda4a49d74d4c9df2eba45b180565fffeab"],"cac08ebda61657f2bd130dc94173456fef381a30":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["9367dbf5b00d7764583d991c1888f4acc9c9991a","fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"ed5005b977107bba28c700351216f1595e7abe4f":["ba52b298388110adda4c077defc2ab02b2b3fcc7"],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"ba52b298388110adda4c077defc2ab02b2b3fcc7":["587eef0a5c30792658ddb8ea8c5281f2ce417fa1"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["b9e52dc3261e61fb422a343ba4e6df9a9fab88e6"],"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4":["ed5005b977107bba28c700351216f1595e7abe4f"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["cac08ebda61657f2bd130dc94173456fef381a30"],"16a1bbda4a49d74d4c9df2eba45b180565fffeab":["5a10d4a0423ccdc7c84efa89beeef9a56c01d0e1"],"e76c7a05748b87468b5ccbcf325482013e002a3d":["6bdcb86c29922edae9a14852e636303bc52df094"],"c20741794ad4aa48bd6159a3acda5b436fd5d165":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"cbaf96cfda5422c42955ce34344f0e01839894ea":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"587eef0a5c30792658ddb8ea8c5281f2ce417fa1":["cbaf96cfda5422c42955ce34344f0e01839894ea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a10d4a0423ccdc7c84efa89beeef9a56c01d0e1":["fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3570e776df3671c1bce4f54b07bf03ca5a2c23de"],"00e1c8e1340d9e31d2c6bee5f72d9040ce569049":["c20741794ad4aa48bd6159a3acda5b436fd5d165"]},"commit2Childs":{"6bdcb86c29922edae9a14852e636303bc52df094":["e76c7a05748b87468b5ccbcf325482013e002a3d"],"b9e52dc3261e61fb422a343ba4e6df9a9fab88e6":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"3570e776df3671c1bce4f54b07bf03ca5a2c23de":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["cbaf96cfda5422c42955ce34344f0e01839894ea"],"cac08ebda61657f2bd130dc94173456fef381a30":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","5a10d4a0423ccdc7c84efa89beeef9a56c01d0e1"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"ed5005b977107bba28c700351216f1595e7abe4f":["a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4"],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["c20741794ad4aa48bd6159a3acda5b436fd5d165"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["6bdcb86c29922edae9a14852e636303bc52df094"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"ba52b298388110adda4c077defc2ab02b2b3fcc7":["ed5005b977107bba28c700351216f1595e7abe4f"],"a32e902eb5b2408fefa7ca7a8579e22f4ba6f2b4":["3570e776df3671c1bce4f54b07bf03ca5a2c23de"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"e76c7a05748b87468b5ccbcf325482013e002a3d":["b9e52dc3261e61fb422a343ba4e6df9a9fab88e6"],"16a1bbda4a49d74d4c9df2eba45b180565fffeab":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"c20741794ad4aa48bd6159a3acda5b436fd5d165":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"cbaf96cfda5422c42955ce34344f0e01839894ea":["587eef0a5c30792658ddb8ea8c5281f2ce417fa1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"587eef0a5c30792658ddb8ea8c5281f2ce417fa1":["ba52b298388110adda4c077defc2ab02b2b3fcc7"],"5a10d4a0423ccdc7c84efa89beeef9a56c01d0e1":["16a1bbda4a49d74d4c9df2eba45b180565fffeab"],"00e1c8e1340d9e31d2c6bee5f72d9040ce569049":["cac08ebda61657f2bd130dc94173456fef381a30"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}