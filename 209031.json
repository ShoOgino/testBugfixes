{"path":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","commits":[{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"/dev/null","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", Field.Index.NOT_ANALYZED);\n      doc.add(idField);\n      \n      final int NUM_IDS = (int) (1000*RANDOM_MULTIPLIER*(1.0+random.nextDouble()));\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.optimize();\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = (int) (1000*RANDOM_MULTIPLIER*(1.0+random.nextDouble()));\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.optimize();\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", Field.Index.NOT_ANALYZED);\n      doc.add(idField);\n      \n      final int NUM_IDS = (int) (1000*RANDOM_MULTIPLIER*(1.0+random.nextDouble()));\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.optimize();\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = (int) (1000*RANDOM_MULTIPLIER*(1.0+random.nextDouble()));\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = (int) (1000*RANDOM_MULTIPLIER*(1.0+random.nextDouble()));\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.optimize();\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = (int) (1000*RANDOM_MULTIPLIER*(1.0+random.nextDouble()));\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = (int) (1000*RANDOM_MULTIPLIER*(1.0+random.nextDouble()));\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator();\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8be580b58bcc650d428f3f22de81cadcf51d650a","date":1325279655,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = (int) (1000*RANDOM_MULTIPLIER*(1.0+random.nextDouble()));\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testPrimaryKeys().mjava","sourceNew":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  public void testPrimaryKeys() throws Exception {\n    Directory dir = newDirectory();\n\n    for(int cycle=0;cycle<2;cycle++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: cycle=\" + cycle);\n      }\n      RandomIndexWriter w = new RandomIndexWriter(random, dir,\n                                                  newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE));\n      Document doc = new Document();\n      Field idField = newField(\"id\", \"\", StringField.TYPE_UNSTORED);\n      doc.add(idField);\n      \n      final int NUM_IDS = atLeast(200);\n      //final int NUM_IDS = (int) (377 * (1.0+random.nextDouble()));\n      if (VERBOSE) {\n        System.out.println(\"TEST: NUM_IDS=\" + NUM_IDS);\n      }\n      final Set<String> allIDs = new HashSet<String>();\n      for(int id=0;id<NUM_IDS;id++) {\n        String idString;\n        if (cycle == 0) {\n          // PKs are assigned sequentially\n          idString = String.format(\"%07d\", id);\n        } else {\n          while(true) {\n            final String s = Long.toString(random.nextLong());\n            if (!allIDs.contains(s)) {\n              idString = s;\n              break;\n            }\n          }\n        }\n        allIDs.add(idString);\n        idField.setValue(idString);\n        w.addDocument(doc);\n      }\n\n      //w.forceMerge(1);\n\n      // turn writer into reader:\n      final IndexReader r = w.getReader();\n      final IndexSearcher s = new IndexSearcher(r);\n      w.close();\n\n      final List<String> allIDsList = new ArrayList<String>(allIDs);\n      final List<String> sortedAllIDsList = new ArrayList<String>(allIDsList);\n      Collections.sort(sortedAllIDsList);\n\n      // Sprinkle in some non-existent PKs:\n      Set<String> outOfBounds = new HashSet<String>();\n      for(int idx=0;idx<NUM_IDS/10;idx++) {\n        String idString;\n        if (cycle == 0) {\n          idString = String.format(\"%07d\", (NUM_IDS + idx));\n        } else {\n          while(true) {\n            idString = Long.toString(random.nextLong());\n            if (!allIDs.contains(idString)) {\n              break;\n            }\n          }\n        }\n        outOfBounds.add(idString);\n        allIDsList.add(idString);\n      }\n\n      // Verify w/ TermQuery\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id = allIDsList.get(random.nextInt(allIDsList.size()));\n        final boolean exists = !outOfBounds.contains(id);\n        if (VERBOSE) {\n          System.out.println(\"TEST: TermQuery \" + (exists ? \"\" : \"non-exist \") + \" id=\" + id);\n        }\n        assertEquals((exists ? \"\" : \"non-exist \") + \"id=\" + id, exists ? 1 : 0, s.search(new TermQuery(new Term(\"id\", id)), 1).totalHits);\n      }\n\n      // Verify w/ MultiTermsEnum\n      final TermsEnum termsEnum = MultiFields.getTerms(r, \"id\").iterator(null);\n      for(int iter=0;iter<2*NUM_IDS;iter++) {\n        final String id;\n        final String nextID;\n        final boolean exists;\n\n        if (random.nextBoolean()) {\n          id = allIDsList.get(random.nextInt(allIDsList.size()));\n          exists = !outOfBounds.contains(id);\n          nextID = null;\n          if (VERBOSE) {\n            System.out.println(\"TEST: exactOnly \" + (exists ? \"\" : \"non-exist \") + \"id=\" + id);\n          }\n        } else {\n          // Pick ID between two IDs:\n          exists = false;\n          final int idv = random.nextInt(NUM_IDS-1);\n          if (cycle == 0) {\n            id = String.format(\"%07da\", idv);\n            nextID = String.format(\"%07d\", idv+1);\n          } else {\n            id = sortedAllIDsList.get(idv) + \"a\";\n            nextID = sortedAllIDsList.get(idv+1);\n          }\n          if (VERBOSE) {\n            System.out.println(\"TEST: not exactOnly id=\" + id + \" nextID=\" + nextID);\n          }\n        }\n\n        final boolean useCache = random.nextBoolean();\n        if (VERBOSE) {\n          System.out.println(\"  useCache=\" + useCache);\n        }\n\n        final TermsEnum.SeekStatus status;\n        if (nextID == null) {\n          if (termsEnum.seekExact(new BytesRef(id), useCache)) {\n            status = TermsEnum.SeekStatus.FOUND;\n          } else {\n            status = TermsEnum.SeekStatus.NOT_FOUND;\n          }\n        } else {\n          status = termsEnum.seekCeil(new BytesRef(id), useCache);\n        }\n\n        if (nextID != null) {\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, status);\n          assertEquals(\"expected=\" + nextID + \" actual=\" + termsEnum.term().utf8ToString(), new BytesRef(nextID), termsEnum.term());\n        } else if (!exists) {\n          assertTrue(status == TermsEnum.SeekStatus.NOT_FOUND ||\n                     status == TermsEnum.SeekStatus.END);\n        } else {\n          assertEquals(TermsEnum.SeekStatus.FOUND, status);\n        }\n      }\n\n      r.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["8be580b58bcc650d428f3f22de81cadcf51d650a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"8be580b58bcc650d428f3f22de81cadcf51d650a":["3cc749c053615f5871f3b95715fe292f34e70a53"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"3cc749c053615f5871f3b95715fe292f34e70a53":["8be580b58bcc650d428f3f22de81cadcf51d650a"],"8be580b58bcc650d428f3f22de81cadcf51d650a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["3cc749c053615f5871f3b95715fe292f34e70a53"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}