{"path":"src/test-deprecated/org/apache/lucene/search/TestMultiSearcher#testEmptyIndex().mjava","commits":[{"id":"5b5461affe637a07375542c763a4805300802be8","date":1102270918,"type":0,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/test-deprecated/org/apache/lucene/search/TestMultiSearcher#testEmptyIndex().mjava","pathOld":"/dev/null","sourceNew":"    public void testEmptyIndex()\n        throws Exception\n    {\n        // creating two directories for indices\n        Directory indexStoreA = new RAMDirectory();\n        Directory indexStoreB = new RAMDirectory();\n\n        // creating a document to store\n        Document lDoc = new Document();\n        lDoc.add(Field.Text(\"fulltext\", \"Once upon a time.....\"));\n        lDoc.add(Field.Keyword(\"id\", \"doc1\"));\n        lDoc.add(Field.Keyword(\"handle\", \"1\"));\n\n        // creating a document to store\n        Document lDoc2 = new Document();\n        lDoc2.add(Field.Text(\"fulltext\", \"in a galaxy far far away.....\"));\n        lDoc2.add(Field.Keyword(\"id\", \"doc2\"));\n        lDoc2.add(Field.Keyword(\"handle\", \"1\"));\n\n        // creating a document to store\n        Document lDoc3 = new Document();\n        lDoc3.add(Field.Text(\"fulltext\", \"a bizarre bug manifested itself....\"));\n        lDoc3.add(Field.Keyword(\"id\", \"doc3\"));\n        lDoc3.add(Field.Keyword(\"handle\", \"1\"));\n\n        // creating an index writer for the first index\n        IndexWriter writerA = new IndexWriter(indexStoreA, new StandardAnalyzer(), true);\n        // creating an index writer for the second index, but writing nothing\n        IndexWriter writerB = new IndexWriter(indexStoreB, new StandardAnalyzer(), true);\n\n        //--------------------------------------------------------------------\n        // scenario 1\n        //--------------------------------------------------------------------\n\n        // writing the documents to the first index\n        writerA.addDocument(lDoc);\n        writerA.addDocument(lDoc2);\n        writerA.addDocument(lDoc3);\n        writerA.optimize();\n        writerA.close();\n\n        // closing the second index\n        writerB.close();\n\n        // creating the query\n        Query query = QueryParser.parse(\"handle:1\", \"fulltext\", new StandardAnalyzer());\n\n        // building the searchables\n        Searcher[] searchers = new Searcher[2];\n        // VITAL STEP:adding the searcher for the empty index first, before the searcher for the populated index\n        searchers[0] = new IndexSearcher(indexStoreB);\n        searchers[1] = new IndexSearcher(indexStoreA);\n        // creating the multiSearcher\n        Searcher mSearcher = getMultiSearcherInstance(searchers);\n        // performing the search\n        Hits hits = mSearcher.search(query);\n\n        assertEquals(3, hits.length());\n\n        try {\n            // iterating over the hit documents\n            for (int i = 0; i < hits.length(); i++) {\n                Document d = hits.doc(i);\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            fail(\"ArrayIndexOutOfBoundsException thrown: \" + e.getMessage());\n            e.printStackTrace();\n        } finally{\n            mSearcher.close();\n        }\n\n\n        //--------------------------------------------------------------------\n        // scenario 2\n        //--------------------------------------------------------------------\n\n        // adding one document to the empty index\n        writerB = new IndexWriter(indexStoreB, new StandardAnalyzer(), false);\n        writerB.addDocument(lDoc);\n        writerB.optimize();\n        writerB.close();\n\n        // building the searchables\n        Searcher[] searchers2 = new Searcher[2];\n        // VITAL STEP:adding the searcher for the empty index first, before the searcher for the populated index\n        searchers2[0] = new IndexSearcher(indexStoreB);\n        searchers2[1] = new IndexSearcher(indexStoreA);\n        // creating the mulitSearcher\n        Searcher mSearcher2 = getMultiSearcherInstance(searchers2);\n        // performing the same search\n        Hits hits2 = mSearcher2.search(query);\n\n        assertEquals(4, hits2.length());\n\n        try {\n            // iterating over the hit documents\n            for (int i = 0; i < hits2.length(); i++) {\n                // no exception should happen at this point\n                Document d = hits2.doc(i);\n            }\n        }\n        catch (Exception e)\n        {\n            fail(\"Exception thrown: \" + e.getMessage());\n            e.printStackTrace();\n        } finally{\n            mSearcher2.close();\n        }\n\n        //--------------------------------------------------------------------\n        // scenario 3\n        //--------------------------------------------------------------------\n\n        // deleting the document just added, this will cause a different exception to take place\n        Term term = new Term(\"id\", \"doc1\");\n        IndexReader readerB = IndexReader.open(indexStoreB);\n        readerB.delete(term);\n        readerB.close();\n\n        // optimizing the index with the writer\n        writerB = new IndexWriter(indexStoreB, new StandardAnalyzer(), false);\n        writerB.optimize();\n        writerB.close();\n\n        // building the searchables\n        Searcher[] searchers3 = new Searcher[2];\n\n        searchers3[0] = new IndexSearcher(indexStoreB);\n        searchers3[1] = new IndexSearcher(indexStoreA);\n        // creating the mulitSearcher\n        Searcher mSearcher3 = getMultiSearcherInstance(searchers3);\n        // performing the same search\n        Hits hits3 = mSearcher3.search(query);\n\n        assertEquals(3, hits3.length());\n\n        try {\n            // iterating over the hit documents\n            for (int i = 0; i < hits3.length(); i++) {\n                Document d = hits3.doc(i);\n            }\n        }\n        catch (IOException e)\n        {\n            fail(\"IOException thrown: \" + e.getMessage());\n            e.printStackTrace();\n        } finally{\n            mSearcher3.close();\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69e98ffd83f56083b99e5443ca713cd5783a2ae","date":1142955392,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"src/test-deprecated/org/apache/lucene/search/TestMultiSearcher#testEmptyIndex().mjava","sourceNew":null,"sourceOld":"    public void testEmptyIndex()\n        throws Exception\n    {\n        // creating two directories for indices\n        Directory indexStoreA = new RAMDirectory();\n        Directory indexStoreB = new RAMDirectory();\n\n        // creating a document to store\n        Document lDoc = new Document();\n        lDoc.add(Field.Text(\"fulltext\", \"Once upon a time.....\"));\n        lDoc.add(Field.Keyword(\"id\", \"doc1\"));\n        lDoc.add(Field.Keyword(\"handle\", \"1\"));\n\n        // creating a document to store\n        Document lDoc2 = new Document();\n        lDoc2.add(Field.Text(\"fulltext\", \"in a galaxy far far away.....\"));\n        lDoc2.add(Field.Keyword(\"id\", \"doc2\"));\n        lDoc2.add(Field.Keyword(\"handle\", \"1\"));\n\n        // creating a document to store\n        Document lDoc3 = new Document();\n        lDoc3.add(Field.Text(\"fulltext\", \"a bizarre bug manifested itself....\"));\n        lDoc3.add(Field.Keyword(\"id\", \"doc3\"));\n        lDoc3.add(Field.Keyword(\"handle\", \"1\"));\n\n        // creating an index writer for the first index\n        IndexWriter writerA = new IndexWriter(indexStoreA, new StandardAnalyzer(), true);\n        // creating an index writer for the second index, but writing nothing\n        IndexWriter writerB = new IndexWriter(indexStoreB, new StandardAnalyzer(), true);\n\n        //--------------------------------------------------------------------\n        // scenario 1\n        //--------------------------------------------------------------------\n\n        // writing the documents to the first index\n        writerA.addDocument(lDoc);\n        writerA.addDocument(lDoc2);\n        writerA.addDocument(lDoc3);\n        writerA.optimize();\n        writerA.close();\n\n        // closing the second index\n        writerB.close();\n\n        // creating the query\n        Query query = QueryParser.parse(\"handle:1\", \"fulltext\", new StandardAnalyzer());\n\n        // building the searchables\n        Searcher[] searchers = new Searcher[2];\n        // VITAL STEP:adding the searcher for the empty index first, before the searcher for the populated index\n        searchers[0] = new IndexSearcher(indexStoreB);\n        searchers[1] = new IndexSearcher(indexStoreA);\n        // creating the multiSearcher\n        Searcher mSearcher = getMultiSearcherInstance(searchers);\n        // performing the search\n        Hits hits = mSearcher.search(query);\n\n        assertEquals(3, hits.length());\n\n        try {\n            // iterating over the hit documents\n            for (int i = 0; i < hits.length(); i++) {\n                Document d = hits.doc(i);\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            fail(\"ArrayIndexOutOfBoundsException thrown: \" + e.getMessage());\n            e.printStackTrace();\n        } finally{\n            mSearcher.close();\n        }\n\n\n        //--------------------------------------------------------------------\n        // scenario 2\n        //--------------------------------------------------------------------\n\n        // adding one document to the empty index\n        writerB = new IndexWriter(indexStoreB, new StandardAnalyzer(), false);\n        writerB.addDocument(lDoc);\n        writerB.optimize();\n        writerB.close();\n\n        // building the searchables\n        Searcher[] searchers2 = new Searcher[2];\n        // VITAL STEP:adding the searcher for the empty index first, before the searcher for the populated index\n        searchers2[0] = new IndexSearcher(indexStoreB);\n        searchers2[1] = new IndexSearcher(indexStoreA);\n        // creating the mulitSearcher\n        Searcher mSearcher2 = getMultiSearcherInstance(searchers2);\n        // performing the same search\n        Hits hits2 = mSearcher2.search(query);\n\n        assertEquals(4, hits2.length());\n\n        try {\n            // iterating over the hit documents\n            for (int i = 0; i < hits2.length(); i++) {\n                // no exception should happen at this point\n                Document d = hits2.doc(i);\n            }\n        }\n        catch (Exception e)\n        {\n            fail(\"Exception thrown: \" + e.getMessage());\n            e.printStackTrace();\n        } finally{\n            mSearcher2.close();\n        }\n\n        //--------------------------------------------------------------------\n        // scenario 3\n        //--------------------------------------------------------------------\n\n        // deleting the document just added, this will cause a different exception to take place\n        Term term = new Term(\"id\", \"doc1\");\n        IndexReader readerB = IndexReader.open(indexStoreB);\n        readerB.delete(term);\n        readerB.close();\n\n        // optimizing the index with the writer\n        writerB = new IndexWriter(indexStoreB, new StandardAnalyzer(), false);\n        writerB.optimize();\n        writerB.close();\n\n        // building the searchables\n        Searcher[] searchers3 = new Searcher[2];\n\n        searchers3[0] = new IndexSearcher(indexStoreB);\n        searchers3[1] = new IndexSearcher(indexStoreA);\n        // creating the mulitSearcher\n        Searcher mSearcher3 = getMultiSearcherInstance(searchers3);\n        // performing the same search\n        Hits hits3 = mSearcher3.search(query);\n\n        assertEquals(3, hits3.length());\n\n        try {\n            // iterating over the hit documents\n            for (int i = 0; i < hits3.length(); i++) {\n                Document d = hits3.doc(i);\n            }\n        }\n        catch (IOException e)\n        {\n            fail(\"IOException thrown: \" + e.getMessage());\n            e.printStackTrace();\n        } finally{\n            mSearcher3.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5b5461affe637a07375542c763a4805300802be8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["5b5461affe637a07375542c763a4805300802be8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"]},"commit2Childs":{"5b5461affe637a07375542c763a4805300802be8":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5b5461affe637a07375542c763a4805300802be8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}