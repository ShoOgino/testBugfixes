{"path":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.remove(\"distrib\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d66363068e87a246ce08fee4a42f30f126b92723","date":1329988051,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are tolerant, just continue\n              if(rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n                if( rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false) ) {\n                  NamedList<Object> sinfo = (NamedList<Object>) rb.rsp.getValues().get(ShardParams.SHARDS_INFO);\n                  if(sinfo==null) {\n                    sinfo = new SimpleOrderedMap<Object>();\n                    rb.rsp.getValues().add(ShardParams.SHARDS_INFO,sinfo);\n                  }\n  \n                  SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n                  Throwable t = srsp.getException();\n                  if(t instanceof SolrServerException) {\n                    t = ((SolrServerException)t).getCause();\n                  }\n                  nl.add(\"error\", t.toString() );\n                  \n                  StringWriter trace = new StringWriter();\n                  t.printStackTrace(new PrintWriter(trace));\n                  nl.add(\"trace\", trace.toString() );\n                  if(srsp.getSolrResponse()!=null){\n                    nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n                  }\n                  sinfo.add(srsp.getShard(), nl);\n                }\n              }\n              else { // If so, abort everything and rethrow\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6dd476b943b132ecfa6b3ffc72e439eb2d9e061","date":1330500722,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are tolerant, just continue\n              if(rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n                if( rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false) ) {\n                  NamedList<Object> sinfo = (NamedList<Object>) rb.rsp.getValues().get(ShardParams.SHARDS_INFO);\n                  if(sinfo==null) {\n                    sinfo = new SimpleOrderedMap<Object>();\n                    rb.rsp.getValues().add(ShardParams.SHARDS_INFO,sinfo);\n                  }\n  \n                  SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();\n                  Throwable t = srsp.getException();\n                  if(t instanceof SolrServerException) {\n                    t = ((SolrServerException)t).getCause();\n                  }\n                  nl.add(\"error\", t.toString() );\n                  \n                  StringWriter trace = new StringWriter();\n                  t.printStackTrace(new PrintWriter(trace));\n                  nl.add(\"trace\", trace.toString() );\n                  if(srsp.getSolrResponse()!=null){\n                    nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n                  }\n                  sinfo.add(srsp.getShard(), nl);\n                }\n              }\n              else { // If so, abort everything and rethrow\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  If so, abort everything and\n            // rethrow\n            if (srsp.getException() != null) {\n              shardHandler1.cancelAll();\n              if (srsp.getException() instanceof SolrException) {\n                throw (SolrException)srsp.getException();\n              } else {\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n            c.finishStage(rb);\n         }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bea3922196318026c4274f2013416acb60c691e","date":1336496433,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = req.getParams().get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception, ParseException, InstantiationException, IllegalAccessException\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a5c97e98e8e65bb8f85fe1a1a6418dafc568b43","date":1386062370,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"167c9d3137acf706f53c875de69f3165df85fd3b","date":1391327271,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f5084509b7789719f8c37e7d8c6116e2b61d538","date":1392400041,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(\"distrib\", \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<ShardRequest>();\n      }\n      rb.finished = new ArrayList<ShardRequest>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<ShardResponse>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0d0eda576bd1392f929c375143ff45503e89192","date":1394979067,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }      \n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }\n\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e","date":1411674127,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Request took too long during query expansion. Terminating request.\");\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }      \n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da951a24a6a87d5ba7e1820f8c28a1e2beea76c1","date":1411744836,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Request took too long during query expansion. Terminating request.\");\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      // The semantics of debugging vs not debugging are different enough that\n      // it makes sense to have two control loops\n      if(!rb.isDebug()) {\n        // Process\n        for( SearchComponent c : components ) {\n          c.process(rb);\n        }\n      }\n      else {\n        // Process\n        RTimer subt = timer.sub( \"process\" );\n        for( SearchComponent c : components ) {\n          rb.setTimer( subt.sub( c.getName() ) );\n          c.process(rb);\n          rb.getTimer().stop();\n        }\n        subt.stop();\n        timer.stop();\n\n        // add the timing info\n        if (rb.isDebugTimings()) {\n          rb.addDebugInfo(\"timing\", timer.asNamedList() );\n        }\n      }      \n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f001da93ec624cbfbf3655c529836b5b1ec1aa46","date":1412885266,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Request took too long during query expansion. Terminating request.\");\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Request took too long during query expansion. Terminating request.\");\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"944836102ccff275d4e5382638bc2ec1257ff8bc","date":1413785408,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a94e45463a0089149b0d148ae5369140e7f54b8c","date":1419231934,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c","date":1423863597,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt == null) {\n                params.remove(CommonParams.QT);\n              } else {\n                params.set(CommonParams.QT, shardQt);\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":["18da05e3b71bc8fa9a63493f568c3a3cf8b67a93","828f199c76d70a5ea0ddc4d9605063f1d323a28d","a6c6e4e06160d2ad231072e8743988a623ab14c9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da41004e1997059b4d0549fbeb56bf0858d14689","date":1425425090,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b3be660e210b4a5ce1e30fa69abb2d0dd0d8cc1","date":1426889883,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    // int sleep = req.getParams().getInt(\"sleep\",0);\n    // if (sleep > 0) {log.error(\"SLEEPING for \" + sleep);  Thread.sleep(sleep);}\n    if (req.getContentStreams() != null && req.getContentStreams().iterator().hasNext()) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Search requests cannot accept content streams\");\n    }\n    \n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? new RTimer() : null;\n\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n          timer.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", rsp.getEndTime()-req.getStartTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String)req.getContext().get(\"path\");\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"469779ab5be8ae82c45e0e2a86bfa6d3b30ce0c8","date":1428845063,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    if (components == null) getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":["0fc42da67bf449028cdf47b627864e69f70711b8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0fc42da67bf449028cdf47b627864e69f70711b8","date":1429224431,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    if (components == null) getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":["469779ab5be8ae82c45e0e2a86bfa6d3b30ce0c8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5676bf22fd531b9a2a3053047d0e0f922c1c53ff","date":1435097302,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    ShardHandler shardHandler1 = shardHandlerFactory.getShardHandler();\n    shardHandler1.checkDistributed(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>();\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"104456f4eeacc857f7e1e6408e1483de8c2bd658","date":1439164522,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimer timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimer subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimer subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"23e55c29de60130e8a1226800b66c5f6d7e16e8a","date":1447950053,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ecd75942508378ccc92c3a26f71db6cba9f25784","date":1450708761,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getValues().get(\"response\");\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.add(\"response\", r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83b038ad0480d5e81e058bf9fafb2dd85399985d","date":1450812495,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(\"partialResults\") == null) {\n                  rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6392c263ac1e0e2a22a7f2d50f499e76971801d","date":1456927541,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                if (req.getCore().getSolrConfig().luceneMatchVersion.onOrAfter(Version.LUCENE_5_1_0)) {\n                  String reqPath = (String) req.getContext().get(PATH);\n                  if (!\"/select\".equals(reqPath)) {\n                    params.set(CommonParams.QT, reqPath);\n                  } // else if path is /select, then the qt gets passed thru if set\n                } else {\n                  // this is the pre-5.1 behavior, which translates to sending the shard request to /select\n                  params.remove(CommonParams.QT);\n                }\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"304ef848381e39ff6cf3e7af6127733a6f4db389","date":1482353305,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params, rb.preferredHostAddress);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(CommonParams.DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd22dcd3ba035a1626face7319c94be45ae07172","date":1527224634,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        SolrDocumentList r = (SolrDocumentList) rb.rsp.getResponse();\n        if(r == null)\n          r = new SolrDocumentList();\n        r.setNumFound(0);\n        rb.rsp.addResponse(r);\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                if(rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n                  rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n                }\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":["83b038ad0480d5e81e058bf9fafb2dd85399985d","944836102ccff275d4e5382638bc2ec1257ff8bc","167c9d3137acf706f53c875de69f3165df85fd3b","ecd75942508378ccc92c3a26f71db6cba9f25784"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68f345f3b4bee014d571c564dac11b519febe85f","date":1560355769,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50932b328a92519d02ecfbcc328ef1415c26bd33","date":1560514224,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = new ResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab30b5737e6a5d4ee74fdc889750d18d2a624471","date":1576097297,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed > 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn( \"Query: \" + req.getParamString() + \"; \" + ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"640ded7811e1b7d29236a5e2934ec3cd266a8199","date":1588973147,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b73e9c1914a76cfa16576e9d7165e286cc35c36e","date":1593099382,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers;\n\n    if (timer != null) {\n      RTimerTree subt = timer.sub(\"circuitbreaker\");\n      rb.setTimer(subt.sub(\"circuitbreaker\"));\n\n      CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n      trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n\n      rb.getTimer().stop();\n      subt.stop();\n    } else {\n      CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n      trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n    }\n\n    if (trippedCircuitBreakers != null) {\n      String errorMessage = CircuitBreakerManager.constructFinalErrorMessageString(trippedCircuitBreakers);\n      rsp.add(STATUS, FAILURE);\n      rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n      return;\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c83e4e3bad02b24e922b644b91e819af19553a79","date":1593190221,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getSolrConfig().useCircuitBreakers) {\n      Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers;\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.constructFinalErrorMessageString(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers;\n\n    if (timer != null) {\n      RTimerTree subt = timer.sub(\"circuitbreaker\");\n      rb.setTimer(subt.sub(\"circuitbreaker\"));\n\n      CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n      trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n\n      rb.getTimer().stop();\n      subt.stop();\n    } else {\n      CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n      trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n    }\n\n    if (trippedCircuitBreakers != null) {\n      String errorMessage = CircuitBreakerManager.constructFinalErrorMessageString(trippedCircuitBreakers);\n      rsp.add(STATUS, FAILURE);\n      rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n      return;\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9c8a0d139a128916bbde3ee20210c0aec72f4f7","date":1593281638,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers;\n\n    if (timer != null) {\n      RTimerTree subt = timer.sub(\"circuitbreaker\");\n      rb.setTimer(subt.sub(\"circuitbreaker\"));\n\n      CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n      trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n\n      rb.getTimer().stop();\n      subt.stop();\n    } else {\n      CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n      trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n    }\n\n    if (trippedCircuitBreakers != null) {\n      String errorMessage = CircuitBreakerManager.constructFinalErrorMessageString(trippedCircuitBreakers);\n      rsp.add(STATUS, FAILURE);\n      rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n      return;\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getSolrConfig().useCircuitBreakers) {\n      Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers;\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.constructFinalErrorMessageString(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c24f8f07a3e4a885c0e19286d51575df197a611b","date":1593281672,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers;\n\n    if (timer != null) {\n      RTimerTree subt = timer.sub(\"circuitbreaker\");\n      rb.setTimer(subt.sub(\"circuitbreaker\"));\n\n      CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n      trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n\n      rb.getTimer().stop();\n      subt.stop();\n    } else {\n      CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n      trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n    }\n\n    if (trippedCircuitBreakers != null) {\n      String errorMessage = CircuitBreakerManager.constructFinalErrorMessageString(trippedCircuitBreakers);\n      rsp.add(STATUS, FAILURE);\n      rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n      return;\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; {}\", req.getParamString(), ex.getMessage());\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ef8e4fae9bcd156a117f5758819aeabdae3e963","date":1593674028,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getSolrConfig().useCircuitBreakers) {\n      List<CircuitBreaker> trippedCircuitBreakers;\n\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.toErrorMessage(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer( subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b5b21ccc1d52b794ed961763fbef107dc2c8b9f","date":1594211903,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getSolrConfig().useCircuitBreakers) {\n      List<CircuitBreaker> trippedCircuitBreakers;\n\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.toErrorMessage(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n\n    tagRequestWithRequestId(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getSolrConfig().useCircuitBreakers) {\n      List<CircuitBreaker> trippedCircuitBreakers;\n\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.toErrorMessage(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n    \n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f6d19d09273bf442102fec52cfac9af9294bc89","date":1597466467,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getSolrConfig().useCircuitBreakers) {\n      List<CircuitBreaker> trippedCircuitBreakers;\n\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.toErrorMessage(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n\n    tagRequestWithRequestId(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      SolrQueryTimeoutImpl.set(req);\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getSolrConfig().useCircuitBreakers) {\n      List<CircuitBreaker> trippedCircuitBreakers;\n\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.toErrorMessage(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n\n    tagRequestWithRequestId(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      long timeAllowed = req.getParams().getLong(CommonParams.TIME_ALLOWED, -1L);\n      if (timeAllowed >= 0L) {\n        SolrQueryTimeoutImpl.set(timeAllowed);\n      }\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ef286034ca1be064a363aaec38e34e64a59154c","date":1598517382,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SearchHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getCircuitBreakerManager().isEnabled()) {\n      List<CircuitBreaker> trippedCircuitBreakers;\n\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.toErrorMessage(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n\n    tagRequestWithRequestId(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      SolrQueryTimeoutImpl.set(req);\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    List<SearchComponent> components  = getComponents();\n    ResponseBuilder rb = newResponseBuilder(req, rsp, components);\n    if (rb.requestInfo != null) {\n      rb.requestInfo.setResponseBuilder(rb);\n    }\n\n    boolean dbg = req.getParams().getBool(CommonParams.DEBUG_QUERY, false);\n    rb.setDebug(dbg);\n    if (dbg == false){//if it's true, we are doing everything anyway.\n      SolrPluginUtils.getDebugInterests(req.getParams().getParams(CommonParams.DEBUG), rb);\n    }\n\n    final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n\n    if (req.getCore().getSolrConfig().useCircuitBreakers) {\n      List<CircuitBreaker> trippedCircuitBreakers;\n\n      if (timer != null) {\n        RTimerTree subt = timer.sub(\"circuitbreaker\");\n        rb.setTimer(subt);\n\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n\n        rb.getTimer().stop();\n      } else {\n        CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n        trippedCircuitBreakers = circuitBreakerManager.checkTripped();\n      }\n\n      if (trippedCircuitBreakers != null) {\n        String errorMessage = CircuitBreakerManager.toErrorMessage(trippedCircuitBreakers);\n        rsp.add(STATUS, FAILURE);\n        rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));\n        return;\n      }\n    }\n\n    final ShardHandler shardHandler1 = getAndPrepShardHandler(req, rb); // creates a ShardHandler object only if it's needed\n\n    tagRequestWithRequestId(rb);\n\n    if (timer == null) {\n      // non-debugging prepare phase\n      for( SearchComponent c : components ) {\n        c.prepare(rb);\n      }\n    } else {\n      // debugging prepare phase\n      RTimerTree subt = timer.sub( \"prepare\" );\n      for( SearchComponent c : components ) {\n        rb.setTimer(subt.sub( c.getName() ) );\n        c.prepare(rb);\n        rb.getTimer().stop();\n      }\n      subt.stop();\n    }\n\n    if (!rb.isDistrib) {\n      // a normal non-distributed request\n\n      SolrQueryTimeoutImpl.set(req);\n      try {\n        // The semantics of debugging vs not debugging are different enough that\n        // it makes sense to have two control loops\n        if(!rb.isDebug()) {\n          // Process\n          for( SearchComponent c : components ) {\n            c.process(rb);\n          }\n        }\n        else {\n          // Process\n          RTimerTree subt = timer.sub( \"process\" );\n          for( SearchComponent c : components ) {\n            rb.setTimer( subt.sub( c.getName() ) );\n            c.process(rb);\n            rb.getTimer().stop();\n          }\n          subt.stop();\n\n          // add the timing info\n          if (rb.isDebugTimings()) {\n            rb.addDebugInfo(\"timing\", timer.asNamedList() );\n          }\n        }\n      } catch (ExitableDirectoryReader.ExitingReaderException ex) {\n        log.warn(\"Query: {}; \", req.getParamString(), ex);\n        if( rb.rsp.getResponse() == null) {\n          rb.rsp.addResponse(new SolrDocumentList());\n        }\n        if(rb.isDebug()) {\n          NamedList debug = new NamedList();\n          debug.add(\"explain\", new NamedList());\n          rb.rsp.add(\"debug\", debug);\n        }\n        rb.rsp.getResponseHeader().asShallowMap()\n              .put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n      } finally {\n        SolrQueryTimeoutImpl.reset();\n      }\n    } else {\n      // a distributed request\n\n      if (rb.outgoing == null) {\n        rb.outgoing = new LinkedList<>();\n      }\n      rb.finished = new ArrayList<>();\n\n      int nextStage = 0;\n      do {\n        rb.stage = nextStage;\n        nextStage = ResponseBuilder.STAGE_DONE;\n\n        // call all components\n        for( SearchComponent c : components ) {\n          // the next stage is the minimum of what all components report\n          nextStage = Math.min(nextStage, c.distributedProcess(rb));\n        }\n\n\n        // check the outgoing queue and send requests\n        while (rb.outgoing.size() > 0) {\n\n          // submit all current request tasks at once\n          while (rb.outgoing.size() > 0) {\n            ShardRequest sreq = rb.outgoing.remove(0);\n            sreq.actualShards = sreq.shards;\n            if (sreq.actualShards==ShardRequest.ALL_SHARDS) {\n              sreq.actualShards = rb.shards;\n            }\n            sreq.responses = new ArrayList<>(sreq.actualShards.length); // presume we'll get a response from each shard we send to\n\n            // TODO: map from shard to address[]\n            for (String shard : sreq.actualShards) {\n              ModifiableSolrParams params = new ModifiableSolrParams(sreq.params);\n              params.remove(ShardParams.SHARDS);      // not a top-level request\n              params.set(DISTRIB, \"false\");               // not a top-level request\n              params.remove(\"indent\");\n              params.remove(CommonParams.HEADER_ECHO_PARAMS);\n              params.set(ShardParams.IS_SHARD, true);  // a sub (shard) request\n              params.set(ShardParams.SHARDS_PURPOSE, sreq.purpose);\n              params.set(ShardParams.SHARD_URL, shard); // so the shard knows what was asked\n              params.set(CommonParams.OMIT_HEADER, false);\n              if (rb.requestInfo != null) {\n                // we could try and detect when this is needed, but it could be tricky\n                params.set(\"NOW\", Long.toString(rb.requestInfo.getNOW().getTime()));\n              }\n              String shardQt = params.get(ShardParams.SHARDS_QT);\n              if (shardQt != null) {\n                params.set(CommonParams.QT, shardQt);\n              } else {\n                // for distributed queries that don't include shards.qt, use the original path\n                // as the default but operators need to update their luceneMatchVersion to enable\n                // this behavior since it did not work this way prior to 5.1\n                String reqPath = (String) req.getContext().get(PATH);\n                if (!\"/select\".equals(reqPath)) {\n                  params.set(CommonParams.QT, reqPath);\n                } // else if path is /select, then the qt gets passed thru if set\n              }\n              shardHandler1.submit(sreq, shard, params);\n            }\n          }\n\n\n          // now wait for replies, but if anyone puts more requests on\n          // the outgoing queue, send them out immediately (by exiting\n          // this loop)\n          boolean tolerant = ShardParams.getShardsTolerantAsBool(rb.req.getParams());\n          while (rb.outgoing.size() == 0) {\n            ShardResponse srsp = tolerant ? \n                shardHandler1.takeCompletedIncludingErrors():\n                shardHandler1.takeCompletedOrError();\n            if (srsp == null) break;  // no more requests to wait for\n\n            // Was there an exception?  \n            if (srsp.getException() != null) {\n              // If things are not tolerant, abort everything and rethrow\n              if(!tolerant) {\n                shardHandler1.cancelAll();\n                if (srsp.getException() instanceof SolrException) {\n                  throw (SolrException)srsp.getException();\n                } else {\n                  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, srsp.getException());\n                }\n              } else {\n                rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n              }\n            }\n\n            rb.finished.add(srsp.getShardRequest());\n\n            // let the components see the responses to the request\n            for(SearchComponent c : components) {\n              c.handleResponses(rb, srsp.getShardRequest());\n            }\n          }\n        }\n\n        for(SearchComponent c : components) {\n          c.finishStage(rb);\n        }\n\n        // we are done when the next stage is MAX_VALUE\n      } while (nextStage != Integer.MAX_VALUE);\n    }\n    \n    // SOLR-5550: still provide shards.info if requested even for a short circuited distrib request\n    if(!rb.isDistrib && req.getParams().getBool(ShardParams.SHARDS_INFO, false) && rb.shortCircuitedURL != null) {  \n      NamedList<Object> shardInfo = new SimpleOrderedMap<Object>();\n      SimpleOrderedMap<Object> nl = new SimpleOrderedMap<Object>();        \n      if (rsp.getException() != null) {\n        Throwable cause = rsp.getException();\n        if (cause instanceof SolrServerException) {\n          cause = ((SolrServerException)cause).getRootCause();\n        } else {\n          if (cause.getCause() != null) {\n            cause = cause.getCause();\n          }          \n        }\n        nl.add(\"error\", cause.toString() );\n        StringWriter trace = new StringWriter();\n        cause.printStackTrace(new PrintWriter(trace));\n        nl.add(\"trace\", trace.toString() );\n      }\n      else {\n        nl.add(\"numFound\", rb.getResults().docList.matches());\n        nl.add(\"numFoundExact\", rb.getResults().docList.hitCountRelation() == TotalHits.Relation.EQUAL_TO);\n        nl.add(\"maxScore\", rb.getResults().docList.maxScore());\n      }\n      nl.add(\"shardAddress\", rb.shortCircuitedURL);\n      nl.add(\"time\", req.getRequestTimer().getTime()); // elapsed time of this request so far\n      \n      int pos = rb.shortCircuitedURL.indexOf(\"://\");        \n      String shardInfoName = pos != -1 ? rb.shortCircuitedURL.substring(pos+3) : rb.shortCircuitedURL;\n      shardInfo.add(shardInfoName, nl);   \n      rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);            \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"640ded7811e1b7d29236a5e2934ec3cd266a8199":["575e66bd4b2349209027f6801184da7fc3cba13f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","e6dd476b943b132ecfa6b3ffc72e439eb2d9e061"],"104456f4eeacc857f7e1e6408e1483de8c2bd658":["5676bf22fd531b9a2a3053047d0e0f922c1c53ff"],"01624b85de12fb02335810bdf325124e59040772":["304ef848381e39ff6cf3e7af6127733a6f4db389"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["ecd75942508378ccc92c3a26f71db6cba9f25784"],"d9c8a0d139a128916bbde3ee20210c0aec72f4f7":["c83e4e3bad02b24e922b644b91e819af19553a79"],"4a5c97e98e8e65bb8f85fe1a1a6418dafc568b43":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"d6392c263ac1e0e2a22a7f2d50f499e76971801d":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"5f6d19d09273bf442102fec52cfac9af9294bc89":["4b5b21ccc1d52b794ed961763fbef107dc2c8b9f"],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"3f5084509b7789719f8c37e7d8c6116e2b61d538":["167c9d3137acf706f53c875de69f3165df85fd3b"],"d66363068e87a246ce08fee4a42f30f126b92723":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"ab30b5737e6a5d4ee74fdc889750d18d2a624471":["50932b328a92519d02ecfbcc328ef1415c26bd33"],"da41004e1997059b4d0549fbeb56bf0858d14689":["edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c"],"944836102ccff275d4e5382638bc2ec1257ff8bc":["f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"4b5b21ccc1d52b794ed961763fbef107dc2c8b9f":["8ef8e4fae9bcd156a117f5758819aeabdae3e963"],"575e66bd4b2349209027f6801184da7fc3cba13f":["ab30b5737e6a5d4ee74fdc889750d18d2a624471"],"304ef848381e39ff6cf3e7af6127733a6f4db389":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","304ef848381e39ff6cf3e7af6127733a6f4db389"],"68f345f3b4bee014d571c564dac11b519febe85f":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["944836102ccff275d4e5382638bc2ec1257ff8bc"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["1bea3922196318026c4274f2013416acb60c691e","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"bd22dcd3ba035a1626face7319c94be45ae07172":["01624b85de12fb02335810bdf325124e59040772"],"5676bf22fd531b9a2a3053047d0e0f922c1c53ff":["0fc42da67bf449028cdf47b627864e69f70711b8"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4a5c97e98e8e65bb8f85fe1a1a6418dafc568b43"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["83b038ad0480d5e81e058bf9fafb2dd85399985d","d6392c263ac1e0e2a22a7f2d50f499e76971801d"],"23e55c29de60130e8a1226800b66c5f6d7e16e8a":["104456f4eeacc857f7e1e6408e1483de8c2bd658"],"0ef286034ca1be064a363aaec38e34e64a59154c":["5f6d19d09273bf442102fec52cfac9af9294bc89"],"eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e":["c0d0eda576bd1392f929c375143ff45503e89192"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"b73e9c1914a76cfa16576e9d7165e286cc35c36e":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["bd22dcd3ba035a1626face7319c94be45ae07172"],"8ef8e4fae9bcd156a117f5758819aeabdae3e963":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"1bea3922196318026c4274f2013416acb60c691e":["e6dd476b943b132ecfa6b3ffc72e439eb2d9e061"],"df724d84dab24a0cc54bec95a8680867adc7f171":["50932b328a92519d02ecfbcc328ef1415c26bd33","ab30b5737e6a5d4ee74fdc889750d18d2a624471"],"c24f8f07a3e4a885c0e19286d51575df197a611b":["d9c8a0d139a128916bbde3ee20210c0aec72f4f7"],"50932b328a92519d02ecfbcc328ef1415c26bd33":["68f345f3b4bee014d571c564dac11b519febe85f"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c","6b3be660e210b4a5ce1e30fa69abb2d0dd0d8cc1"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"6b3be660e210b4a5ce1e30fa69abb2d0dd0d8cc1":["da41004e1997059b4d0549fbeb56bf0858d14689"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["6b3be660e210b4a5ce1e30fa69abb2d0dd0d8cc1"],"c0d0eda576bd1392f929c375143ff45503e89192":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c":["a94e45463a0089149b0d148ae5369140e7f54b8c"],"0fc42da67bf449028cdf47b627864e69f70711b8":["469779ab5be8ae82c45e0e2a86bfa6d3b30ce0c8"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["1bea3922196318026c4274f2013416acb60c691e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3f5084509b7789719f8c37e7d8c6116e2b61d538"],"c83e4e3bad02b24e922b644b91e819af19553a79":["b73e9c1914a76cfa16576e9d7165e286cc35c36e"],"55980207f1977bd1463465de1659b821347e2fa8":["da951a24a6a87d5ba7e1820f8c28a1e2beea76c1","f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"e6dd476b943b132ecfa6b3ffc72e439eb2d9e061":["d66363068e87a246ce08fee4a42f30f126b92723"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["c24f8f07a3e4a885c0e19286d51575df197a611b"],"469779ab5be8ae82c45e0e2a86bfa6d3b30ce0c8":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"167c9d3137acf706f53c875de69f3165df85fd3b":["4a5c97e98e8e65bb8f85fe1a1a6418dafc568b43"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["304ef848381e39ff6cf3e7af6127733a6f4db389"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["55980207f1977bd1463465de1659b821347e2fa8","944836102ccff275d4e5382638bc2ec1257ff8bc"],"da951a24a6a87d5ba7e1820f8c28a1e2beea76c1":["c0d0eda576bd1392f929c375143ff45503e89192","eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f001da93ec624cbfbf3655c529836b5b1ec1aa46":["eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ecd75942508378ccc92c3a26f71db6cba9f25784":["23e55c29de60130e8a1226800b66c5f6d7e16e8a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0ef286034ca1be064a363aaec38e34e64a59154c"]},"commit2Childs":{"640ded7811e1b7d29236a5e2934ec3cd266a8199":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"104456f4eeacc857f7e1e6408e1483de8c2bd658":["23e55c29de60130e8a1226800b66c5f6d7e16e8a"],"01624b85de12fb02335810bdf325124e59040772":["bd22dcd3ba035a1626face7319c94be45ae07172"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["d6392c263ac1e0e2a22a7f2d50f499e76971801d","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"d9c8a0d139a128916bbde3ee20210c0aec72f4f7":["c24f8f07a3e4a885c0e19286d51575df197a611b"],"4a5c97e98e8e65bb8f85fe1a1a6418dafc568b43":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","167c9d3137acf706f53c875de69f3165df85fd3b"],"d6392c263ac1e0e2a22a7f2d50f499e76971801d":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"5f6d19d09273bf442102fec52cfac9af9294bc89":["0ef286034ca1be064a363aaec38e34e64a59154c"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3f5084509b7789719f8c37e7d8c6116e2b61d538":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d66363068e87a246ce08fee4a42f30f126b92723":["e6dd476b943b132ecfa6b3ffc72e439eb2d9e061"],"ab30b5737e6a5d4ee74fdc889750d18d2a624471":["575e66bd4b2349209027f6801184da7fc3cba13f","df724d84dab24a0cc54bec95a8680867adc7f171"],"da41004e1997059b4d0549fbeb56bf0858d14689":["6b3be660e210b4a5ce1e30fa69abb2d0dd0d8cc1"],"944836102ccff275d4e5382638bc2ec1257ff8bc":["a94e45463a0089149b0d148ae5369140e7f54b8c","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"4b5b21ccc1d52b794ed961763fbef107dc2c8b9f":["5f6d19d09273bf442102fec52cfac9af9294bc89"],"304ef848381e39ff6cf3e7af6127733a6f4db389":["01624b85de12fb02335810bdf325124e59040772","f03e4bed5023ec3ef93a771b8888cae991cf448d","6f4c5d3859373c3a74734e85efa122b17514e3e8"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["b73e9c1914a76cfa16576e9d7165e286cc35c36e"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"68f345f3b4bee014d571c564dac11b519febe85f":["50932b328a92519d02ecfbcc328ef1415c26bd33"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"bd22dcd3ba035a1626face7319c94be45ae07172":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"5676bf22fd531b9a2a3053047d0e0f922c1c53ff":["104456f4eeacc857f7e1e6408e1483de8c2bd658"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["304ef848381e39ff6cf3e7af6127733a6f4db389","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"23e55c29de60130e8a1226800b66c5f6d7e16e8a":["ecd75942508378ccc92c3a26f71db6cba9f25784"],"0ef286034ca1be064a363aaec38e34e64a59154c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e":["da951a24a6a87d5ba7e1820f8c28a1e2beea76c1","f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"c26f00b574427b55127e869b935845554afde1fa":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b73e9c1914a76cfa16576e9d7165e286cc35c36e":["c83e4e3bad02b24e922b644b91e819af19553a79"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["68f345f3b4bee014d571c564dac11b519febe85f"],"8ef8e4fae9bcd156a117f5758819aeabdae3e963":["4b5b21ccc1d52b794ed961763fbef107dc2c8b9f"],"1bea3922196318026c4274f2013416acb60c691e":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"df724d84dab24a0cc54bec95a8680867adc7f171":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"50932b328a92519d02ecfbcc328ef1415c26bd33":["ab30b5737e6a5d4ee74fdc889750d18d2a624471","df724d84dab24a0cc54bec95a8680867adc7f171"],"c24f8f07a3e4a885c0e19286d51575df197a611b":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"6b3be660e210b4a5ce1e30fa69abb2d0dd0d8cc1":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d2638f781be724518ff6c2263d14a48cf6e68017","469779ab5be8ae82c45e0e2a86bfa6d3b30ce0c8"],"c0d0eda576bd1392f929c375143ff45503e89192":["eb9e4cb185078b4e99e3b7070abb77eb2cdfaf6e","da951a24a6a87d5ba7e1820f8c28a1e2beea76c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"edd89d5655f0e7381ecdfc7770e8bdaa1741ed3c":["da41004e1997059b4d0549fbeb56bf0858d14689","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"0fc42da67bf449028cdf47b627864e69f70711b8":["5676bf22fd531b9a2a3053047d0e0f922c1c53ff"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["4a5c97e98e8e65bb8f85fe1a1a6418dafc568b43","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c0d0eda576bd1392f929c375143ff45503e89192"],"c83e4e3bad02b24e922b644b91e819af19553a79":["d9c8a0d139a128916bbde3ee20210c0aec72f4f7"],"55980207f1977bd1463465de1659b821347e2fa8":["0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"e6dd476b943b132ecfa6b3ffc72e439eb2d9e061":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1bea3922196318026c4274f2013416acb60c691e"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["8ef8e4fae9bcd156a117f5758819aeabdae3e963"],"469779ab5be8ae82c45e0e2a86bfa6d3b30ce0c8":["0fc42da67bf449028cdf47b627864e69f70711b8"],"167c9d3137acf706f53c875de69f3165df85fd3b":["3f5084509b7789719f8c37e7d8c6116e2b61d538"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":[],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"da951a24a6a87d5ba7e1820f8c28a1e2beea76c1":["55980207f1977bd1463465de1659b821347e2fa8"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"f001da93ec624cbfbf3655c529836b5b1ec1aa46":["944836102ccff275d4e5382638bc2ec1257ff8bc","55980207f1977bd1463465de1659b821347e2fa8"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d66363068e87a246ce08fee4a42f30f126b92723","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ecd75942508378ccc92c3a26f71db6cba9f25784":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d2638f781be724518ff6c2263d14a48cf6e68017","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","f03e4bed5023ec3ef93a771b8888cae991cf448d","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0","df724d84dab24a0cc54bec95a8680867adc7f171","0d22ac6a4146774c1bc8400160fc0b6150294e92","6f4c5d3859373c3a74734e85efa122b17514e3e8","0a22eafe3f72a4c2945eaad9547e6c78816978f4","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}