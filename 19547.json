{"path":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","commits":[{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"/dev/null","sourceNew":"  public String addRandomEdit(String string, int prefixLenght) {\n    char[] charArray = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < charArray.length; i++) {\n      if (i >= prefixLenght && random().nextBoolean() && i < charArray.length-1) {\n        switch(random().nextInt(3)){\n          case 2:\n            for (int j = i+1; j < charArray.length; j++) {\n              builder.append(charArray[j]);  \n            }\n            return builder.toString();\n          case 1:\n            if (i+1<charArray.length) {\n              builder.append(charArray[i+1]);\n              builder.append(charArray[i++]);\n              i++;\n            }\n            for (int j = i; j < charArray.length; j++) {\n              builder.append(charArray[j]);\n            }\n            return builder.toString();\n          case 0:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < charArray.length; j++) {\n              builder.append(charArray[j]);  \n            }\n            return builder.toString();\n           \n        }\n      }\n      builder.append(charArray[i]);\n      \n    }\n    return builder.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8","date":1350576194,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","sourceNew":"  private static String addRandomEdit(String string, int prefixLenght) {\n    char[] charArray = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < charArray.length; i++) {\n      if (i >= prefixLenght && random().nextBoolean() && i < charArray.length-1) {\n        switch(random().nextInt(3)){\n          case 2:\n            for (int j = i+1; j < charArray.length; j++) {\n              builder.append(charArray[j]);  \n            }\n            return builder.toString();\n          case 1:\n            if (i+1<charArray.length) {\n              builder.append(charArray[i+1]);\n              builder.append(charArray[i++]);\n              i++;\n            }\n            for (int j = i; j < charArray.length; j++) {\n              builder.append(charArray[j]);\n            }\n            return builder.toString();\n          case 0:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < charArray.length; j++) {\n              builder.append(charArray[j]);  \n            }\n            return builder.toString();\n           \n        }\n      }\n      builder.append(charArray[i]);\n      \n    }\n    return builder.toString();\n  }\n\n","sourceOld":"  public String addRandomEdit(String string, int prefixLenght) {\n    char[] charArray = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < charArray.length; i++) {\n      if (i >= prefixLenght && random().nextBoolean() && i < charArray.length-1) {\n        switch(random().nextInt(3)){\n          case 2:\n            for (int j = i+1; j < charArray.length; j++) {\n              builder.append(charArray[j]);  \n            }\n            return builder.toString();\n          case 1:\n            if (i+1<charArray.length) {\n              builder.append(charArray[i+1]);\n              builder.append(charArray[i++]);\n              i++;\n            }\n            for (int j = i; j < charArray.length; j++) {\n              builder.append(charArray[j]);\n            }\n            return builder.toString();\n          case 0:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < charArray.length; j++) {\n              builder.append(charArray[j]);  \n            }\n            return builder.toString();\n           \n        }\n      }\n      builder.append(charArray[i]);\n      \n    }\n    return builder.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e70d31b054fdad6f9d128fd421df6506f724b91","date":1350995421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","sourceNew":"  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(3)) {\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n\n          // nocommit need transposition too?\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","sourceOld":"  private static String addRandomEdit(String string, int prefixLenght) {\n    char[] charArray = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < charArray.length; i++) {\n      if (i >= prefixLenght && random().nextBoolean() && i < charArray.length-1) {\n        switch(random().nextInt(3)){\n          case 2:\n            for (int j = i+1; j < charArray.length; j++) {\n              builder.append(charArray[j]);  \n            }\n            return builder.toString();\n          case 1:\n            if (i+1<charArray.length) {\n              builder.append(charArray[i+1]);\n              builder.append(charArray[i++]);\n              i++;\n            }\n            for (int j = i; j < charArray.length; j++) {\n              builder.append(charArray[j]);\n            }\n            return builder.toString();\n          case 0:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < charArray.length; j++) {\n              builder.append(charArray[j]);  \n            }\n            return builder.toString();\n           \n        }\n      }\n      builder.append(charArray[i]);\n      \n    }\n    return builder.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ba222c174ec1943d8d14d012d1d6e24a1cc4972","date":1351522220,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","sourceNew":"  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","sourceOld":"  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(3)) {\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n\n          // nocommit need transposition too?\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"/dev/null","sourceNew":"  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c2e9514030f533e06823aa8aec716afaf09cced","date":1353602477,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","sourceOld":"  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","sourceOld":"  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","date":1374158194,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            // bytes 0x1e and 0x1f are reserved\n            int x = random().nextBoolean() ? random().nextInt(30) :  32 + random().nextInt(128 - 32);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","bugFix":["cc41b743423981e7ec17a024ce7e107096e472fe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest#addRandomEdit(String,int).mjava","sourceNew":"  @SuppressWarnings(\"fallthrough\")\n  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            // bytes 0x1e and 0x1f are reserved\n            int x = random().nextBoolean() ? random().nextInt(30) :  32 + random().nextInt(128 - 32);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"fallthrough\")\n  private static String addRandomEdit(String string, int prefixLength) {\n    char[] input = string.toCharArray();\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < input.length; i++) {\n      if (i >= prefixLength && random().nextBoolean() && i < input.length-1) {\n        switch(random().nextInt(4)) {\n          case 3:\n            if (i < input.length-1) {\n              // Transpose input[i] and input[1+i]:\n              builder.append(input[i+1]);\n              builder.append(input[i]);\n              for(int j=i+2;j<input.length;j++) {\n                builder.append(input[j]);\n              }\n              return builder.toString();\n            }\n            // NOTE: fall through to delete:\n          case 2:\n            // Delete input[i]\n            for (int j = i+1; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n          case 1:\n            // Insert input[i+1] twice\n            if (i+1<input.length) {\n              builder.append(input[i+1]);\n              builder.append(input[i++]);\n              i++;\n            }\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);\n            }\n            return builder.toString();\n          case 0:\n            // Insert random byte.\n            // NOTE: can only use ascii here so that, in\n            // UTF8 byte space it's still a single\n            // insertion:\n            int x = random().nextInt(128);\n            builder.append((char) x);\n            for (int j = i; j < input.length; j++) {\n              builder.append(input[j]);  \n            }\n            return builder.toString();\n        }\n      }\n\n      builder.append(input[i]);\n    }\n\n    return builder.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ba222c174ec1943d8d14d012d1d6e24a1cc4972"],"cc41b743423981e7ec17a024ce7e107096e472fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["1e70d31b054fdad6f9d128fd421df6506f724b91"],"407687e67faf6e1f02a211ca078d8e3eed631027":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","8c2e9514030f533e06823aa8aec716afaf09cced"],"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6":["8c2e9514030f533e06823aa8aec716afaf09cced"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["8c2e9514030f533e06823aa8aec716afaf09cced"],"1e70d31b054fdad6f9d128fd421df6506f724b91":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["cc41b743423981e7ec17a024ce7e107096e472fe"],"8c2e9514030f533e06823aa8aec716afaf09cced":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6"]},"commit2Childs":{"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["407687e67faf6e1f02a211ca078d8e3eed631027","8c2e9514030f533e06823aa8aec716afaf09cced"],"cc41b743423981e7ec17a024ce7e107096e472fe":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","cc41b743423981e7ec17a024ce7e107096e472fe"],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"1e70d31b054fdad6f9d128fd421df6506f724b91":["0ba222c174ec1943d8d14d012d1d6e24a1cc4972"],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["1e70d31b054fdad6f9d128fd421df6506f724b91"],"8c2e9514030f533e06823aa8aec716afaf09cced":["407687e67faf6e1f02a211ca078d8e3eed631027","2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}