{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeString(word, 0, word.length);\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeString(word, 0, word.length);\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f4ef381bf0c2d618c6db830d3dd668c6901c05a","date":1402592253,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeString(word, 0, word.length);\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a67285d1a68175d877eb9fd1624fccad3db028ff","date":1402779028,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public LightAutomaton toAutomaton(int n) {\n    return toAutomaton(n, \"\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    return toAutomaton(n, \"\");\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public LightAutomaton toAutomaton(int n) {\n    return toAutomaton(n, \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    return toAutomaton(n, \"\");\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0) {\n      return BasicAutomata.makeString(word, 0, word.length);\n    }\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14600834a1fbc7c12faf344466e00cca8cc67de4","date":1423303834,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   */\n  public Automaton toAutomaton(int n) {\n    return toAutomaton(n, \"\");\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    return toAutomaton(n, \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","cc41b743423981e7ec17a024ce7e107096e472fe"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a"],"cc41b743423981e7ec17a024ce7e107096e472fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"14600834a1fbc7c12faf344466e00cca8cc67de4":["5c84485629d80d203608e8975a1139de9933cc38"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"5c84485629d80d203608e8975a1139de9933cc38":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["14600834a1fbc7c12faf344466e00cca8cc67de4"]},"commit2Childs":{"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a","5c84485629d80d203608e8975a1139de9933cc38"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"cc41b743423981e7ec17a024ce7e107096e472fe":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","cc41b743423981e7ec17a024ce7e107096e472fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"14600834a1fbc7c12faf344466e00cca8cc67de4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"5c84485629d80d203608e8975a1139de9933cc38":["14600834a1fbc7c12faf344466e00cca8cc67de4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}