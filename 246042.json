{"path":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","commits":[{"id":"954ae83b7dfacaa33d48ea056448ae11f7745a93","date":1571867711,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file :\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n      cluster.getZkClient().delete(\"/keys/exe/pub_key512.der\", -1, true);\n      add.files = Arrays.asList(new String[]{FILE2});\n      expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");\n\n      //Now lets' put the keys back\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correcy\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d218decf811b7a0a4d86218c54c79c74a962374b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d218decf811b7a0a4d86218c54c79c74a962374b","date":1578632144,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","sourceNew":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file:\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n//      cluster.getZkClient().delete(\"/keys/exe/pub_key512.der\", -1, true);\n      add.files = Arrays.asList(new String[]{FILE2});\n      /*expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");*/\n\n      //Now lets' put the keys back\n//      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correcy\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file :\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n      cluster.getZkClient().delete(\"/keys/exe/pub_key512.der\", -1, true);\n      add.files = Arrays.asList(new String[]{FILE2});\n      expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");\n\n      //Now lets' put the keys back\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correcy\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","bugFix":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8f0a7504661c8e51be5c63e87f9d79a36d9116c","date":1578657638,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","sourceNew":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file:\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n//      cluster.getZkClient().delete(\"/keys/exe/pub_key512.der\", -1, true);\n      add.files = Arrays.asList(new String[]{FILE2});\n      /*expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");*/\n\n      //Now lets' put the keys back\n//      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correcy\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file :\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      cluster.getZkClient().makePath(\"/keys/exe\", true);\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n      cluster.getZkClient().delete(\"/keys/exe/pub_key512.der\", -1, true);\n      add.files = Arrays.asList(new String[]{FILE2});\n      expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");\n\n      //Now lets' put the keys back\n      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correcy\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7757ad4a47d8b36bb6894c5ad33f766b4ddfa389","date":1591056099,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","sourceNew":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file:\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n      add.files = Arrays.asList(new String[]{FILE2});\n      /*expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");*/\n\n      //Now lets' put the keys back\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correcy\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file:\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n//      cluster.getZkClient().delete(\"/keys/exe/pub_key512.der\", -1, true);\n      add.files = Arrays.asList(new String[]{FILE2});\n      /*expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");*/\n\n      //Now lets' put the keys back\n//      cluster.getZkClient().create(\"/keys/exe/pub_key512.der\", derFile, CreateMode.PERSISTENT, true);\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correcy\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64ec73f19361ec6354e55c878a349735fa8bc52e","date":1596183798,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/pkg/TestPackages#testAPI().mjava","sourceNew":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file:\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n      add.files = Arrays.asList(new String[]{FILE2});\n      /*expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");*/\n\n      //Now lets' put the keys back\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correct\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testAPI() throws Exception {\n    System.setProperty(\"enable.packages\", \"true\");\n    MiniSolrCloudCluster cluster =\n        configureCluster(4)\n            .withJettyConfig(jetty -> jetty.enableV2(true))\n            .addConfig(\"conf\", configset(\"cloud-minimal\"))\n            .configure();\n    try {\n      String errPath = \"/error/details[0]/errorMessages[0]\";\n      String FILE1 = \"/mypkg/v.0.12/jar_a.jar\";\n      String FILE2 = \"/mypkg/v.0.12/jar_b.jar\";\n      String FILE3 = \"/mypkg/v.0.13/jar_a.jar\";\n\n      Package.AddVersion add = new Package.AddVersion();\n      add.version = \"0.12\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE1, FILE2});\n      V2Request req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"add\", add))\n          .build();\n\n      //the files is not yet there. The command should fail with error saying \"No such file\"\n      expectError(req, cluster.getSolrClient(), errPath, \"No such file:\");\n\n\n      //post the jar file. No signature is sent\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE1, null);\n\n\n      add.files = Arrays.asList(new String[]{FILE1});\n      expectError(req, cluster.getSolrClient(), errPath,\n          FILE1 + \" has no signature\");\n      //now we upload the keys\n      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n      //and upload the same file with a different name but it has proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs.jar.bin\", FILE2,\n          \"L3q/qIGs4NaF6JiO0ZkMUFa88j0OmYc+I6O7BOdNuMct/xoZ4h73aZHZGc0+nmI1f/U3bOlMPINlSOM6LK3JpQ==\");\n      // with correct signature\n      //after uploading the file, let's delete the keys to see if we get proper error message\n      add.files = Arrays.asList(new String[]{FILE2});\n      /*expectError(req, cluster.getSolrClient(), errPath,\n          \"ZooKeeper does not have any public keys\");*/\n\n      //Now lets' put the keys back\n\n      //this time we have a file with proper signature, public keys are in ZK\n      // so the add {} command should succeed\n      req.process(cluster.getSolrClient());\n\n      //Now verify the data in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.12\",\n              \":packages:test_pkg[0]:files[0]\", FILE1\n          ));\n\n      //post a new jar with a proper signature\n      postFileAndWait(cluster, \"runtimecode/runtimelibs_v2.jar.bin\", FILE3,\n          \"j+Rflxi64tXdqosIhbusqi6GTwZq8znunC/dzwcWW0/dHlFGKDurOaE1Nz9FSPJuXbHkVLj638yZ0Lp1ssnoYA==\");\n\n\n      //this time we are adding the second version of the package (0.13)\n      add.version = \"0.13\";\n      add.pkg = \"test_pkg\";\n      add.files = Arrays.asList(new String[]{FILE3});\n\n      //this request should succeed\n      req.process(cluster.getSolrClient());\n      //no verify the data (/packages.json) in ZK\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[1]:version\", \"0.13\",\n              \":packages:test_pkg[1]:files[0]\", FILE3\n          ));\n\n      //Now we will just delete one version\n      Package.DelVersion delVersion = new Package.DelVersion();\n      delVersion.version = \"0.1\";//this version does not exist\n      delVersion.pkg = \"test_pkg\";\n      req = new V2Request.Builder(\"/cluster/package\")\n          .forceV2(true)\n          .withMethod(SolrRequest.METHOD.POST)\n          .withPayload(Collections.singletonMap(\"delete\", delVersion))\n          .build();\n\n      //we are expecting an error\n      expectError(req, cluster.getSolrClient(), errPath, \"No such version:\");\n\n      delVersion.version = \"0.12\";//correct version. Should succeed\n      req.process(cluster.getSolrClient());\n      //Verify with ZK that the data is correcy\n      TestDistribPackageStore.assertResponseValues(1,\n          () -> new MapWriterMap((Map) Utils.fromJSON(cluster.getZkClient().getData(SOLR_PKGS_PATH,\n              null, new Stat(), true))),\n          Utils.makeMap(\n              \":packages:test_pkg[0]:version\", \"0.13\",\n              \":packages:test_pkg[0]:files[0]\", FILE2\n          ));\n\n\n      //So far we have been verifying the details with  ZK directly\n      //use the package read API to verify with each node that it has the correct data\n      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n        String path = jetty.getBaseUrl().toString().replace(\"/solr\", \"/api\") + \"/cluster/package?wt=javabin\";\n        TestDistribPackageStore.assertResponseValues(10, new Callable<NavigableObject>() {\n          @Override\n          public NavigableObject call() throws Exception {\n            try (HttpSolrClient solrClient = (HttpSolrClient) jetty.newClient()) {\n              return (NavigableObject) Utils.executeGET(solrClient.getHttpClient(), path, Utils.JAVABINCONSUMER);\n            }\n          }\n        }, Utils.makeMap(\n            \":result:packages:test_pkg[0]:version\", \"0.13\",\n            \":result:packages:test_pkg[0]:files[0]\", FILE3\n        ));\n      }\n    } finally {\n      cluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8f0a7504661c8e51be5c63e87f9d79a36d9116c":["954ae83b7dfacaa33d48ea056448ae11f7745a93","d218decf811b7a0a4d86218c54c79c74a962374b"],"64ec73f19361ec6354e55c878a349735fa8bc52e":["7757ad4a47d8b36bb6894c5ad33f766b4ddfa389"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d218decf811b7a0a4d86218c54c79c74a962374b":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"7757ad4a47d8b36bb6894c5ad33f766b4ddfa389":["d218decf811b7a0a4d86218c54c79c74a962374b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["64ec73f19361ec6354e55c878a349735fa8bc52e"]},"commit2Childs":{"b8f0a7504661c8e51be5c63e87f9d79a36d9116c":[],"64ec73f19361ec6354e55c878a349735fa8bc52e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"954ae83b7dfacaa33d48ea056448ae11f7745a93":["b8f0a7504661c8e51be5c63e87f9d79a36d9116c","d218decf811b7a0a4d86218c54c79c74a962374b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["954ae83b7dfacaa33d48ea056448ae11f7745a93"],"d218decf811b7a0a4d86218c54c79c74a962374b":["b8f0a7504661c8e51be5c63e87f9d79a36d9116c","7757ad4a47d8b36bb6894c5ad33f766b4ddfa389"],"7757ad4a47d8b36bb6894c5ad33f766b4ddfa389":["64ec73f19361ec6354e55c878a349735fa8bc52e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b8f0a7504661c8e51be5c63e87f9d79a36d9116c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}