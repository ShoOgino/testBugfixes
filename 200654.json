{"path":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","commits":[{"id":"0f45f65b8ca4312a6880cc80396c35205dc21543","date":1317846119,"type":0,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"/dev/null","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      docIdField = params.get(DOCID_PARAM, DOCID_FIELD_DEFAULT);\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47aa44a85056dbdfdb00ae7342da74c0988bf1b7","date":1343120359,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      docIdField = params.get(DOCID_PARAM, DOCID_FIELD_DEFAULT);\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","date":1343203827,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      docIdField = params.get(DOCID_PARAM, DOCID_FIELD_DEFAULT);\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      docIdField = params.get(DOCID_PARAM, DOCID_FIELD_DEFAULT);\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      docIdField = params.get(DOCID_PARAM, DOCID_FIELD_DEFAULT);\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f","date":1351009382,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["3ff1a276d1c94e9393032df34ad607eda09ee3a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;        \n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n      \n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      \n      \n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d3ef1a6efd1b3a7ca06843b1165d8690dee94ee","date":1372775927,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Normalize detected langcode onto normalized langcode\n      lcMap = new HashMap<String,String>();\n      if(params.get(LCMAP) != null) {\n        for(String mapping : params.get(LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n\n      // Language Code mapping\n      mapLcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            mapLcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Normalize detected langcode onto normalized langcode\n      lcMap = new HashMap<String,String>();\n      if(params.get(LCMAP) != null) {\n        for(String mapping : params.get(LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n\n      // Language Code mapping\n      mapLcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            mapLcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Language Code mapping\n      lcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Normalize detected langcode onto normalized langcode\n      lcMap = new HashMap<>();\n      if(params.get(LCMAP) != null) {\n        for(String mapping : params.get(LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n\n      // Language Code mapping\n      mapLcMap = new HashMap<>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            mapLcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<String>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<String>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<String>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Normalize detected langcode onto normalized langcode\n      lcMap = new HashMap<String,String>();\n      if(params.get(LCMAP) != null) {\n        for(String mapping : params.get(LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n\n      // Language Code mapping\n      mapLcMap = new HashMap<String,String>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            mapLcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ff1a276d1c94e9393032df34ad607eda09ee3a6","date":1417803750,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Normalize detected langcode onto normalized langcode\n      lcMap = new HashMap<>();\n      if(params.get(LCMAP) != null) {\n        for(String mapping : params.get(LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n\n      // Language Code mapping\n      mapLcMap = new HashMap<>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            mapLcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      maxFieldValueChars = params.getInt(MAX_FIELD_VALUE_CHARS, MAX_FIELD_VALUE_CHARS_DEFAULT);\n      maxTotalChars = params.getInt(MAX_TOTAL_CHARS, MAX_TOTAL_CHARS_DEFAULT);\n      if (maxFieldValueChars > maxTotalChars) {\n        if (maxTotalChars == MAX_TOTAL_CHARS_DEFAULT) {\n          // If the user specified only maxFieldValueChars, make maxTotalChars the same as it\n          log.warn(MAX_FIELD_VALUE_CHARS + \" (\" + maxFieldValueChars + \") is less than \" + MAX_TOTAL_CHARS + \" (\"\n              + maxTotalChars + \").  Setting \" + MAX_TOTAL_CHARS + \" to \" + maxFieldValueChars + \".\");\n          maxTotalChars = maxFieldValueChars;\n        } else {\n          // If the user specified maxTotalChars, make maxFieldValueChars the same as it\n          log.warn(MAX_FIELD_VALUE_CHARS + \" (\" + maxFieldValueChars + \") is less than \" + MAX_TOTAL_CHARS + \" (\"\n              + maxTotalChars + \").  Setting \" + MAX_FIELD_VALUE_CHARS + \" to \" + maxTotalChars + \".\");\n          maxFieldValueChars = maxTotalChars;\n        }\n      }\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Normalize detected langcode onto normalized langcode\n      lcMap = new HashMap<>();\n      if(params.get(LCMAP) != null) {\n        for(String mapping : params.get(LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n\n      // Language Code mapping\n      mapLcMap = new HashMap<>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            mapLcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n\n\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","bugFix":["46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","pathOld":"solr/contrib/langid/src/java/org/apache/solr/update/processor/LanguageIdentifierUpdateProcessor#initParams(SolrParams).mjava","sourceNew":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Normalize detected langcode onto normalized langcode\n      lcMap = new HashMap<>();\n      if(params.get(LCMAP) != null) {\n        for(String mapping : params.get(LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.lcmap: {}. Skipping this mapping.\", mapping);\n          }\n        }\n      }\n\n      // Language Code mapping\n      mapLcMap = new HashMap<>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            mapLcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: {}. Skipping this mapping.\", mapping);\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      maxFieldValueChars = params.getInt(MAX_FIELD_VALUE_CHARS, MAX_FIELD_VALUE_CHARS_DEFAULT);\n      maxTotalChars = params.getInt(MAX_TOTAL_CHARS, MAX_TOTAL_CHARS_DEFAULT);\n      if (maxFieldValueChars > maxTotalChars) {\n        if (maxTotalChars == MAX_TOTAL_CHARS_DEFAULT) {\n          // If the user specified only maxFieldValueChars, make maxTotalChars the same as it\n          log.warn(\"{} ({}) is less than {} ({}).  Setting {} to {}.\"\n              , MAX_FIELD_VALUE_CHARS, maxFieldValueChars, MAX_TOTAL_CHARS\n              , maxTotalChars, MAX_TOTAL_CHARS, maxFieldValueChars);\n          maxTotalChars = maxFieldValueChars;\n        } else {\n          // If the user specified maxTotalChars, make maxFieldValueChars the same as it\n          log.warn(\"{} ({}) is less than {} ({}).  Setting {} to {}.\"\n              , MAX_FIELD_VALUE_CHARS, maxFieldValueChars, MAX_TOTAL_CHARS\n              , maxTotalChars, MAX_FIELD_VALUE_CHARS, maxTotalChars );\n          maxFieldValueChars = maxTotalChars;\n        }\n      }\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","sourceOld":"  private void initParams(SolrParams params) {\n    if (params != null) {\n      // Document-centric langId params\n      setEnabled(params.getBool(LANGUAGE_ID, true));\n      if(params.get(FIELDS_PARAM, \"\").length() > 0) {\n        inputFields = params.get(FIELDS_PARAM, \"\").split(\",\");\n      }\n      langField = params.get(LANG_FIELD, DOCID_LANGFIELD_DEFAULT);\n      langsField = params.get(LANGS_FIELD, DOCID_LANGSFIELD_DEFAULT);\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n      docIdField = params.get(DOCID_PARAM, uniqueKeyField == null ? DOCID_FIELD_DEFAULT : uniqueKeyField.getName());\n      fallbackValue = params.get(FALLBACK);\n      if(params.get(FALLBACK_FIELDS, \"\").length() > 0) {\n        fallbackFields = params.get(FALLBACK_FIELDS).split(\",\");\n      }\n      overwrite = params.getBool(OVERWRITE, false);\n      langWhitelist = new HashSet<>();\n      threshold = params.getDouble(THRESHOLD, DOCID_THRESHOLD_DEFAULT);\n      if(params.get(LANG_WHITELIST, \"\").length() > 0) {\n        for(String lang : params.get(LANG_WHITELIST, \"\").split(\",\")) {\n          langWhitelist.add(lang);\n        }\n      }\n\n      // Mapping params (field centric)\n      enableMapping = params.getBool(MAP_ENABLE, false);\n      if(params.get(MAP_FL, \"\").length() > 0) {\n        mapFields = params.get(MAP_FL, \"\").split(\",\");\n      } else {\n        mapFields = inputFields;\n      }\n      mapKeepOrig = params.getBool(MAP_KEEP_ORIG, false);\n      mapOverwrite = params.getBool(MAP_OVERWRITE, false);\n      mapIndividual = params.getBool(MAP_INDIVIDUAL, false);\n\n      // Process individual fields\n      String[] mapIndividualFields = {};\n      if(params.get(MAP_INDIVIDUAL_FL, \"\").length() > 0) {\n        mapIndividualFields = params.get(MAP_INDIVIDUAL_FL, \"\").split(\",\");\n      } else {\n        mapIndividualFields = mapFields;\n      }\n      mapIndividualFieldsSet = new HashSet<>(Arrays.asList(mapIndividualFields));\n      // Compile a union of the lists of fields to map\n      allMapFieldsSet = new HashSet<>(Arrays.asList(mapFields));\n      if(Arrays.equals(mapFields, mapIndividualFields)) {\n        allMapFieldsSet.addAll(mapIndividualFieldsSet);\n      }\n\n      // Normalize detected langcode onto normalized langcode\n      lcMap = new HashMap<>();\n      if(params.get(LCMAP) != null) {\n        for(String mapping : params.get(LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            lcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n\n      // Language Code mapping\n      mapLcMap = new HashMap<>();\n      if(params.get(MAP_LCMAP) != null) {\n        for(String mapping : params.get(MAP_LCMAP).split(\"[, ]\")) {\n          String[] keyVal = mapping.split(\":\");\n          if(keyVal.length == 2) {\n            mapLcMap.put(keyVal[0], keyVal[1]);\n          } else {\n            log.error(\"Unsupported format for langid.map.lcmap: \"+mapping+\". Skipping this mapping.\");\n          }\n        }\n      }\n      enforceSchema = params.getBool(ENFORCE_SCHEMA, true);\n\n      mapPattern = Pattern.compile(params.get(MAP_PATTERN, MAP_PATTERN_DEFAULT));\n      mapReplaceStr = params.get(MAP_REPLACE, MAP_REPLACE_DEFAULT);\n      maxFieldValueChars = params.getInt(MAX_FIELD_VALUE_CHARS, MAX_FIELD_VALUE_CHARS_DEFAULT);\n      maxTotalChars = params.getInt(MAX_TOTAL_CHARS, MAX_TOTAL_CHARS_DEFAULT);\n      if (maxFieldValueChars > maxTotalChars) {\n        if (maxTotalChars == MAX_TOTAL_CHARS_DEFAULT) {\n          // If the user specified only maxFieldValueChars, make maxTotalChars the same as it\n          log.warn(MAX_FIELD_VALUE_CHARS + \" (\" + maxFieldValueChars + \") is less than \" + MAX_TOTAL_CHARS + \" (\"\n              + maxTotalChars + \").  Setting \" + MAX_TOTAL_CHARS + \" to \" + maxFieldValueChars + \".\");\n          maxTotalChars = maxFieldValueChars;\n        } else {\n          // If the user specified maxTotalChars, make maxFieldValueChars the same as it\n          log.warn(MAX_FIELD_VALUE_CHARS + \" (\" + maxFieldValueChars + \") is less than \" + MAX_TOTAL_CHARS + \" (\"\n              + maxTotalChars + \").  Setting \" + MAX_FIELD_VALUE_CHARS + \" to \" + maxTotalChars + \".\");\n          maxFieldValueChars = maxTotalChars;\n        }\n      }\n    }\n    log.debug(\"LangId configured\");\n\n\n    if (inputFields.length == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n              \"Missing or faulty configuration of LanguageIdentifierUpdateProcessor. Input fields must be specified as a comma separated list\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["8d3ef1a6efd1b3a7ca06843b1165d8690dee94ee"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f","8d3ef1a6efd1b3a7ca06843b1165d8690dee94ee"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":["0f45f65b8ca4312a6880cc80396c35205dc21543","47aa44a85056dbdfdb00ae7342da74c0988bf1b7"],"47aa44a85056dbdfdb00ae7342da74c0988bf1b7":["0f45f65b8ca4312a6880cc80396c35205dc21543"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["3ff1a276d1c94e9393032df34ad607eda09ee3a6"],"8d3ef1a6efd1b3a7ca06843b1165d8690dee94ee":["46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f"],"46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f":["47aa44a85056dbdfdb00ae7342da74c0988bf1b7"],"aba371508186796cc6151d8223a5b4e16d02e26e":["0f45f65b8ca4312a6880cc80396c35205dc21543","47aa44a85056dbdfdb00ae7342da74c0988bf1b7"],"0f45f65b8ca4312a6880cc80396c35205dc21543":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"62e52115b56781006682fd92c6938efaf174304d":["47aa44a85056dbdfdb00ae7342da74c0988bf1b7","46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["0f45f65b8ca4312a6880cc80396c35205dc21543","47aa44a85056dbdfdb00ae7342da74c0988bf1b7"],"3ff1a276d1c94e9393032df34ad607eda09ee3a6":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3ff1a276d1c94e9393032df34ad607eda09ee3a6"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":[],"47aa44a85056dbdfdb00ae7342da74c0988bf1b7":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f","aba371508186796cc6151d8223a5b4e16d02e26e","62e52115b56781006682fd92c6938efaf174304d","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8d3ef1a6efd1b3a7ca06843b1165d8690dee94ee":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"46ae57a9ea3e7c9a47a3fc2548e1b32c060e3f8f":["37a0f60745e53927c4c876cfe5b5a58170f0646c","8d3ef1a6efd1b3a7ca06843b1165d8690dee94ee","62e52115b56781006682fd92c6938efaf174304d"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"0f45f65b8ca4312a6880cc80396c35205dc21543":["fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","47aa44a85056dbdfdb00ae7342da74c0988bf1b7","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"62e52115b56781006682fd92c6938efaf174304d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f45f65b8ca4312a6880cc80396c35205dc21543"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"3ff1a276d1c94e9393032df34ad607eda09ee3a6":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","aba371508186796cc6151d8223a5b4e16d02e26e","62e52115b56781006682fd92c6938efaf174304d","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}