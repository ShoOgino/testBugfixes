{"path":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","commits":[{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":1,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66c64e8cfded6a585100e6430238faaf416f3fea","date":1344964603,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","date":1346817835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPause) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n            Thread.sleep(roundPause);\n            Random random = LuceneTestCase.random();\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdd31721a25ce5c64c43a0fdb8a54eb36f7014a5","date":1383494058,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecca3a058d28b0a9fbd9458fa9196a9677ae5dcc","date":1385324410,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68fe0b7fa3b6a69495244529754954d2ae5cf0f7","date":1385414051,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final boolean startDeadPool, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n        if (startDeadPool) {\n          // starting down nodes\n          for (CloudJettyRunner jetty : deadPool) {\n            try {\n              if (jetty.jetty.isStopped()) ChaosMonkey.start(jetty.jetty);\n            } catch (Exception e) {\n              log.error(\"\", e);\n            }\n          }\n        }\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca","date":1385777952,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final boolean startDeadPool, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n        if (startDeadPool) {\n          // starting down nodes\n          for (CloudJettyRunner jetty : deadPool) {\n            try {\n              if (jetty.jetty.isStopped()) ChaosMonkey.start(jetty.jetty);\n            } catch (Exception e) {\n              log.error(\"\", e);\n            }\n          }\n        }\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (!ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1fdd9a08f8add7f8120c504fc73a542881f14db","date":1387820064,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (LuceneTestCase.random().nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on shutdown\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n    \n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"880ba9508bc60f5a45941227f966e69e521ead10","date":1390432381,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (LuceneTestCase.random().nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on shutdown\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n    \n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (LuceneTestCase.random().nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on shutdown\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n    \n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n      private List<CloudJettyRunner> deadPool = new ArrayList<CloudJettyRunner>();\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (LuceneTestCase.random().nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on close\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n    \n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (LuceneTestCase.random().nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on shutdown\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n    \n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (LuceneTestCase.random().nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on close\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n\n    this.aggressivelyKillLeaders = killLeaders;\n    runTimer = new RTimer();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + runTimer.getTime() / 1000 + \"s. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (LuceneTestCase.random().nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on close\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n    \n    this.aggressivelyKillLeaders = killLeaders;\n    startTime = System.currentTimeMillis();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + (System.currentTimeMillis() - startTime)/1000.0f + \"sec. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e373ca932bd347b9022c6fd6565e227010c6a9c","date":1458065865,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (chaosRandom.nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on close\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n\n    this.aggressivelyKillLeaders = killLeaders;\n    runTimer = new RTimer();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Thread.sleep(chaosRandom.nextInt(roundPauseUpperLimit));\n\n            causeSomeChaos();\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + runTimer.getTime() / 1000 + \"s. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (LuceneTestCase.random().nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on close\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n\n    this.aggressivelyKillLeaders = killLeaders;\n    runTimer = new RTimer();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Random random = LuceneTestCase.random();\n            Thread.sleep(random.nextInt(roundPauseUpperLimit));\n            if (random.nextBoolean()) {\n             if (!deadPool.isEmpty()) {\n               int index = random.nextInt(deadPool.size());\n               JettySolrRunner jetty = deadPool.get(index).jetty;\n               if (jetty.isStopped() && !ChaosMonkey.start(jetty)) {\n                 continue;\n               }\n               //System.out.println(\"started on port:\" + jetty.getLocalPort());\n               deadPool.remove(index);\n               starts.incrementAndGet();\n               continue;\n             }\n            }\n            \n            int rnd = random.nextInt(10);\n\n            if (expireSessions && rnd < EXPIRE_PERCENT) {\n              expireRandomSession();\n            } \n            \n            if (causeConnectionLoss && rnd < CONLOSS_PERCENT) {\n              randomConnectionLoss();\n            }\n            \n            CloudJettyRunner cjetty;\n            if (random.nextBoolean()) {\n              cjetty = stopRandomShard();\n            } else {\n              cjetty = killRandomShard();\n            }\n            if (cjetty == null) {\n              // we cannot kill\n            } else {\n              deadPool.add(cjetty);\n            }\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + runTimer.getTime() / 1000 + \"s. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1","date":1579200426,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/ChaosMonkey#startTheMonkey(boolean,int).mjava","sourceNew":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (chaosRandom.nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on close\");\n      TestInjection.skipIndexWriterCommitOnClose = true;\n    }\n\n    this.aggressivelyKillLeaders = killLeaders;\n    runTimer = new RTimer();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Thread.sleep(chaosRandom.nextInt(roundPauseUpperLimit));\n\n            causeSomeChaos();\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + runTimer.getTime() / 1000 + \"s. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","sourceOld":"  // synchronously starts and stops shards randomly, unless there is only one\n  // active shard up for a slice or if there is one active and others recovering\n  public void startTheMonkey(boolean killLeaders, final int roundPauseUpperLimit) {\n    if (!MONKEY_ENABLED) {\n      monkeyLog(\"The Monkey is disabled and will not start\");\n      return;\n    }\n    monkeyLog(\"starting\");\n    \n    \n    if (chaosRandom.nextBoolean()) {\n      monkeyLog(\"Jetty will not commit on close\");\n      DirectUpdateHandler2.commitOnClose = false;\n    }\n\n    this.aggressivelyKillLeaders = killLeaders;\n    runTimer = new RTimer();\n    // TODO: when kill leaders is on, lets kill a higher percentage of leaders\n    \n    stop = false;\n    monkeyThread = new Thread() {\n\n      @Override\n      public void run() {\n        while (!stop) {\n          try {\n    \n            Thread.sleep(chaosRandom.nextInt(roundPauseUpperLimit));\n\n            causeSomeChaos();\n            \n          } catch (InterruptedException e) {\n            //\n          } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n          }\n        }\n        monkeyLog(\"finished\");\n        monkeyLog(\"I ran for \" + runTimer.getTime() / 1000 + \"s. I stopped \" + stops + \" and I started \" + starts\n            + \". I also expired \" + expires.get() + \" and caused \" + connloss\n            + \" connection losses\");\n      }\n    };\n    monkeyThread.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"66c64e8cfded6a585100e6430238faaf416f3fea":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"6e373ca932bd347b9022c6fd6565e227010c6a9c":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"ecca3a058d28b0a9fbd9458fa9196a9677ae5dcc":["fdd31721a25ce5c64c43a0fdb8a54eb36f7014a5"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["c7869f64c874ebf7f317d22c00baf2b6857797a6","66c64e8cfded6a585100e6430238faaf416f3fea"],"a1fdd9a08f8add7f8120c504fc73a542881f14db":["7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca"],"880ba9508bc60f5a45941227f966e69e521ead10":["a1fdd9a08f8add7f8120c504fc73a542881f14db"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["66c64e8cfded6a585100e6430238faaf416f3fea"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d6f074e73200c07d54f242d3880a8da5a35ff97b","66c64e8cfded6a585100e6430238faaf416f3fea"],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["6e373ca932bd347b9022c6fd6565e227010c6a9c"],"7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca":["68fe0b7fa3b6a69495244529754954d2ae5cf0f7"],"a6378064655e76cd7b908b1cab4ce425b384b508":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"fdd31721a25ce5c64c43a0fdb8a54eb36f7014a5":["a6378064655e76cd7b908b1cab4ce425b384b508"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["880ba9508bc60f5a45941227f966e69e521ead10"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["fdd31721a25ce5c64c43a0fdb8a54eb36f7014a5","7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"68fe0b7fa3b6a69495244529754954d2ae5cf0f7":["ecca3a058d28b0a9fbd9458fa9196a9677ae5dcc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"66c64e8cfded6a585100e6430238faaf416f3fea":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"6e373ca932bd347b9022c6fd6565e227010c6a9c":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"ecca3a058d28b0a9fbd9458fa9196a9677ae5dcc":["68fe0b7fa3b6a69495244529754954d2ae5cf0f7"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"a1fdd9a08f8add7f8120c504fc73a542881f14db":["880ba9508bc60f5a45941227f966e69e521ead10"],"880ba9508bc60f5a45941227f966e69e521ead10":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["a6378064655e76cd7b908b1cab4ce425b384b508"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca":["a1fdd9a08f8add7f8120c504fc73a542881f14db","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"a6378064655e76cd7b908b1cab4ce425b384b508":["fdd31721a25ce5c64c43a0fdb8a54eb36f7014a5"],"fdd31721a25ce5c64c43a0fdb8a54eb36f7014a5":["ecca3a058d28b0a9fbd9458fa9196a9677ae5dcc","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","2c30e4c1cee08b3b229a77991882594fe7250b66"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["6e373ca932bd347b9022c6fd6565e227010c6a9c"],"68fe0b7fa3b6a69495244529754954d2ae5cf0f7":["7ecc0a3ce34111c2ebb18dc006e7f2f72d4162ca"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["66c64e8cfded6a585100e6430238faaf416f3fea","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}