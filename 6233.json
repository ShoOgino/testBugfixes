{"path":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","commits":[{"id":"ecc11368dc265bfdad90214f8bf5da99016ab1e2","date":1294144090,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c311a19ecb867db0c622832963dacea3e636f45","date":1300706617,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    String algTxt = runData.getConfig().getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    String taskPackage = PerfTask.class.getPackage().getName() + \".\";\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = Class.forName(taskPackage+s+\"Task\")\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm#Algorithm(PerfRunData).mjava","sourceNew":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","sourceOld":"  /**\n   * Read algorithm from file\n   * Property examined: alt.tasks.packages == comma separated list of \n   * alternate package names where tasks would be searched for, when not found \n   * in the default package (that of {@link PerfTask}{@link #getClass()}).\n   * If the same task class appears in more than one package, the package \n   * indicated first in this list will be used.\n   * @param runData perf-run-data used at running the tasks.\n   * @throws Exception if errors while parsing the algorithm \n   */\n  @SuppressWarnings(\"fallthrough\")\n  public Algorithm (PerfRunData runData) throws Exception {\n    Config config = runData.getConfig();\n    taskPackages = initTasksPackages(config);\n    String algTxt = config.getAlgorithmText();\n    sequence = new TaskSequence(runData,null,null,false);\n    TaskSequence currSequence = sequence;\n    PerfTask prevTask = null;\n    StreamTokenizer stok = new StreamTokenizer(new StringReader(algTxt));\n    stok.commentChar('#');\n    stok.eolIsSignificant(false);\n    stok.ordinaryChar('\"');\n    stok.ordinaryChar('/');\n    stok.ordinaryChar('(');\n    stok.ordinaryChar(')');\n    boolean colonOk = false; \n    boolean isDisableCountNextTask = false; // only for primitive tasks\n    currSequence.setDepth(0);\n    \n    while (stok.nextToken() != StreamTokenizer.TT_EOF) { \n      switch(stok.ttype) {\n  \n        case StreamTokenizer.TT_WORD:\n          String s = stok.sval;\n          Constructor<? extends PerfTask> cnstr = taskClass(config,s)\n            .asSubclass(PerfTask.class).getConstructor(PerfRunData.class);\n          PerfTask task = cnstr.newInstance(runData);\n          task.setDisableCounting(isDisableCountNextTask);\n          isDisableCountNextTask = false;\n          currSequence.addTask(task);\n          if (task instanceof RepSumByPrefTask) {\n            stok.nextToken();\n            String prefix = stok.sval;\n            if (prefix==null || prefix.length()==0) { \n              throw new Exception(\"named report prefix problem - \"+stok.toString()); \n            }\n            ((RepSumByPrefTask) task).setPrefix(prefix);\n          }\n          // check for task param: '(' someParam ')'\n          stok.nextToken();\n          if (stok.ttype!='(') {\n            stok.pushBack();\n          } else {\n            // get params, for tasks that supports them, - anything until next ')'\n            StringBuilder params = new StringBuilder();\n            stok.nextToken();\n            while (stok.ttype!=')') { \n              switch (stok.ttype) {\n                case StreamTokenizer.TT_NUMBER:  \n                  params.append(stok.nval);\n                  break;\n                case StreamTokenizer.TT_WORD:    \n                  params.append(stok.sval);             \n                  break;\n                case StreamTokenizer.TT_EOF:     \n                  throw new Exception(\"unexpexted EOF: - \"+stok.toString());\n                default:\n                  params.append((char)stok.ttype);\n              }\n              stok.nextToken();\n            }\n            String prm = params.toString().trim();\n            if (prm.length()>0) {\n              task.setParams(prm);\n            }\n          }\n\n          // ---------------------------------------\n          colonOk = false; prevTask = task;\n          break;\n  \n        default:\n          char c = (char)stok.ttype;\n          \n          switch(c) {\n          \n            case ':' :\n              if (!colonOk) throw new Exception(\"colon unexpexted: - \"+stok.toString());\n              colonOk = false;\n              // get repetitions number\n              stok.nextToken();\n              if ((char)stok.ttype == '*') {\n                ((TaskSequence)prevTask).setRepetitions(TaskSequence.REPEAT_EXHAUST);\n              } else {\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER)  {\n                  throw new Exception(\"expected repetitions number or XXXs: - \"+stok.toString());\n                } else {\n                  double num = stok.nval;\n                  stok.nextToken();\n                  if (stok.ttype == StreamTokenizer.TT_WORD && stok.sval.equals(\"s\")) {\n                    ((TaskSequence) prevTask).setRunTime(num);\n                  } else {\n                    stok.pushBack();\n                    ((TaskSequence) prevTask).setRepetitions((int) num);\n                  }\n                }\n              }\n              // check for rate specification (ops/min)\n              stok.nextToken();\n              if (stok.ttype!=':') {\n                stok.pushBack();\n              } else {\n                // get rate number\n                stok.nextToken();\n                if (stok.ttype!=StreamTokenizer.TT_NUMBER) throw new Exception(\"expected rate number: - \"+stok.toString());\n                // check for unit - min or sec, sec is default\n                stok.nextToken();\n                if (stok.ttype!='/') {\n                  stok.pushBack();\n                  ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                } else {\n                  stok.nextToken();\n                  if (stok.ttype!=StreamTokenizer.TT_WORD) throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  String unit = stok.sval.toLowerCase();\n                  if (\"min\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,true); // set rate per min\n                  } else if (\"sec\".equals(unit)) {\n                    ((TaskSequence)prevTask).setRate((int)stok.nval,false); // set rate per sec\n                  } else {\n                    throw new Exception(\"expected rate unit: 'min' or 'sec' - \"+stok.toString());\n                  }\n                }\n              }\n              colonOk = false;\n              break;\n    \n            case '{' : \n            case '[' :  \n              // a sequence\n              // check for sequence name\n              String name = null;\n              stok.nextToken();\n              if (stok.ttype!='\"') {\n                stok.pushBack();\n              } else {\n                stok.nextToken();\n                name = stok.sval;\n                stok.nextToken();\n                if (stok.ttype!='\"' || name==null || name.length()==0) { \n                  throw new Exception(\"sequence name problem - \"+stok.toString()); \n                }\n              }\n              // start the sequence\n              TaskSequence seq2 = new TaskSequence(runData, name, currSequence, c=='[');\n              currSequence.addTask(seq2);\n              currSequence = seq2;\n              colonOk = false;\n              break;\n\n            case '&' :\n              if (currSequence.isParallel()) {\n                throw new Exception(\"Can only create background tasks within a serial task\");\n              }\n              stok.nextToken();\n              final int deltaPri;\n              if (stok.ttype != StreamTokenizer.TT_NUMBER) {\n                stok.pushBack();\n                deltaPri = 0;\n              } else {\n                // priority\n                deltaPri = (int) stok.nval;\n              }\n\n              if (prevTask == null) {\n                throw new Exception(\"& was unexpected\");\n              } else if (prevTask.getRunInBackground()) {\n                throw new Exception(\"double & was unexpected\");\n              } else {\n                prevTask.setRunInBackground(deltaPri);\n              }\n              break;\n    \n            case '>' :\n              currSequence.setNoChildReport(); /* intentional fallthrough */\n            case '}' : \n            case ']' : \n              // end sequence\n              colonOk = true; prevTask = currSequence;\n              currSequence = currSequence.getParent();\n              break;\n          \n            case '-' :\n              isDisableCountNextTask = true;\n              break;\n              \n          } //switch(c)\n          break;\n          \n      } //switch(stok.ttype)\n      \n    }\n    \n    if (sequence != currSequence) {\n      throw new Exception(\"Unmatched sequences\");\n    }\n    \n    // remove redundant top level enclosing sequences\n    while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {\n      ArrayList<PerfTask> t = sequence.getTasks();\n      if (t!=null && t.size()==1) {\n        PerfTask p = t.get(0);\n        if (p instanceof TaskSequence) {\n          sequence = (TaskSequence) p;\n          continue;\n        }\n      }\n      break;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["7c311a19ecb867db0c622832963dacea3e636f45"],"7c311a19ecb867db0c622832963dacea3e636f45":["ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"ecc11368dc265bfdad90214f8bf5da99016ab1e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["868da859b43505d9d2a023bfeae6dd0c795f5295","7c311a19ecb867db0c622832963dacea3e636f45"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["70ad682703b8585f5d0a637efec044d57ec05efb","7c311a19ecb867db0c622832963dacea3e636f45"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"ecc11368dc265bfdad90214f8bf5da99016ab1e2":["70ad682703b8585f5d0a637efec044d57ec05efb","7c311a19ecb867db0c622832963dacea3e636f45","868da859b43505d9d2a023bfeae6dd0c795f5295"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c311a19ecb867db0c622832963dacea3e636f45":["b89678825b68eccaf09e6ab71675fc0b0af1e099","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"d619839baa8ce5503e496b94a9e42ad6f079293f":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70ad682703b8585f5d0a637efec044d57ec05efb","ecc11368dc265bfdad90214f8bf5da99016ab1e2","868da859b43505d9d2a023bfeae6dd0c795f5295"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}