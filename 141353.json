{"path":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","commits":[{"id":"97e30c53fd81463c6ccd52402c91a6548cf42acb","date":1309296018,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, Field.Store.YES, Field.Index.NOT_ANALYZED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", Field.Index.NOT_ANALYZED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             Field.Index.NOT_ANALYZED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, Field.Store.YES, Field.Index.NOT_ANALYZED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               Field.Index.NOT_ANALYZED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = new IndexSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2","71da933d30aea361ccc224d6544c451cbf49916d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, Field.Store.YES, Field.Index.NOT_ANALYZED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", Field.Index.NOT_ANALYZED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             Field.Index.NOT_ANALYZED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, Field.Store.YES, Field.Index.NOT_ANALYZED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               Field.Index.NOT_ANALYZED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = new IndexSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, Field.Store.YES, Field.Index.NOT_ANALYZED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", Field.Index.NOT_ANALYZED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             Field.Index.NOT_ANALYZED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, Field.Store.YES, Field.Index.NOT_ANALYZED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               Field.Index.NOT_ANALYZED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = new IndexSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = new IndexSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, Field.Store.YES, Field.Index.NOT_ANALYZED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", Field.Index.NOT_ANALYZED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             Field.Index.NOT_ANALYZED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, Field.Store.YES, Field.Index.NOT_ANALYZED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               Field.Index.NOT_ANALYZED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = new IndexSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6442a1e611a2a329dd4725e0419ea23d118b89b3","date":1322422217,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = new IndexSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = new IndexSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"75f259c6440904f8e40d4e1690aba0b3d616bef4","date":1322423560,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    s.close();\n    r.close();\n    joinS.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f76ccdfca879f9e8881676ce0fb611f44c0f07a2","date":1322905997,"type":5,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    s.close();\n    r.close();\n    joinS.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    s.close();\n    r.close();\n    joinS.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"6442a1e611a2a329dd4725e0419ea23d118b89b3":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"97e30c53fd81463c6ccd52402c91a6548cf42acb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"75f259c6440904f8e40d4e1690aba0b3d616bef4":["6442a1e611a2a329dd4725e0419ea23d118b89b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["97e30c53fd81463c6ccd52402c91a6548cf42acb"],"f76ccdfca879f9e8881676ce0fb611f44c0f07a2":["75f259c6440904f8e40d4e1690aba0b3d616bef4"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","97e30c53fd81463c6ccd52402c91a6548cf42acb"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","97e30c53fd81463c6ccd52402c91a6548cf42acb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f76ccdfca879f9e8881676ce0fb611f44c0f07a2"]},"commit2Childs":{"6442a1e611a2a329dd4725e0419ea23d118b89b3":["75f259c6440904f8e40d4e1690aba0b3d616bef4"],"97e30c53fd81463c6ccd52402c91a6548cf42acb":["1509f151d7692d84fae414b2b799ac06ba60fcb4","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"75f259c6440904f8e40d4e1690aba0b3d616bef4":["f76ccdfca879f9e8881676ce0fb611f44c0f07a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["97e30c53fd81463c6ccd52402c91a6548cf42acb","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["6442a1e611a2a329dd4725e0419ea23d118b89b3"],"f76ccdfca879f9e8881676ce0fb611f44c0f07a2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}