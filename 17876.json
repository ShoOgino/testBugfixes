{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter#BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int,int,int).mjava","commits":[{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter#BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min.\n   *  For DOCS_ONLY fields, this terms dictionary will\n   *  insert automatically generated prefix terms for common\n   *  prefixes, as long as each prefix matches at least\n   *  {@code minItemsInAutoPrefix} other terms or prefixes,\n   *  and at most {@code maxItemsInAutoPrefix} other terms\n   *  or prefixes.  Set {@code minItemsInAutoPrefix} to 0\n   *  to disable auto-prefix terms. */\n  public BlockTreeTermsWriter(SegmentWriteState state,\n                              PostingsWriterBase postingsWriter,\n                              int minItemsInBlock,\n                              int maxItemsInBlock,\n                              int minItemsInAutoPrefix,\n                              int maxItemsInAutoPrefix)\n    throws IOException\n  {\n    validateSettings(minItemsInBlock,\n                     maxItemsInBlock);\n\n    this.minItemsInBlock = minItemsInBlock;\n    this.maxItemsInBlock = maxItemsInBlock;\n\n    validateAutoPrefixSettings(minItemsInAutoPrefix,\n                               maxItemsInAutoPrefix);\n\n    if (minItemsInAutoPrefix != 0) {\n      // TODO: can we used compressed bitset instead?  that auto-upgrades if it's dense enough...\n      prefixDocs = new FixedBitSet(state.segmentInfo.maxDoc());\n      prefixFixedBitsTermsEnum = new BitSetTermsEnum(prefixDocs);\n    } else {\n      prefixDocs = null;\n      prefixFixedBitsTermsEnum = null;\n    }\n\n    this.minItemsInAutoPrefix = minItemsInAutoPrefix;\n    this.maxItemsInAutoPrefix = maxItemsInAutoPrefix;\n\n    this.maxDoc = state.segmentInfo.maxDoc();\n    this.fieldInfos = state.fieldInfos;\n    this.postingsWriter = postingsWriter;\n\n    final String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_EXTENSION);\n    termsOut = state.directory.createOutput(termsName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      CodecUtil.writeIndexHeader(termsOut, BlockTreeTermsReader.TERMS_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n\n      final String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(indexOut, BlockTreeTermsReader.TERMS_INDEX_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n      //segment = state.segmentInfo.name;\n\n      postingsWriter.init(termsOut, state);                          // have consumer write its format/header\n      \n      this.indexOut = indexOut;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(termsOut, indexOut);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter#BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min.\n   *  For DOCS_ONLY fields, this terms dictionary will\n   *  insert automatically generated prefix terms for common\n   *  prefixes, as long as each prefix matches at least\n   *  {@code minItemsInAutoPrefix} other terms or prefixes,\n   *  and at most {@code maxItemsInAutoPrefix} other terms\n   *  or prefixes.  Set {@code minItemsInAutoPrefix} to 0\n   *  to disable auto-prefix terms. */\n  public BlockTreeTermsWriter(SegmentWriteState state,\n                              PostingsWriterBase postingsWriter,\n                              int minItemsInBlock,\n                              int maxItemsInBlock,\n                              int minItemsInAutoPrefix,\n                              int maxItemsInAutoPrefix)\n    throws IOException\n  {\n    validateSettings(minItemsInBlock,\n                     maxItemsInBlock);\n\n    this.minItemsInBlock = minItemsInBlock;\n    this.maxItemsInBlock = maxItemsInBlock;\n\n    validateAutoPrefixSettings(minItemsInAutoPrefix,\n                               maxItemsInAutoPrefix);\n\n    if (minItemsInAutoPrefix != 0) {\n      // TODO: can we used compressed bitset instead?  that auto-upgrades if it's dense enough...\n      prefixDocs = new FixedBitSet(state.segmentInfo.maxDoc());\n      prefixFixedBitsTermsEnum = new BitSetTermsEnum(prefixDocs);\n    } else {\n      prefixDocs = null;\n      prefixFixedBitsTermsEnum = null;\n    }\n\n    this.minItemsInAutoPrefix = minItemsInAutoPrefix;\n    this.maxItemsInAutoPrefix = maxItemsInAutoPrefix;\n\n    this.maxDoc = state.segmentInfo.maxDoc();\n    this.fieldInfos = state.fieldInfos;\n    this.postingsWriter = postingsWriter;\n\n    final String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_EXTENSION);\n    termsOut = state.directory.createOutput(termsName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      CodecUtil.writeIndexHeader(termsOut, BlockTreeTermsReader.TERMS_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n\n      final String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(indexOut, BlockTreeTermsReader.TERMS_INDEX_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n      //segment = state.segmentInfo.name;\n\n      postingsWriter.init(termsOut, state);                          // have consumer write its format/header\n      \n      this.indexOut = indexOut;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(termsOut, indexOut);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59db5e5f780185e0155d296a323e440a6ecfd3b6","date":1435089559,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter#BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter#BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int,int,int).mjava","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min.\n   *  For DOCS_ONLY fields, this terms dictionary will\n   *  insert automatically generated prefix terms for common\n   *  prefixes, as long as each prefix matches at least\n   *  {@code minItemsInAutoPrefix} other terms or prefixes,\n   *  and at most {@code maxItemsInAutoPrefix} other terms\n   *  or prefixes.  Set {@code minItemsInAutoPrefix} to 0\n   *  to disable auto-prefix terms. */\n  public BlockTreeTermsWriter(SegmentWriteState state,\n                              PostingsWriterBase postingsWriter,\n                              int minItemsInBlock,\n                              int maxItemsInBlock,\n                              int minItemsInAutoPrefix,\n                              int maxItemsInAutoPrefix)\n    throws IOException\n  {\n    validateSettings(minItemsInBlock,\n                     maxItemsInBlock);\n\n    this.minItemsInBlock = minItemsInBlock;\n    this.maxItemsInBlock = maxItemsInBlock;\n\n    validateAutoPrefixSettings(minItemsInAutoPrefix,\n                               maxItemsInAutoPrefix);\n\n    if (minItemsInAutoPrefix != 0) {\n      // TODO: can we used compressed bitset instead?  that auto-upgrades if it's dense enough...\n      prefixDocs = new FixedBitSet(state.segmentInfo.maxDoc());\n      prefixFixedBitsTermsEnum = new BitSetTermsEnum(prefixDocs);\n    } else {\n      prefixDocs = null;\n      prefixFixedBitsTermsEnum = null;\n    }\n\n    this.minItemsInAutoPrefix = minItemsInAutoPrefix;\n    this.maxItemsInAutoPrefix = maxItemsInAutoPrefix;\n\n    this.maxDoc = state.segmentInfo.maxDoc();\n    this.fieldInfos = state.fieldInfos;\n    this.postingsWriter = postingsWriter;\n\n    final String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_EXTENSION);\n    termsOut = state.directory.createOutput(termsName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      CodecUtil.writeIndexHeader(termsOut, BlockTreeTermsReader.TERMS_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n\n      // So at read time we know, globally, that there will be no auto-prefix terms:\n      if (minItemsInAutoPrefix == 0) {\n        termsOut.writeByte((byte) 0);\n      } else {\n        termsOut.writeByte((byte) 1);\n      }\n\n      final String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(indexOut, BlockTreeTermsReader.TERMS_INDEX_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n      //segment = state.segmentInfo.name;\n\n      postingsWriter.init(termsOut, state);                          // have consumer write its format/header\n      \n      this.indexOut = indexOut;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(termsOut, indexOut);\n      }\n    }\n  }\n\n","sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min.\n   *  For DOCS_ONLY fields, this terms dictionary will\n   *  insert automatically generated prefix terms for common\n   *  prefixes, as long as each prefix matches at least\n   *  {@code minItemsInAutoPrefix} other terms or prefixes,\n   *  and at most {@code maxItemsInAutoPrefix} other terms\n   *  or prefixes.  Set {@code minItemsInAutoPrefix} to 0\n   *  to disable auto-prefix terms. */\n  public BlockTreeTermsWriter(SegmentWriteState state,\n                              PostingsWriterBase postingsWriter,\n                              int minItemsInBlock,\n                              int maxItemsInBlock,\n                              int minItemsInAutoPrefix,\n                              int maxItemsInAutoPrefix)\n    throws IOException\n  {\n    validateSettings(minItemsInBlock,\n                     maxItemsInBlock);\n\n    this.minItemsInBlock = minItemsInBlock;\n    this.maxItemsInBlock = maxItemsInBlock;\n\n    validateAutoPrefixSettings(minItemsInAutoPrefix,\n                               maxItemsInAutoPrefix);\n\n    if (minItemsInAutoPrefix != 0) {\n      // TODO: can we used compressed bitset instead?  that auto-upgrades if it's dense enough...\n      prefixDocs = new FixedBitSet(state.segmentInfo.maxDoc());\n      prefixFixedBitsTermsEnum = new BitSetTermsEnum(prefixDocs);\n    } else {\n      prefixDocs = null;\n      prefixFixedBitsTermsEnum = null;\n    }\n\n    this.minItemsInAutoPrefix = minItemsInAutoPrefix;\n    this.maxItemsInAutoPrefix = maxItemsInAutoPrefix;\n\n    this.maxDoc = state.segmentInfo.maxDoc();\n    this.fieldInfos = state.fieldInfos;\n    this.postingsWriter = postingsWriter;\n\n    final String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_EXTENSION);\n    termsOut = state.directory.createOutput(termsName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      CodecUtil.writeIndexHeader(termsOut, BlockTreeTermsReader.TERMS_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n\n      final String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(indexOut, BlockTreeTermsReader.TERMS_INDEX_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n      //segment = state.segmentInfo.name;\n\n      postingsWriter.init(termsOut, state);                          // have consumer write its format/header\n      \n      this.indexOut = indexOut;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(termsOut, indexOut);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","date":1466407389,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter#BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int,int,int).mjava","sourceNew":null,"sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min.\n   *  For DOCS_ONLY fields, this terms dictionary will\n   *  insert automatically generated prefix terms for common\n   *  prefixes, as long as each prefix matches at least\n   *  {@code minItemsInAutoPrefix} other terms or prefixes,\n   *  and at most {@code maxItemsInAutoPrefix} other terms\n   *  or prefixes.  Set {@code minItemsInAutoPrefix} to 0\n   *  to disable auto-prefix terms. */\n  public BlockTreeTermsWriter(SegmentWriteState state,\n                              PostingsWriterBase postingsWriter,\n                              int minItemsInBlock,\n                              int maxItemsInBlock,\n                              int minItemsInAutoPrefix,\n                              int maxItemsInAutoPrefix)\n    throws IOException\n  {\n    validateSettings(minItemsInBlock,\n                     maxItemsInBlock);\n\n    this.minItemsInBlock = minItemsInBlock;\n    this.maxItemsInBlock = maxItemsInBlock;\n\n    validateAutoPrefixSettings(minItemsInAutoPrefix,\n                               maxItemsInAutoPrefix);\n\n    if (minItemsInAutoPrefix != 0) {\n      // TODO: can we used compressed bitset instead?  that auto-upgrades if it's dense enough...\n      prefixDocs = new FixedBitSet(state.segmentInfo.maxDoc());\n      prefixFixedBitsTermsEnum = new BitSetTermsEnum(prefixDocs);\n    } else {\n      prefixDocs = null;\n      prefixFixedBitsTermsEnum = null;\n    }\n\n    this.minItemsInAutoPrefix = minItemsInAutoPrefix;\n    this.maxItemsInAutoPrefix = maxItemsInAutoPrefix;\n\n    this.maxDoc = state.segmentInfo.maxDoc();\n    this.fieldInfos = state.fieldInfos;\n    this.postingsWriter = postingsWriter;\n\n    final String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_EXTENSION);\n    termsOut = state.directory.createOutput(termsName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      CodecUtil.writeIndexHeader(termsOut, BlockTreeTermsReader.TERMS_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n\n      // So at read time we know, globally, that there will be no auto-prefix terms:\n      if (minItemsInAutoPrefix == 0) {\n        termsOut.writeByte((byte) 0);\n      } else {\n        termsOut.writeByte((byte) 1);\n      }\n\n      final String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(indexOut, BlockTreeTermsReader.TERMS_INDEX_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n      //segment = state.segmentInfo.name;\n\n      postingsWriter.init(termsOut, state);                          // have consumer write its format/header\n      \n      this.indexOut = indexOut;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(termsOut, indexOut);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter#BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int,int,int).mjava","sourceNew":null,"sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min.\n   *  For DOCS_ONLY fields, this terms dictionary will\n   *  insert automatically generated prefix terms for common\n   *  prefixes, as long as each prefix matches at least\n   *  {@code minItemsInAutoPrefix} other terms or prefixes,\n   *  and at most {@code maxItemsInAutoPrefix} other terms\n   *  or prefixes.  Set {@code minItemsInAutoPrefix} to 0\n   *  to disable auto-prefix terms. */\n  public BlockTreeTermsWriter(SegmentWriteState state,\n                              PostingsWriterBase postingsWriter,\n                              int minItemsInBlock,\n                              int maxItemsInBlock,\n                              int minItemsInAutoPrefix,\n                              int maxItemsInAutoPrefix)\n    throws IOException\n  {\n    validateSettings(minItemsInBlock,\n                     maxItemsInBlock);\n\n    this.minItemsInBlock = minItemsInBlock;\n    this.maxItemsInBlock = maxItemsInBlock;\n\n    validateAutoPrefixSettings(minItemsInAutoPrefix,\n                               maxItemsInAutoPrefix);\n\n    if (minItemsInAutoPrefix != 0) {\n      // TODO: can we used compressed bitset instead?  that auto-upgrades if it's dense enough...\n      prefixDocs = new FixedBitSet(state.segmentInfo.maxDoc());\n      prefixFixedBitsTermsEnum = new BitSetTermsEnum(prefixDocs);\n    } else {\n      prefixDocs = null;\n      prefixFixedBitsTermsEnum = null;\n    }\n\n    this.minItemsInAutoPrefix = minItemsInAutoPrefix;\n    this.maxItemsInAutoPrefix = maxItemsInAutoPrefix;\n\n    this.maxDoc = state.segmentInfo.maxDoc();\n    this.fieldInfos = state.fieldInfos;\n    this.postingsWriter = postingsWriter;\n\n    final String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_EXTENSION);\n    termsOut = state.directory.createOutput(termsName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      CodecUtil.writeIndexHeader(termsOut, BlockTreeTermsReader.TERMS_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n\n      // So at read time we know, globally, that there will be no auto-prefix terms:\n      if (minItemsInAutoPrefix == 0) {\n        termsOut.writeByte((byte) 0);\n      } else {\n        termsOut.writeByte((byte) 1);\n      }\n\n      final String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(indexOut, BlockTreeTermsReader.TERMS_INDEX_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n      //segment = state.segmentInfo.name;\n\n      postingsWriter.init(termsOut, state);                          // have consumer write its format/header\n      \n      this.indexOut = indexOut;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(termsOut, indexOut);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter#BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int,int,int).mjava","sourceNew":null,"sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min.\n   *  For DOCS_ONLY fields, this terms dictionary will\n   *  insert automatically generated prefix terms for common\n   *  prefixes, as long as each prefix matches at least\n   *  {@code minItemsInAutoPrefix} other terms or prefixes,\n   *  and at most {@code maxItemsInAutoPrefix} other terms\n   *  or prefixes.  Set {@code minItemsInAutoPrefix} to 0\n   *  to disable auto-prefix terms. */\n  public BlockTreeTermsWriter(SegmentWriteState state,\n                              PostingsWriterBase postingsWriter,\n                              int minItemsInBlock,\n                              int maxItemsInBlock,\n                              int minItemsInAutoPrefix,\n                              int maxItemsInAutoPrefix)\n    throws IOException\n  {\n    validateSettings(minItemsInBlock,\n                     maxItemsInBlock);\n\n    this.minItemsInBlock = minItemsInBlock;\n    this.maxItemsInBlock = maxItemsInBlock;\n\n    validateAutoPrefixSettings(minItemsInAutoPrefix,\n                               maxItemsInAutoPrefix);\n\n    if (minItemsInAutoPrefix != 0) {\n      // TODO: can we used compressed bitset instead?  that auto-upgrades if it's dense enough...\n      prefixDocs = new FixedBitSet(state.segmentInfo.maxDoc());\n      prefixFixedBitsTermsEnum = new BitSetTermsEnum(prefixDocs);\n    } else {\n      prefixDocs = null;\n      prefixFixedBitsTermsEnum = null;\n    }\n\n    this.minItemsInAutoPrefix = minItemsInAutoPrefix;\n    this.maxItemsInAutoPrefix = maxItemsInAutoPrefix;\n\n    this.maxDoc = state.segmentInfo.maxDoc();\n    this.fieldInfos = state.fieldInfos;\n    this.postingsWriter = postingsWriter;\n\n    final String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_EXTENSION);\n    termsOut = state.directory.createOutput(termsName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      CodecUtil.writeIndexHeader(termsOut, BlockTreeTermsReader.TERMS_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n\n      // So at read time we know, globally, that there will be no auto-prefix terms:\n      if (minItemsInAutoPrefix == 0) {\n        termsOut.writeByte((byte) 0);\n      } else {\n        termsOut.writeByte((byte) 1);\n      }\n\n      final String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockTreeTermsReader.TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(indexOut, BlockTreeTermsReader.TERMS_INDEX_CODEC_NAME, BlockTreeTermsReader.VERSION_CURRENT,\n                                 state.segmentInfo.getId(), state.segmentSuffix);\n      //segment = state.segmentInfo.name;\n\n      postingsWriter.init(termsOut, state);                          // have consumer write its format/header\n      \n      this.indexOut = indexOut;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(termsOut, indexOut);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"59db5e5f780185e0155d296a323e440a6ecfd3b6":["3e8715d826e588419327562287d5d6a8040d63d6"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["59db5e5f780185e0155d296a323e440a6ecfd3b6","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["59db5e5f780185e0155d296a323e440a6ecfd3b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["59db5e5f780185e0155d296a323e440a6ecfd3b6","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"]},"commit2Childs":{"59db5e5f780185e0155d296a323e440a6ecfd3b6":["6aaba221b22442bdf0ef28770c25fe259dfb3f55","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["59db5e5f780185e0155d296a323e440a6ecfd3b6","d2638f781be724518ff6c2263d14a48cf6e68017"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}