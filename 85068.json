{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#test().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n    versionToTransLogLocation.put(1L, 0L);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        message(\"top: now flush primary\");\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n\n          long result;\n          try {\n            result = primary.flush();\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n    versionToTransLogLocation.put(1L, 0L);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        message(\"top: now flush primary\");\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n\n          long result;\n          try {\n            result = primary.flush();\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n    versionToTransLogLocation.put(1L, 0L);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        message(\"top: now flush primary\");\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n\n          long result;\n          try {\n            result = primary.flush();\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}