{"path":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","commits":[{"id":"2a282020d6c9a4ea32a359539e283e4771a2fda8","date":1440047542,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertTrue(dq.hasWatcher());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertFalse(dq.hasWatcher());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6321195fe07e4a4627b4f36c48221de10cb6c26e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6321195fe07e4a4627b4f36c48221de10cb6c26e","date":1492541055,"type":3,"author":"Scott Blum","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertTrue(dq.hasWatcher());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertFalse(dq.hasWatcher());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","bugFix":["2a282020d6c9a4ea32a359539e283e4771a2fda8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertTrue(dq.hasWatcher());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertFalse(dq.hasWatcher());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    ZkDistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    ZkDistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e","date":1505888025,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    ZkDistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    ZkDistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    DistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24b4bc514a94d4fbd1d02559c4160d1053b5482b","date":1544540322,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    ZkDistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    \n    TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeout.waitFor(\"Timeout waiting to see dirty=false\", () -> {\n      try {\n        return !dq.isDirty();\n      } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n      }\n    });\n    \n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    ZkDistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e0abaca9e5481b5c3660805111683e8ce53bef3","date":1544554124,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DistributedQueueTest#testDistributedQueueBlocking().mjava","sourceNew":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    ZkDistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    \n    TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeout.waitFor(\"Timeout waiting to see dirty=false\", () -> {\n      try {\n        return !dq.isDirty();\n      } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n      }\n    });\n    \n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","sourceOld":"  @Test\n  public void testDistributedQueueBlocking() throws Exception {\n    String dqZNode = \"/distqueue/test\";\n    String testData = \"hello world\";\n\n    ZkDistributedQueue dq = makeDistributedQueue(dqZNode);\n\n    assertNull(dq.peek());\n    Future<String> future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n\n    // After draining the queue, a watcher should be set.\n    assertNull(dq.peek(100));\n    assertFalse(dq.isDirty());\n    assertEquals(1, dq.watcherCount());\n\n    forceSessionExpire();\n\n    // Session expiry should have fired the watcher.\n    Thread.sleep(100);\n    assertTrue(dq.isDirty());\n    assertEquals(0, dq.watcherCount());\n\n    // Rerun the earlier test make sure updates are still seen, post reconnection.\n    future = executor.submit(() -> new String(dq.peek(true), UTF8));\n    try {\n      future.get(1000, TimeUnit.MILLISECONDS);\n      fail(\"TimeoutException expected\");\n    } catch (TimeoutException expected) {\n      assertFalse(future.isDone());\n    }\n\n    // Ultimately trips the watcher, triggering child refresh\n    dq.offer(testData.getBytes(UTF8));\n    assertEquals(testData, future.get(1000, TimeUnit.MILLISECONDS));\n    assertNotNull(dq.poll());\n    assertNull(dq.poll());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["2a282020d6c9a4ea32a359539e283e4771a2fda8"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["b869898f50ca80263bac2e3ae0949f7700e5c977","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["6321195fe07e4a4627b4f36c48221de10cb6c26e"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"2a282020d6c9a4ea32a359539e283e4771a2fda8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"24b4bc514a94d4fbd1d02559c4160d1053b5482b":["89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"7e0abaca9e5481b5c3660805111683e8ce53bef3":["89c102d671c256ef8dd67b3ecb3ab96fe7a8006e","24b4bc514a94d4fbd1d02559c4160d1053b5482b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7e0abaca9e5481b5c3660805111683e8ce53bef3"],"6321195fe07e4a4627b4f36c48221de10cb6c26e":["2a282020d6c9a4ea32a359539e283e4771a2fda8"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2a282020d6c9a4ea32a359539e283e4771a2fda8"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["6240b74b884c5587f2a4062dd27d6c32bf228889","24b4bc514a94d4fbd1d02559c4160d1053b5482b","7e0abaca9e5481b5c3660805111683e8ce53bef3"],"2a282020d6c9a4ea32a359539e283e4771a2fda8":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","6321195fe07e4a4627b4f36c48221de10cb6c26e"],"24b4bc514a94d4fbd1d02559c4160d1053b5482b":["7e0abaca9e5481b5c3660805111683e8ce53bef3"],"7e0abaca9e5481b5c3660805111683e8ce53bef3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6321195fe07e4a4627b4f36c48221de10cb6c26e":["89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}