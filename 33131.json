{"path":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(4000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        \n        for (int i = 1; i < atLeast(15); i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(6000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    connLossThread.join();\n    killThread.join();\n    \n    scheduler.shutdownNow();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    assertFalse(\"seq is -1 and we may have a zombie leader\", seq == -1);\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["be9f7175e1703e31f8d8de32612b7212db6acf76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(4000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        \n        for (int i = 1; i < atLeast(15); i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(6000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    connLossThread.join();\n    killThread.join();\n    \n    scheduler.shutdownNow();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    assertFalse(\"seq is -1 and we may have a zombie leader\", seq == -1);\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(4000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        \n        for (int i = 1; i < atLeast(15); i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(6000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    connLossThread.join();\n    killThread.join();\n    \n    scheduler.shutdownNow();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    assertFalse(\"seq is -1 and we may have a zombie leader\", seq == -1);\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"336850123198c8df23821aa53cba096f414d0d24","date":1327716209,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(4000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        \n        for (int i = 1; i < atLeast(15); i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(6000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    assertFalse(\"seq is -1 and we may have a zombie leader\", seq == -1);\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(4000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        \n        for (int i = 1; i < atLeast(15); i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(6000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    connLossThread.join();\n    killThread.join();\n    \n    scheduler.shutdownNow();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    assertFalse(\"seq is -1 and we may have a zombie leader\", seq == -1);\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b2ece5a89a03cd987c5680eee13aaa2139290cfd","date":1327719826,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(4000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        \n        for (int i = 1; i < atLeast(15); i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(6000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    assertFalse(\"seq is -1 and we may have a zombie leader\", seq == -1);\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","date":1327763052,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(4000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        \n        for (int i = 1; i < atLeast(15); i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(6000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    connLossThread.join();\n    killThread.join();\n    \n    scheduler.shutdownNow();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    assertFalse(\"seq is -1 and we may have a zombie leader\", seq == -1);\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(4000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        \n        for (int i = 1; i < atLeast(15); i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(6000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    connLossThread.join();\n    killThread.join();\n    \n    scheduler.shutdownNow();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    assertFalse(\"seq is -1 and we may have a zombie leader\", seq == -1);\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random.nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random.nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random.nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c8719b2c0b382be11f5b193b6fc14bc310e906b","date":1344770591,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15);\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n            \n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e","date":1406603075,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (InterruptedException e) {\n              throw e;\n            } catch (Exception e) {\n              \n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":["be9f7175e1703e31f8d8de32612b7212db6acf76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be9f7175e1703e31f8d8de32612b7212db6acf76","date":1408660152,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().closeCnxn();\n              if (random().nextBoolean()) {\n                long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n                server.expire(sessionId);\n              }\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().pauseCnxn(\n                  ZkTestServer.TICK_TIME * 2);\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    \n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().closeCnxn();\n              if (random().nextBoolean()) {\n                long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n                server.expire(sessionId);\n              }\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    Thread.sleep(2000);\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().closeCnxn();\n              if (random().nextBoolean()) {\n                long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n                server.expire(sessionId);\n              }\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":["b2ece5a89a03cd987c5680eee13aaa2139290cfd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n\n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n\n\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n\n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n\n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n\n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n\n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().closeCnxn();\n              if (random().nextBoolean()) {\n                long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n                server.expire(sessionId);\n              }\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n\n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n\n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n\n    Thread.sleep(4000);\n\n    stopStress = true;\n\n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n\n    scheduleThread.join();\n    scheduler.shutdownNow();\n\n    connLossThread.join();\n    killThread.join();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n\n    // we have a leader we know, TODO: lets check some other things\n\n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n    \n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n    \n    \n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n    \n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n    \n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n        \n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().closeCnxn();\n              if (random().nextBoolean()) {\n                long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n                server.expire(sessionId);\n              }\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n            \n          } catch (Exception e) {\n            \n          }\n        }\n      }\n    };\n    \n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n    \n    Thread.sleep(4000);\n    \n    stopStress = true;\n    \n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n    \n    scheduleThread.join();\n    scheduler.shutdownNow();\n    \n    connLossThread.join();\n    killThread.join();\n    \n    int seq = threads.get(getLeaderThread()).getSeq();\n    \n    // we have a leader we know, TODO: lets check some other things\n    \n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n    \n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest#testStressElection().mjava","sourceNew":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new SolrNamedThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n\n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n\n\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n\n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n\n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n\n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n\n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().closeCnxn();\n              if (random().nextBoolean()) {\n                long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n                server.expire(sessionId);\n              }\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n\n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n\n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n\n    Thread.sleep(4000);\n\n    stopStress = true;\n\n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n\n    scheduleThread.join();\n    scheduler.shutdownNow();\n\n    connLossThread.join();\n    killThread.join();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n\n    // we have a leader we know, TODO: lets check some other things\n\n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testStressElection() throws Exception {\n    final ScheduledExecutorService scheduler = Executors\n        .newScheduledThreadPool(15, new DefaultSolrThreadFactory(\"stressElection\"));\n    final List<ClientThread> threads = Collections\n        .synchronizedList(new ArrayList<ClientThread>());\n\n    // start with a leader\n    ClientThread thread1 = null;\n    thread1 = new ClientThread(\"shard1\", 0);\n    threads.add(thread1);\n    scheduler.schedule(thread1, 0, TimeUnit.MILLISECONDS);\n\n\n\n    Thread scheduleThread = new Thread() {\n      @Override\n      public void run() {\n        int count = atLeast(5);\n        for (int i = 1; i < count; i++) {\n          int launchIn = random().nextInt(500);\n          ClientThread thread = null;\n          try {\n            thread = new ClientThread(\"shard1\", i);\n          } catch (Exception e) {\n            //\n          }\n          if (thread != null) {\n            threads.add(thread);\n            scheduler.schedule(thread, launchIn, TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n    };\n\n    Thread killThread = new Thread() {\n      @Override\n      public void run() {\n\n        while (!stopStress) {\n          try {\n            int j;\n            try {\n              // always 1 we won't kill...\n              j = random().nextInt(threads.size() - 2);\n            } catch(IllegalArgumentException e) {\n              continue;\n            }\n            try {\n              threads.get(j).close();\n            } catch (Exception e) {\n            }\n\n            Thread.sleep(10);\n          } catch (Exception e) {\n          }\n        }\n      }\n    };\n\n    Thread connLossThread = new Thread() {\n      @Override\n      public void run() {\n\n        while (!stopStress) {\n          try {\n            Thread.sleep(50);\n            int j;\n            j = random().nextInt(threads.size());\n            try {\n              threads.get(j).es.zkClient.getSolrZooKeeper().closeCnxn();\n              if (random().nextBoolean()) {\n                long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n                server.expire(sessionId);\n              }\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n            Thread.sleep(500);\n\n          } catch (Exception e) {\n\n          }\n        }\n      }\n    };\n\n    scheduleThread.start();\n    connLossThread.start();\n    killThread.start();\n\n    Thread.sleep(4000);\n\n    stopStress = true;\n\n    scheduleThread.interrupt();\n    connLossThread.interrupt();\n    killThread.interrupt();\n\n    scheduleThread.join();\n    scheduler.shutdownNow();\n\n    connLossThread.join();\n    killThread.join();\n\n    int seq = threads.get(getLeaderThread()).getSeq();\n\n    // we have a leader we know, TODO: lets check some other things\n\n    // cleanup any threads still running\n    for (ClientThread thread : threads) {\n      thread.es.zkClient.getSolrZooKeeper().close();\n      thread.close();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["be9f7175e1703e31f8d8de32612b7212db6acf76"],"b2ece5a89a03cd987c5680eee13aaa2139290cfd":["336850123198c8df23821aa53cba096f414d0d24"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","b2ece5a89a03cd987c5680eee13aaa2139290cfd"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"be9f7175e1703e31f8d8de32612b7212db6acf76":["8650ae4e5d74a324411f8b7dd6201774f2b6fb2e"],"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","b2ece5a89a03cd987c5680eee13aaa2139290cfd"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e":["1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"336850123198c8df23821aa53cba096f414d0d24":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b2ece5a89a03cd987c5680eee13aaa2139290cfd"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"1c8719b2c0b382be11f5b193b6fc14bc310e906b":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"b2ece5a89a03cd987c5680eee13aaa2139290cfd":["fd92b8bcc88e969302510acf77bd6970da3994c4","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7"],"be9f7175e1703e31f8d8de32612b7212db6acf76":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"8650ae4e5d74a324411f8b7dd6201774f2b6fb2e":["be9f7175e1703e31f8d8de32612b7212db6acf76"],"336850123198c8df23821aa53cba096f414d0d24":["b2ece5a89a03cd987c5680eee13aaa2139290cfd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","336850123198c8df23821aa53cba096f414d0d24"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":[],"1c8719b2c0b382be11f5b193b6fc14bc310e906b":["c7869f64c874ebf7f317d22c00baf2b6857797a6","8650ae4e5d74a324411f8b7dd6201774f2b6fb2e","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fd92b8bcc88e969302510acf77bd6970da3994c4","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}