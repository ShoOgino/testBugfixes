{"path":"solr/core/src/test/org/apache/solr/util/TestRandomMergePolicy#testGetters().mjava","commits":[{"id":"505b4ec77395cb555366a54a97b24b0906a3d056","date":1375203457,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/TestRandomMergePolicy#testGetters().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Ensure any \"getter\" methods return the same value as\n   * the wrapped MP\n   * (future proof ourselves against new final getter/setter pairs being \n   * added to MP w/o dealing with them in the RMP Constructor)\n   */\n  public void testGetters() throws IllegalAccessException, InvocationTargetException {\n    final int iters = atLeast(20);\n    for (int i = 0; i < iters; i++) {\n      RandomMergePolicy rmp = new RandomMergePolicy();\n      Class mp = MergePolicy.class;\n      for (Method meth : mp.getDeclaredMethods()) {\n        if (meth.getName().startsWith(\"get\") &&\n            (0 == meth.getParameterTypes().length)) {\n\n          assertEquals(\"MergePolicy getter gave diff results for RandomMergePolicy and the policy it wrapped: \" + meth.toGenericString(),\n                       meth.invoke(rmp), meth.invoke(rmp.inner));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/util/TestRandomMergePolicy#testGetters().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Ensure any \"getter\" methods return the same value as\n   * the wrapped MP\n   * (future proof ourselves against new final getter/setter pairs being \n   * added to MP w/o dealing with them in the RMP Constructor)\n   */\n  public void testGetters() throws IllegalAccessException, InvocationTargetException {\n    final int iters = atLeast(20);\n    for (int i = 0; i < iters; i++) {\n      RandomMergePolicy rmp = new RandomMergePolicy();\n      Class mp = MergePolicy.class;\n      for (Method meth : mp.getDeclaredMethods()) {\n        if (meth.getName().startsWith(\"get\") &&\n            (0 == meth.getParameterTypes().length)) {\n\n          assertEquals(\"MergePolicy getter gave diff results for RandomMergePolicy and the policy it wrapped: \" + meth.toGenericString(),\n                       meth.invoke(rmp), meth.invoke(rmp.inner));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e96253deb801879f3fc6373f5069f2debfe797d3","date":1454570664,"type":4,"author":"Shai Erera","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/util/TestRandomMergePolicy#testGetters().mjava","sourceNew":null,"sourceOld":"  /**\n   * Ensure any \"getter\" methods return the same value as\n   * the wrapped MP\n   * (future proof ourselves against new final getter/setter pairs being \n   * added to MP w/o dealing with them in the RMP Constructor)\n   */\n  public void testGetters() throws IllegalAccessException, InvocationTargetException {\n    final int iters = atLeast(20);\n    for (int i = 0; i < iters; i++) {\n      RandomMergePolicy rmp = new RandomMergePolicy();\n      Class mp = MergePolicy.class;\n      for (Method meth : mp.getDeclaredMethods()) {\n        if (meth.getName().startsWith(\"get\") &&\n            (0 == meth.getParameterTypes().length)) {\n\n          assertEquals(\"MergePolicy getter gave diff results for RandomMergePolicy and the policy it wrapped: \" + meth.toGenericString(),\n                       meth.invoke(rmp), meth.invoke(rmp.inner));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1704c078ec59838c9d95d5bf5738b393b537494","date":1454693901,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/util/TestRandomMergePolicy#testGetters().mjava","sourceNew":null,"sourceOld":"  /**\n   * Ensure any \"getter\" methods return the same value as\n   * the wrapped MP\n   * (future proof ourselves against new final getter/setter pairs being \n   * added to MP w/o dealing with them in the RMP Constructor)\n   */\n  public void testGetters() throws IllegalAccessException, InvocationTargetException {\n    final int iters = atLeast(20);\n    for (int i = 0; i < iters; i++) {\n      RandomMergePolicy rmp = new RandomMergePolicy();\n      Class mp = MergePolicy.class;\n      for (Method meth : mp.getDeclaredMethods()) {\n        if (meth.getName().startsWith(\"get\") &&\n            (0 == meth.getParameterTypes().length)) {\n\n          assertEquals(\"MergePolicy getter gave diff results for RandomMergePolicy and the policy it wrapped: \" + meth.toGenericString(),\n                       meth.invoke(rmp), meth.invoke(rmp.inner));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/util/TestRandomMergePolicy#testGetters().mjava","sourceNew":null,"sourceOld":"  /**\n   * Ensure any \"getter\" methods return the same value as\n   * the wrapped MP\n   * (future proof ourselves against new final getter/setter pairs being \n   * added to MP w/o dealing with them in the RMP Constructor)\n   */\n  public void testGetters() throws IllegalAccessException, InvocationTargetException {\n    final int iters = atLeast(20);\n    for (int i = 0; i < iters; i++) {\n      RandomMergePolicy rmp = new RandomMergePolicy();\n      Class mp = MergePolicy.class;\n      for (Method meth : mp.getDeclaredMethods()) {\n        if (meth.getName().startsWith(\"get\") &&\n            (0 == meth.getParameterTypes().length)) {\n\n          assertEquals(\"MergePolicy getter gave diff results for RandomMergePolicy and the policy it wrapped: \" + meth.toGenericString(),\n                       meth.invoke(rmp), meth.invoke(rmp.inner));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"505b4ec77395cb555366a54a97b24b0906a3d056":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","505b4ec77395cb555366a54a97b24b0906a3d056"],"e96253deb801879f3fc6373f5069f2debfe797d3":["505b4ec77395cb555366a54a97b24b0906a3d056"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["505b4ec77395cb555366a54a97b24b0906a3d056","e96253deb801879f3fc6373f5069f2debfe797d3"],"b1704c078ec59838c9d95d5bf5738b393b537494":["505b4ec77395cb555366a54a97b24b0906a3d056","e96253deb801879f3fc6373f5069f2debfe797d3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e96253deb801879f3fc6373f5069f2debfe797d3"]},"commit2Childs":{"505b4ec77395cb555366a54a97b24b0906a3d056":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","e96253deb801879f3fc6373f5069f2debfe797d3","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b1704c078ec59838c9d95d5bf5738b393b537494"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"e96253deb801879f3fc6373f5069f2debfe797d3":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","b1704c078ec59838c9d95d5bf5738b393b537494","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["505b4ec77395cb555366a54a97b24b0906a3d056","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"b1704c078ec59838c9d95d5bf5738b393b537494":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b1704c078ec59838c9d95d5bf5738b393b537494","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}