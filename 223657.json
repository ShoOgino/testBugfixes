{"path":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest#testLUCENE7642().mjava","commits":[{"id":"44c3a4ebfa1a780298de8b00afc0722c16233080","date":1522505029,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest#testLUCENE7642().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testLUCENE7642() {\n    // Construct XYZ solid\n    final XYZSolid solid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84,\n      0.1845405855034623, 0.2730694323646922,\n      -1.398547277986495E-9, 0.020766291030223535,\n      0.7703937553371503, 0.9977622932859774);\n    \n    /*\n   [junit4]   1> individual planes\n   [junit4]   1>  notableMinXPoints=[\n      [X=0.1845405855034623, Y=-1.398547277986495E-9, Z=0.9806642352600131], \n      [X=0.1845405855034623, Y=0.020766291030223535, Z=0.9804458120424796]] \n    notableMaxXPoints=[\n      [X=0.2730694323646922, Y=-1.398547277986495E-9, Z=0.959928047174481], \n      [X=0.2730694323646922, Y=0.020766291030223535, Z=0.9597049045335464]] \n    notableMinYPoints=[\n      [X=0.1845405855034623, Y=-1.398547277986495E-9, Z=0.9806642352600131], \n      [X=0.2730694323646922, Y=-1.398547277986495E-9, Z=0.959928047174481]] \n    notableMaxYPoints=[\n      [X=0.1845405855034623, Y=0.020766291030223535, Z=0.9804458120424796], \n      [X=0.2730694323646922, Y=0.020766291030223535, Z=0.9597049045335464]] \n    notableMinZPoints=[] \n    notableMaxZPoints=[]\n    \n    [junit4]   1> All edge points=[\n      [X=0.1845405855034623, Y=-1.398547277986495E-9, Z=0.9806642352600131], \n      [X=0.1845405855034623, Y=0.020766291030223535, Z=0.9804458120424796], \n      [X=0.2730694323646922, Y=-1.398547277986495E-9, Z=0.959928047174481], \n      [X=0.2730694323646922, Y=0.020766291030223535, Z=0.9597049045335464]]\n\n    */\n\n    final GeoPoint edge1 = new GeoPoint(0.1845405855034623, -1.398547277986495E-9, 0.9806642352600131);\n    final GeoPoint edge2 = new GeoPoint(0.1845405855034623, 0.020766291030223535, 0.9804458120424796);\n    final GeoPoint edge3 = new GeoPoint(0.2730694323646922, -1.398547277986495E-9, 0.959928047174481);\n    final GeoPoint edge4 = new GeoPoint(0.2730694323646922, 0.020766291030223535, 0.9597049045335464);\n    \n    // The above says that none of these intersect the surface: minZmaxX, minZminX, minZmaxY, minZminY, or\n    // maxZmaxX, maxZminX, maxZmaxY, maxZminY.\n    \n    // So what about minZ and maxZ all by themselves?\n    //\n    // [junit4]   1> Outside world: minXminYminZ=false minXminYmaxZ=true minXmaxYminZ=false minXmaxYmaxZ=true maxXminYminZ=false \n    // maxXminYmaxZ=true maxXmaxYminZ=false maxXmaxYmaxZ=true\n    //\n    // So the minz plane does not intersect the world because it's all inside.  The maxZ plane is all outside but may intersect the world still.\n    // But it doesn't because it's too far north.\n    // So it looks like these are our edge points, and they are correct.\n    \n    /*\n  GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[\n    [lat=-1.2267098126036888, lon=3.141592653589793([X=-0.33671029227864785, Y=4.123511816790159E-17, Z=-0.9396354281810864])], \n    [lat=0.2892272352400239, lon=0.017453291479645996([X=0.9591279281485559, Y=0.01674163926221766, Z=0.28545251693892165])], \n    [lat=-1.5707963267948966, lon=1.6247683074702402E-201([X=6.109531986173988E-17, Y=9.926573944611206E-218, Z=-0.997762292022105])]], internalEdges={2}}, \n  GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[\n    [lat=-1.2267098126036888, lon=3.141592653589793([X=-0.33671029227864785, Y=4.123511816790159E-17, Z=-0.9396354281810864])], \n    [lat=-1.5707963267948966, lon=1.6247683074702402E-201([X=6.109531986173988E-17, Y=9.926573944611206E-218, Z=-0.997762292022105])], \n    [lat=0.6723906085905078, lon=-3.0261581679831E-12([X=0.7821883235431606, Y=-2.367025584191143E-12, Z=0.6227413298552851])]], internalEdges={0}}]}\n    */\n    final List<GeoPoint> points = new ArrayList<>();\n    points.add(new GeoPoint(PlanetModel.WGS84, -1.2267098126036888, 3.141592653589793));\n    points.add(new GeoPoint(PlanetModel.WGS84, 0.2892272352400239, 0.017453291479645996));\n    points.add(new GeoPoint(PlanetModel.WGS84, -1.5707963267948966, 1.6247683074702402E-201));\n    points.add(new GeoPoint(PlanetModel.WGS84, 0.6723906085905078, -3.0261581679831E-12));\n    \n    final GeoPolygonFactory.PolygonDescription pd = new GeoPolygonFactory.PolygonDescription(points);\n    final GeoPolygon shape = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, pd);\n    final List<GeoPolygonFactory.PolygonDescription> pdList = new ArrayList<>(1);\n    pdList.add(pd);\n    final GeoPolygon largeShape = GeoPolygonFactory.makeLargeGeoPolygon(PlanetModel. WGS84, pdList);\n    \n    /* This is the output:\n   [junit4]   1> shape = GeoCompositePolygon: {[\n    GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[\n      [lat=-1.2267098126036888, lon=3.141592653589793([X=-0.33671029227864785, Y=4.123511816790159E-17, Z=-0.9396354281810864])], \n      [lat=0.2892272352400239, lon=0.017453291479645996([X=0.9591279281485559, Y=0.01674163926221766, Z=0.28545251693892165])], \n      [lat=-1.5707963267948966, lon=1.6247683074702402E-201([X=6.109531986173988E-17, Y=9.926573944611206E-218, Z=-0.997762292022105])]], internalEdges={2}}, \n    GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[\n      [lat=-1.2267098126036888, lon=3.141592653589793([X=-0.33671029227864785, Y=4.123511816790159E-17, Z=-0.9396354281810864])], \n      [lat=-1.5707963267948966, lon=1.6247683074702402E-201([X=6.109531986173988E-17, Y=9.926573944611206E-218, Z=-0.997762292022105])], \n      [lat=0.6723906085905078, lon=-3.0261581679831E-12([X=0.7821883235431606, Y=-2.367025584191143E-12, Z=0.6227413298552851])]], internalEdges={0}}]}\n    */\n    \n    final GeoPoint quantized = new GeoPoint(0.24162356556559528, 2.3309121299774915E-10, 0.9682657049003708);\n    final GeoPoint unquantized = new GeoPoint(PlanetModel.WGS84, 1.3262481806651818, 2.4457272005608357E-47);\n\n    // This passes; the point is definitely within the solid.\n    assertTrue(solid.isWithin(unquantized));\n\n    // This passes, so I assume that this is the correct response.\n    assertFalse(largeShape.isWithin(unquantized));\n    // This fails because the point is within the shape but apparently shouldn't be.\n    // Instrumenting isWithin finds that the point is on three edge planes somehow:\n    /*\n   [junit4]   1> localIsWithin start for point [0.2416235655409041,5.90945326539883E-48,0.9682657046994557]\n   [junit4]   1>  For edge [A=-1.224646799147353E-16, B=-1.0, C=-7.498798913309287E-33, D=0.0, side=1.0] the point evaluation is -2.959035261382389E-17\n   [junit4]   1>  For edge [A=-3.0261581679831E-12, B=-0.9999999999999999, C=-1.8529874570670608E-28, D=0.0, side=1.0] the point evaluation is -7.31191126438807E-13\n   [junit4]   1>  For edge [A=4.234084035470679E-12, B=1.0, C=-1.5172037954732973E-12, D=0.0, side=1.0] the point evaluation is -4.460019207463956E-13\n    */\n    // These are too close to parallel.  The only solution is to prevent the poly from being created.  Let's see if Geo3d thinks they are parallel.\n    \n    final Plane p1 = new Plane(-1.224646799147353E-16, -1.0, -7.498798913309287E-33, 0.0);\n    final Plane p2 = new Plane(-3.0261581679831E-12, -0.9999999999999999, -1.8529874570670608E-28, 0.0);\n    final Plane p3 = new Plane(4.234084035470679E-12, 1.0, -1.5172037954732973E-12, 0.0);\n    \n    assertFalse(shape.isWithin(unquantized));\n    \n    // This point is indeed outside the shape but it doesn't matter\n    assertFalse(shape.isWithin(quantized));\n    \n    // Sanity check with different poly implementation\n    assertTrue(shape.isWithin(edge1) == largeShape.isWithin(edge1));\n    assertTrue(shape.isWithin(edge2) == largeShape.isWithin(edge2));\n    assertTrue(shape.isWithin(edge3) == largeShape.isWithin(edge3));\n    assertTrue(shape.isWithin(edge4) == largeShape.isWithin(edge4));\n    \n    // Verify both shapes give the same relationship\n    int intersection = solid.getRelationship(shape);\n    int largeIntersection = solid.getRelationship(largeShape);\n    assertTrue(intersection == largeIntersection);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["44c3a4ebfa1a780298de8b00afc0722c16233080"]},"commit2Childs":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}