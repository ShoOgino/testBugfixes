{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#isNumericallyIdentical(Plane).mjava","commits":[{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/Plane#isNumericallyIdentical(Plane).mjava","sourceNew":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   * @param p is the plane to compare against.\n   * @return true if the planes are numerically identical.\n   */\n  protected boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","sourceOld":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   * @param p is the plane to compare against.\n   * @return true if the planes are numerically identical.\n   */\n  protected boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5864f13b0b1ae08430bed46d2fcbc5f5c7005195","date":1460068279,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#isNumericallyIdentical(Plane).mjava","sourceNew":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   * @param p is the plane to compare against.\n   * @return true if the planes are numerically identical.\n   */\n  public boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","sourceOld":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   * @param p is the plane to compare against.\n   * @return true if the planes are numerically identical.\n   */\n  protected boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44c3a4ebfa1a780298de8b00afc0722c16233080","date":1522505029,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#isNumericallyIdentical(Plane).mjava","sourceNew":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   * @param p is the plane to compare against.\n   * @return true if the planes are numerically identical.\n   */\n  public boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  That's basically finding\n    // out if the magnitude of the cross-product is \"zero\".\n    final double cross1 = this.y * p.z - this.z * p.y;\n    final double cross2 = this.z * p.x - this.x * p.z;\n    final double cross3 = this.x * p.y - this.y * p.x;\n    //System.out.println(\"cross product magnitude = \"+(cross1 * cross1 + cross2 * cross2 + cross3 * cross3));\n    // Technically should be MINIMUM_RESOLUTION_SQUARED, but that gives us planes that are *almost* parallel, and those are problematic too\n    if (cross1 * cross1 + cross2 * cross2 + cross3 * cross3 >= MINIMUM_RESOLUTION) {\n      return false;\n    }\n    /* Old method\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n    */\n    \n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","sourceOld":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   * @param p is the plane to compare against.\n   * @return true if the planes are numerically identical.\n   */\n  public boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  If that passes, then compute a point on the plane\n    // (using D) and see if it also on the other plane.\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n\n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","bugFix":null,"bugIntro":["bc5a9298580a352dd8deee6537b9a544a4af8bae"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc5a9298580a352dd8deee6537b9a544a4af8bae","date":1522510952,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#isNumericallyIdentical(Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#isNumericallyIdentical(Plane).mjava","sourceNew":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   * @param p is the plane to compare against.\n   * @return true if the planes are numerically identical.\n   */\n  public boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  That's basically finding\n    // out if the magnitude of the cross-product is \"zero\".\n    final double cross1 = this.y * p.z - this.z * p.y;\n    final double cross2 = this.z * p.x - this.x * p.z;\n    final double cross3 = this.x * p.y - this.y * p.x;\n    //System.out.println(\"cross product magnitude = \"+(cross1 * cross1 + cross2 * cross2 + cross3 * cross3));\n    if (cross1 * cross1 + cross2 * cross2 + cross3 * cross3 >= MINIMUM_RESOLUTION_SQUARED) {\n      return false;\n    }\n    /* Old method\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n    */\n    \n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","sourceOld":"  /**\n   * Returns true if this plane and the other plane are identical within the margin of error.\n   * @param p is the plane to compare against.\n   * @return true if the planes are numerically identical.\n   */\n  public boolean isNumericallyIdentical(final Plane p) {\n    // We can get the correlation by just doing a parallel plane check.  That's basically finding\n    // out if the magnitude of the cross-product is \"zero\".\n    final double cross1 = this.y * p.z - this.z * p.y;\n    final double cross2 = this.z * p.x - this.x * p.z;\n    final double cross3 = this.x * p.y - this.y * p.x;\n    //System.out.println(\"cross product magnitude = \"+(cross1 * cross1 + cross2 * cross2 + cross3 * cross3));\n    // Technically should be MINIMUM_RESOLUTION_SQUARED, but that gives us planes that are *almost* parallel, and those are problematic too\n    if (cross1 * cross1 + cross2 * cross2 + cross3 * cross3 >= MINIMUM_RESOLUTION) {\n      return false;\n    }\n    /* Old method\n    if (Math.abs(this.y * p.z - this.z * p.y) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.z * p.x - this.x * p.z) >= MINIMUM_RESOLUTION)\n      return false;\n    if (Math.abs(this.x * p.y - this.y * p.x) >= MINIMUM_RESOLUTION)\n      return false;\n    */\n    \n    // Now, see whether the parallel planes are in fact on top of one another.\n    // The math:\n    // We need a single point that fulfills:\n    // Ax + By + Cz + D = 0\n    // Pick:\n    // x0 = -(A * D) / (A^2 + B^2 + C^2)\n    // y0 = -(B * D) / (A^2 + B^2 + C^2)\n    // z0 = -(C * D) / (A^2 + B^2 + C^2)\n    // Check:\n    // A (x0) + B (y0) + C (z0) + D =? 0\n    // A (-(A * D) / (A^2 + B^2 + C^2)) + B (-(B * D) / (A^2 + B^2 + C^2)) + C (-(C * D) / (A^2 + B^2 + C^2)) + D ?= 0\n    // -D [ A^2 / (A^2 + B^2 + C^2) + B^2 / (A^2 + B^2 + C^2) + C^2 / (A^2 + B^2 + C^2)] + D ?= 0\n    // Yes.\n    final double denom = 1.0 / (p.x * p.x + p.y * p.y + p.z * p.z);\n    return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);\n  }\n\n","bugFix":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["5864f13b0b1ae08430bed46d2fcbc5f5c7005195"],"5864f13b0b1ae08430bed46d2fcbc5f5c7005195":["b4e444678504caf66a8060b1d514383aa4feac0c"],"bc5a9298580a352dd8deee6537b9a544a4af8bae":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b4e444678504caf66a8060b1d514383aa4feac0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bc5a9298580a352dd8deee6537b9a544a4af8bae"]},"commit2Childs":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["bc5a9298580a352dd8deee6537b9a544a4af8bae"],"5864f13b0b1ae08430bed46d2fcbc5f5c7005195":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"bc5a9298580a352dd8deee6537b9a544a4af8bae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4e444678504caf66a8060b1d514383aa4feac0c"],"b4e444678504caf66a8060b1d514383aa4feac0c":["5864f13b0b1ae08430bed46d2fcbc5f5c7005195"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}