{"path":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","commits":[{"id":"20f6b7cff3771384f27af0f059795d7e64aff6b9","date":1425498309,"type":1,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = (replicationTime - getReplicationStartTime()) / 1000;\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n      \n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = (replicationTime - getReplicationStartTime()) / 1000;\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n      \n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded(this)));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = (replicationTime - getReplicationStartTime()) / 1000;\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n      \n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = (replicationTime - getReplicationStartTime()) / 1000;\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = (replicationTime - getReplicationStartTime()) / 1000;\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n      \n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = (replicationTime - getReplicationStartTime()) / 1000;\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0ca74ae423fe45e31cb4c02b83262f0549f52f5","date":1482969139,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n\n      final IndexOutput out = dir.createOutput(REPLICATION_PROPERTIES, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(REPLICATION_PROPERTIES));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c72a3aa9309c1f5ade9265cf083e565ae8d35b8","date":1489572490,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.parseInt(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.parseInt(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.parseInt(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55e0b3830b94d1abce4e32e98cfc875d5b14e76f","date":1489651910,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.parseInt(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.parseInt(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.parseInt(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.parseInt(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.parseInt(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.parseInt(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.valueOf(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.valueOf(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.valueOf(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.parseInt(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.parseInt(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.parseInt(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      log.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.parseInt(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.parseInt(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.parseInt(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      LOG.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81d505b8f51b856e1b7e9dd377f5050c337b797a","date":1549455307,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#logReplicationTimeAndConfFiles(Collection[Map[String,Object]],boolean).mjava","sourceNew":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.parseInt(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (clearLocalIndexFirst) {\n        props.setProperty(CLEARED_LOCAL_IDX, \"true\");\n      }\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.parseInt(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.parseInt(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      log.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Helper method to record the last replication's details so that we can show them on the statistics page across\n   * restarts.\n   * @throws IOException on IO error\n   */\n  @SuppressForbidden(reason = \"Need currentTimeMillis for debugging/stats\")\n  private void logReplicationTimeAndConfFiles(Collection<Map<String, Object>> modifiedConfFiles, boolean successfulInstall) throws IOException {\n    List<String> confFiles = new ArrayList<>();\n    if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty())\n      for (Map<String, Object> map1 : modifiedConfFiles)\n        confFiles.add((String) map1.get(NAME));\n\n    Properties props = replicationHandler.loadReplicationProperties();\n    long replicationTime = System.currentTimeMillis();\n    long replicationTimeTaken = getReplicationTimeElapsed();\n    Directory dir = null;\n    try {\n      dir = solrCore.getDirectoryFactory().get(solrCore.getDataDir(), DirContext.META_DATA, solrCore.getSolrConfig().indexConfig.lockType);\n\n      int indexCount = 1, confFilesCount = 1;\n      if (props.containsKey(TIMES_INDEX_REPLICATED)) {\n        indexCount = Integer.parseInt(props.getProperty(TIMES_INDEX_REPLICATED)) + 1;\n      }\n      StringBuilder sb = readToStringBuilder(replicationTime, props.getProperty(INDEX_REPLICATED_AT_LIST));\n      props.setProperty(INDEX_REPLICATED_AT_LIST, sb.toString());\n      props.setProperty(INDEX_REPLICATED_AT, String.valueOf(replicationTime));\n      props.setProperty(PREVIOUS_CYCLE_TIME_TAKEN, String.valueOf(replicationTimeTaken));\n      props.setProperty(TIMES_INDEX_REPLICATED, String.valueOf(indexCount));\n      if (modifiedConfFiles != null && !modifiedConfFiles.isEmpty()) {\n        props.setProperty(CONF_FILES_REPLICATED, confFiles.toString());\n        props.setProperty(CONF_FILES_REPLICATED_AT, String.valueOf(replicationTime));\n        if (props.containsKey(TIMES_CONFIG_REPLICATED)) {\n          confFilesCount = Integer.parseInt(props.getProperty(TIMES_CONFIG_REPLICATED)) + 1;\n        }\n        props.setProperty(TIMES_CONFIG_REPLICATED, String.valueOf(confFilesCount));\n      }\n\n      props.setProperty(LAST_CYCLE_BYTES_DOWNLOADED, String.valueOf(getTotalBytesDownloaded()));\n      if (!successfulInstall) {\n        int numFailures = 1;\n        if (props.containsKey(TIMES_FAILED)) {\n          numFailures = Integer.parseInt(props.getProperty(TIMES_FAILED)) + 1;\n        }\n        props.setProperty(TIMES_FAILED, String.valueOf(numFailures));\n        props.setProperty(REPLICATION_FAILED_AT, String.valueOf(replicationTime));\n        sb = readToStringBuilder(replicationTime, props.getProperty(REPLICATION_FAILED_AT_LIST));\n        props.setProperty(REPLICATION_FAILED_AT_LIST, sb.toString());\n      }\n      \n      \n      String tmpFileName = REPLICATION_PROPERTIES + \".\" + System.nanoTime();\n      final IndexOutput out = dir.createOutput(tmpFileName, DirectoryFactory.IOCONTEXT_NO_CACHE);\n      Writer outFile = new OutputStreamWriter(new PropertiesOutputStream(out), StandardCharsets.UTF_8);\n      try {\n        props.store(outFile, \"Replication details\");\n        dir.sync(Collections.singleton(tmpFileName));\n      } finally {\n        IOUtils.closeQuietly(outFile);\n      }\n      \n      solrCore.getDirectoryFactory().renameWithOverwrite(dir, tmpFileName, REPLICATION_PROPERTIES);\n    } catch (Exception e) {\n      log.warn(\"Exception while updating statistics\", e);\n    } finally {\n      if (dir != null) {\n        solrCore.getDirectoryFactory().release(dir);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6c72a3aa9309c1f5ade9265cf083e565ae8d35b8":["f0ca74ae423fe45e31cb4c02b83262f0549f52f5"],"81d505b8f51b856e1b7e9dd377f5050c337b797a":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"f0ca74ae423fe45e31cb4c02b83262f0549f52f5":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["bcf9886c8ff537aafde14de48ebf744f5673f08b","f0ca74ae423fe45e31cb4c02b83262f0549f52f5"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["20f6b7cff3771384f27af0f059795d7e64aff6b9"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","20f6b7cff3771384f27af0f059795d7e64aff6b9"],"20f6b7cff3771384f27af0f059795d7e64aff6b9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55e0b3830b94d1abce4e32e98cfc875d5b14e76f":["f0ca74ae423fe45e31cb4c02b83262f0549f52f5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"ab68488225b6a6c357dda72ed11dedca9914a192":["f0ca74ae423fe45e31cb4c02b83262f0549f52f5","55e0b3830b94d1abce4e32e98cfc875d5b14e76f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["81d505b8f51b856e1b7e9dd377f5050c337b797a"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["6c72a3aa9309c1f5ade9265cf083e565ae8d35b8"]},"commit2Childs":{"6c72a3aa9309c1f5ade9265cf083e565ae8d35b8":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"81d505b8f51b856e1b7e9dd377f5050c337b797a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f0ca74ae423fe45e31cb4c02b83262f0549f52f5":["6c72a3aa9309c1f5ade9265cf083e565ae8d35b8","f03e4bed5023ec3ef93a771b8888cae991cf448d","55e0b3830b94d1abce4e32e98cfc875d5b14e76f","ab68488225b6a6c357dda72ed11dedca9914a192"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"86290366cefc1b9d4eced13b430858c4a4c0421d":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"20f6b7cff3771384f27af0f059795d7e64aff6b9":["86290366cefc1b9d4eced13b430858c4a4c0421d","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"55e0b3830b94d1abce4e32e98cfc875d5b14e76f":["ab68488225b6a6c357dda72ed11dedca9914a192"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","20f6b7cff3771384f27af0f059795d7e64aff6b9"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["f0ca74ae423fe45e31cb4c02b83262f0549f52f5","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"ab68488225b6a6c357dda72ed11dedca9914a192":[],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["81d505b8f51b856e1b7e9dd377f5050c337b797a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f03e4bed5023ec3ef93a771b8888cae991cf448d","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ab68488225b6a6c357dda72ed11dedca9914a192","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}