{"path":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves()[(int)(lookup>>32)]);\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves()[(int)(lookup>>32)]);\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves()[(int)(lookup>>32)]);\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves()[(int)(lookup>>32)]);\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9767265f21f7d1246b13dd7e73e8a4ad88b4384","date":1342986300,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"773a737806859660d4756f710adc0ad53e05f9d5","date":1432140757,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null;\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n      long ver = fv.longVal((int)lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  /**\n   * Returns the latest version from the index, searched by the given id (bytes) as seen from the realtime searcher.\n   * Returns null if no document can be found in the index for the given id.\n   */\n  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  /**\n   * Returns the latest version from the index, searched by the given id (bytes) as seen from the realtime searcher.\n   * Returns null if no document can be found in the index for the given id.\n   */\n  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  /**\n   * Returns the latest version from the index, searched by the given id (bytes) as seen from the realtime searcher.\n   * Returns null if no document can be found in the index for the given id.\n   */\n  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      @SuppressWarnings({\"rawtypes\"})\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the latest version from the index, searched by the given id (bytes) as seen from the realtime searcher.\n   * Returns null if no document can be found in the index for the given id.\n   */\n  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getVersionFromIndex(BytesRef).mjava","sourceNew":"  /**\n   * Returns the latest version from the index, searched by the given id (bytes) as seen from the realtime searcher.\n   * Returns null if no document can be found in the index for the given id.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      @SuppressWarnings({\"rawtypes\"})\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns the latest version from the index, searched by the given id (bytes) as seen from the realtime searcher.\n   * Returns null if no document can be found in the index for the given id.\n   */\n  public Long getVersionFromIndex(BytesRef idBytes) {\n    // TODO: we could cache much of this and invalidate during a commit.\n    // TODO: most DocValues classes are threadsafe - expose which.\n\n    RefCounted<SolrIndexSearcher> newestSearcher = ulog.uhandler.core.getRealtimeSearcher();\n    try {\n      SolrIndexSearcher searcher = newestSearcher.get();\n      long lookup = searcher.lookupId(idBytes);\n      if (lookup < 0) return null; // this means the doc doesn't exist in the index yet\n\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      @SuppressWarnings({\"rawtypes\"})\n      Map context = ValueSource.newContext(searcher);\n      vs.createWeight(context, searcher);\n      FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int) (lookup >> 32)));\n      long ver = fv.longVal((int) lookup);\n      return ver;\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["773a737806859660d4756f710adc0ad53e05f9d5"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["773a737806859660d4756f710adc0ad53e05f9d5","415bbbe7da8065dd3c477bdc3c703c6425622998"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"773a737806859660d4756f710adc0ad53e05f9d5":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"773a737806859660d4756f710adc0ad53e05f9d5":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["aba371508186796cc6151d8223a5b4e16d02e26e","773a737806859660d4756f710adc0ad53e05f9d5","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}