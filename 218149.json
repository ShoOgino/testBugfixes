{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","commits":[{"id":"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1","date":1402094642,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrServer server = getSolrServer();\n    server.deleteByQuery(\"*:*\");\n    server.commit();\n\n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      server.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    server.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"*:*\");\n    QueryResponse resp = server.query(q);\n    assertEquals(\"Doc count does not match\", \n                 allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"level_i:0\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = server.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"*:*\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = server.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"*:*\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"name:\" + name);\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = server.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["87405ce5d9e414377a5dcdcd407fc75c4454a19e","23d4fcf7ecbff00440f8af034b6a8eeec65a0583"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"23d4fcf7ecbff00440f8af034b6a8eeec65a0583","date":1414004449,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","sourceNew":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrServer server = getSolrServer();\n    server.deleteByQuery(\"*:*\");\n    server.commit();\n\n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      server.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    server.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"*:*\");\n    QueryResponse resp = server.query(q);\n    assertEquals(\"Doc count does not match\", \n                 allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"level_i:0\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = server.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"*:*\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = server.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"*:*\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"name:\" + name);\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = server.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrServer server = getSolrServer();\n    server.deleteByQuery(\"*:*\");\n    server.commit();\n\n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      server.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    server.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"*:*\");\n    QueryResponse resp = server.query(q);\n    assertEquals(\"Doc count does not match\", \n                 allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"level_i:0\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = server.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"*:*\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = server.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"*:*\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"name:\" + name);\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = server.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","sourceNew":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n\n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"*:*\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"level_i:0\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"*:*\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"*:*\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"name:\" + name);\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrServer server = getSolrServer();\n    server.deleteByQuery(\"*:*\");\n    server.commit();\n\n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      server.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    server.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"*:*\");\n    QueryResponse resp = server.query(q);\n    assertEquals(\"Doc count does not match\", \n                 allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"level_i:0\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = server.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"*:*\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = server.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"*:*\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"name:\" + name);\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = server.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87405ce5d9e414377a5dcdcd407fc75c4454a19e","date":1500683157,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","sourceNew":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    \n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"], name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n    \n    // bespoke check - use child transformer twice in one query to get diff kids, with name field in between\n    {\n      q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n      // NOTE: should be impossible to have more then 7 direct kids, or more then 49 grandkids\n      q.setFields(\"id\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:1\\\"]\",\n                  \"name\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:2\\\"]\");\n      resp = client.query(q);\n      assertEquals(\"topLevel count does not match\", numRootDocs,\n                   resp.getResults().getNumFound());\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n          // the total number of kids should be our direct kids and our grandkids\n          int expectedKidsOut = origDoc.getChildDocuments().size();\n          for (SolrInputDocument origKid : origDoc.getChildDocuments()) {\n            if (origKid.hasChildDocuments()) {\n              expectedKidsOut += origKid.getChildDocuments().size();\n            }\n          }\n          assertEquals(\"total number of kids and grandkids doesn't match expected\",\n                       expectedKidsOut, outDoc.getChildDocuments().size());\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"q\",\"*:*\", \"indent\", \"true\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"q\", \"name:\" + name, \"indent\", \"true\");\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"],name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n\n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"*:*\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"level_i:0\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"*:*\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"*:*\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"name:\" + name);\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","sourceNew":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    \n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"], name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n    \n    // bespoke check - use child transformer twice in one query to get diff kids, with name field in between\n    {\n      q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n      // NOTE: should be impossible to have more then 7 direct kids, or more then 49 grandkids\n      q.setFields(\"id\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:1\\\"]\",\n                  \"name\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:2\\\"]\");\n      resp = client.query(q);\n      assertEquals(\"topLevel count does not match\", numRootDocs,\n                   resp.getResults().getNumFound());\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n          // the total number of kids should be our direct kids and our grandkids\n          int expectedKidsOut = origDoc.getChildDocuments().size();\n          for (SolrInputDocument origKid : origDoc.getChildDocuments()) {\n            if (origKid.hasChildDocuments()) {\n              expectedKidsOut += origKid.getChildDocuments().size();\n            }\n          }\n          assertEquals(\"total number of kids and grandkids doesn't match expected\",\n                       expectedKidsOut, outDoc.getChildDocuments().size());\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"q\",\"*:*\", \"indent\", \"true\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"q\", \"name:\" + name, \"indent\", \"true\");\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"],name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n\n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"*:*\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"level_i:0\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"*:*\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"*:*\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"name:\" + name);\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","sourceNew":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    \n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"], name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n    \n    // bespoke check - use child transformer twice in one query to get diff kids, with name field in between\n    {\n      q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n      // NOTE: should be impossible to have more then 7 direct kids, or more then 49 grandkids\n      q.setFields(\"id\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:1\\\"]\",\n                  \"name\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:2\\\"]\");\n      resp = client.query(q);\n      assertEquals(\"topLevel count does not match\", numRootDocs,\n                   resp.getResults().getNumFound());\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n          // the total number of kids should be our direct kids and our grandkids\n          int expectedKidsOut = origDoc.getChildDocuments().size();\n          for (SolrInputDocument origKid : origDoc.getChildDocuments()) {\n            if (origKid.hasChildDocuments()) {\n              expectedKidsOut += origKid.getChildDocuments().size();\n            }\n          }\n          assertEquals(\"total number of kids and grandkids doesn't match expected\",\n                       expectedKidsOut, outDoc.getChildDocuments().size());\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"q\",\"*:*\", \"indent\", \"true\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"q\", \"name:\" + name, \"indent\", \"true\");\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"],name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n\n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"*:*\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"level_i:0\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"*:*\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"*:*\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"name:\" + name);\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"]\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"373ea6b2f051d2a56e8e78a5da11de7aa52ed399","date":1536159014,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testChildDoctransformer().mjava","sourceNew":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    \n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id, level_i, [child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"], name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n    \n    // bespoke check - use child transformer twice in one query to get diff kids, with name field in between\n    {\n      q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n      // NOTE: should be impossible to have more then 7 direct kids, or more then 49 grandkids\n      q.setFields(\"id\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:1\\\"]\",\n                  \"name\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:2\\\"]\");\n      resp = client.query(q);\n      assertEquals(\"topLevel count does not match\", numRootDocs,\n                   resp.getResults().getNumFound());\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n          // the total number of kids should be our direct kids and our grandkids\n          int expectedKidsOut = origDoc.getChildDocuments().size();\n          for (SolrInputDocument origKid : origDoc.getChildDocuments()) {\n            if (origKid.hasChildDocuments()) {\n              expectedKidsOut += origKid.getChildDocuments().size();\n            }\n          }\n          assertEquals(\"total number of kids and grandkids doesn't match expected\",\n                       expectedKidsOut, outDoc.getChildDocuments().size());\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"q\",\"*:*\", \"indent\", \"true\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"q\", \"name:\" + name, \"indent\", \"true\");\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id, level_i, [child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"],name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testChildDoctransformer() throws IOException, SolrServerException {\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    \n    int numRootDocs = TestUtil.nextInt(random(), 10, 100);\n    int maxDepth = TestUtil.nextInt(random(), 2, 5);\n\n    Map<String,SolrInputDocument> allDocs = new HashMap<>();\n\n    for (int i =0; i < numRootDocs; i++) {\n      client.add(genNestedDocuments(allDocs, 0, maxDepth));\n    }\n\n    client.commit();\n\n    // sanity check\n    SolrQuery q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\",\n        allDocs.size(), resp.getResults().getNumFound());\n\n\n    // base check - we know there is an exact number of these root docs\n    q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n    q.setFields(\"*\", \"[child parentFilter=\\\"level_i:0\\\"]\");\n    resp = client.query(q);\n    assertEquals(\"topLevel count does not match\", numRootDocs,\n                 resp.getResults().getNumFound());\n    for (SolrDocument outDoc : resp.getResults()) {\n      String docId = (String)outDoc.getFieldValue(\"id\");\n      SolrInputDocument origDoc = allDocs.get(docId);\n      assertNotNull(\"docId not found: \" + docId, origDoc);\n      assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n      assertEquals(\"kids mismatch\", \n                   origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n      if (outDoc.hasChildDocuments()) {\n        for (SolrDocument kid : outDoc.getChildDocuments()) {\n          String kidId = (String)kid.getFieldValue(\"id\");\n          SolrInputDocument origChild = findDecendent(origDoc, kidId);\n          assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                        origChild);\n        }\n      }\n    }\n\n    // simple check: direct verification of direct children on random docs\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth);\n      int kidLevel = parentLevel+1;\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:\" + kidLevel;\n      int maxKidCount = TestUtil.nextInt(random(), 1, 37);\n      \n      q = new SolrQuery(\"q\", \"*:*\", \"indent\", \"true\");\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"], name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          // since we know we are looking at our direct children\n          // we can verify the count\n          int numOrigKids = origDoc.getChildDocuments().size();\n          int numOutKids = outDoc.getChildDocuments().size();\n          assertEquals(\"Num kids mismatch: \" + numOrigKids + \"/\" + maxKidCount,\n                       (maxKidCount < numOrigKids ? maxKidCount : numOrigKids),\n                       numOutKids);\n          \n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            assertEquals(\"kid is the wrong level\",\n                         kidLevel, (int)kid.getFieldValue(\"level_i\"));\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n    \n    // bespoke check - use child transformer twice in one query to get diff kids, with name field in between\n    {\n      q = new SolrQuery(\"q\",\"level_i:0\", \"indent\", \"true\");\n      // NOTE: should be impossible to have more then 7 direct kids, or more then 49 grandkids\n      q.setFields(\"id\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:1\\\"]\",\n                  \"name\", \"[child parentFilter=\\\"level_i:0\\\" limit=100 childFilter=\\\"level_i:2\\\"]\");\n      resp = client.query(q);\n      assertEquals(\"topLevel count does not match\", numRootDocs,\n                   resp.getResults().getNumFound());\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        assertEquals(\"kids mismatch\", \n                     origDoc.hasChildDocuments(), outDoc.hasChildDocuments());\n        if (outDoc.hasChildDocuments()) {\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n          // the total number of kids should be our direct kids and our grandkids\n          int expectedKidsOut = origDoc.getChildDocuments().size();\n          for (SolrInputDocument origKid : origDoc.getChildDocuments()) {\n            if (origKid.hasChildDocuments()) {\n              expectedKidsOut += origKid.getChildDocuments().size();\n            }\n          }\n          assertEquals(\"total number of kids and grandkids doesn't match expected\",\n                       expectedKidsOut, outDoc.getChildDocuments().size());\n        }\n      }\n    }\n\n    // fully randomized\n    // verifications are driven only by the results\n    {\n      int parentLevel = TestUtil.nextInt(random(), 0, maxDepth-1);\n      int kidLevelMin = TestUtil.nextInt(random(), parentLevel + 1, maxDepth);\n      int kidLevelMax = TestUtil.nextInt(random(), kidLevelMin, maxDepth);\n\n      String parentFilter = \"level_i:\" + parentLevel;\n      String childFilter = \"level_i:[\" + kidLevelMin + \" TO \" + kidLevelMax + \"]\";\n      int maxKidCount = TestUtil.nextInt(random(), 1, 7);\n      \n      q = new SolrQuery(\"q\",\"*:*\", \"indent\", \"true\");\n      if (random().nextBoolean()) {\n        String name = names[TestUtil.nextInt(random(), 0, names.length-1)];\n        q = new SolrQuery(\"q\", \"name:\" + name, \"indent\", \"true\");\n      }\n      q.setFilterQueries(parentFilter);\n      q.setFields(\"id,[child parentFilter=\\\"\" + parentFilter +\n                  \"\\\" childFilter=\\\"\" + childFilter + \n                  \"\\\" limit=\\\"\" + maxKidCount + \"\\\"],name\");\n      resp = client.query(q);\n      for (SolrDocument outDoc : resp.getResults()) {\n        String docId = (String)outDoc.getFieldValue(\"id\");\n        SolrInputDocument origDoc = allDocs.get(docId);\n        assertNotNull(\"docId not found: \" + docId, origDoc);\n        assertEquals(\"name mismatch\", origDoc.getFieldValue(\"name\"), outDoc.getFieldValue(\"name\"));\n        // we can't always assert origHasKids==outHasKids, original kids\n        // might not go deep enough for childFilter...\n        if (outDoc.hasChildDocuments()) {\n          // ...however if there are out kids, there *have* to be orig kids\n          assertTrue(\"orig doc had no kids at all\", origDoc.hasChildDocuments());\n          for (SolrDocument kid : outDoc.getChildDocuments()) {\n            String kidId = (String)kid.getFieldValue(\"id\");\n            int kidLevel = (int)kid.getFieldValue(\"level_i\");\n            assertTrue(\"kid level to high: \" + kidLevelMax + \"<\" + kidLevel,\n                       kidLevel <= kidLevelMax);\n            assertTrue(\"kid level to low: \" + kidLevelMin + \">\" + kidLevel,\n                       kidLevelMin <= kidLevel);\n            SolrInputDocument origChild = findDecendent(origDoc, kidId);\n            assertNotNull(docId + \" doesn't have decendent \" + kidId,\n                          origChild);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a52341299179de5479672f7cf518bf4b173f34b3":["bafca15d8e408346a67f4282ad1143b88023893b","87405ce5d9e414377a5dcdcd407fc75c4454a19e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"87405ce5d9e414377a5dcdcd407fc75c4454a19e":["bafca15d8e408346a67f4282ad1143b88023893b"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["bafca15d8e408346a67f4282ad1143b88023893b","87405ce5d9e414377a5dcdcd407fc75c4454a19e"],"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bafca15d8e408346a67f4282ad1143b88023893b":["23d4fcf7ecbff00440f8af034b6a8eeec65a0583"],"23d4fcf7ecbff00440f8af034b6a8eeec65a0583":["9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"373ea6b2f051d2a56e8e78a5da11de7aa52ed399":["a52341299179de5479672f7cf518bf4b173f34b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["373ea6b2f051d2a56e8e78a5da11de7aa52ed399"]},"commit2Childs":{"a52341299179de5479672f7cf518bf4b173f34b3":["373ea6b2f051d2a56e8e78a5da11de7aa52ed399"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"87405ce5d9e414377a5dcdcd407fc75c4454a19e":["a52341299179de5479672f7cf518bf4b173f34b3","936cdd5882761db3b844afd6f84ab81cbb011a75"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1":["23d4fcf7ecbff00440f8af034b6a8eeec65a0583"],"bafca15d8e408346a67f4282ad1143b88023893b":["a52341299179de5479672f7cf518bf4b173f34b3","87405ce5d9e414377a5dcdcd407fc75c4454a19e","936cdd5882761db3b844afd6f84ab81cbb011a75"],"23d4fcf7ecbff00440f8af034b6a8eeec65a0583":["bafca15d8e408346a67f4282ad1143b88023893b"],"373ea6b2f051d2a56e8e78a5da11de7aa52ed399":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}