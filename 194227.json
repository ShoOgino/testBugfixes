{"path":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","commits":[{"id":"ac981db60ef979233b3438ec49ddae82e8cc4697","date":1503407558,"type":0,"author":"Toke Eskildsen","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","pathOld":"/dev/null","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n    \n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","pathOld":"/dev/null","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n    \n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69134590ccbc41a1e613d81c884dda8005fdcfea","date":1523122465,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    assumeFalse(\"Don't run this massive test with MemoryPostingsFormat, as it can OOM\",\n        Objects.equals(Codec.getDefault().postingsFormat().getName(), \"Memory\"));\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n    \n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n    \n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa62115b9e45c213699273acb13af242762232e4","date":1523184285,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    assumeFalse(\"Don't run this massive test with MemoryPostingsFormat, as it can OOM\",\n        Objects.equals(Codec.getDefault().postingsFormat().getName(), \"Memory\"));\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n    \n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n    \n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ae3b56523ea072233ba817a3da28207b44dc3a9","date":1523888644,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    assumeFalse(\"Don't run this massive test with MemoryPostingsFormat, as it can OOM\",\n        Objects.equals(Codec.getDefault().postingsFormat().getName(), \"Memory\"));\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n    \n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ae3b56523ea072233ba817a3da28207b44dc3a9":["aa62115b9e45c213699273acb13af242762232e4"],"aa62115b9e45c213699273acb13af242762232e4":["ac981db60ef979233b3438ec49ddae82e8cc4697","69134590ccbc41a1e613d81c884dda8005fdcfea"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac981db60ef979233b3438ec49ddae82e8cc4697"],"ac981db60ef979233b3438ec49ddae82e8cc4697":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"69134590ccbc41a1e613d81c884dda8005fdcfea":["ac981db60ef979233b3438ec49ddae82e8cc4697"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ae3b56523ea072233ba817a3da28207b44dc3a9"]},"commit2Childs":{"5ae3b56523ea072233ba817a3da28207b44dc3a9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aa62115b9e45c213699273acb13af242762232e4":["5ae3b56523ea072233ba817a3da28207b44dc3a9"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"ac981db60ef979233b3438ec49ddae82e8cc4697":["aa62115b9e45c213699273acb13af242762232e4","3a7809d1d753b67f48b1a706e17034bf8b624ea3","69134590ccbc41a1e613d81c884dda8005fdcfea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","ac981db60ef979233b3438ec49ddae82e8cc4697"],"69134590ccbc41a1e613d81c884dda8005fdcfea":["aa62115b9e45c213699273acb13af242762232e4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}