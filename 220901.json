{"path":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"/dev/null","sourceNew":"  public void testGeneral() throws Exception {\n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    doTestDegreeRads();\n    doTestFuncs();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":null,"sourceOld":"  public void testGeneral() throws Exception {\n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    doTestDegreeRads();\n    doTestFuncs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  public void testGeneral() throws Exception {\n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    doTestDegreeRads();\n    doTestFuncs();\n  }\n\n","sourceOld":"  public void testGeneral() throws Exception {\n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    doTestDegreeRads();\n    doTestFuncs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"/dev/null","sourceNew":"  public void testGeneral() throws Exception {\n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    doTestDegreeRads();\n    doTestFuncs();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68759a52d8da5c4ac149c4484a1dbc071b480bb3","date":1276544744,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  public void testGeneral() throws Exception {\n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    doTestDegreeRads();\n    doTestFuncs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15345a5c40a4fa937f1b1b8462ddd6677135378a","date":1276548894,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  public void testGeneral() throws Exception {\n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\"));\n    assertU(commit());\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    doTestDegreeRads();\n    doTestFuncs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a9672b47b5b54b62cbb4f69567f186ce9d8488e","date":1285166890,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58f6207f98d96eddff4bee41c445792c249e5b74","date":1285448770,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","date":1292210954,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e00f80591de714c6975f454e33e0fa5218b5902","date":1294514405,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"771281b4c7dc712b48ba338b970b49007ca402a1","date":1295480908,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.lengthNorm(\"a_t\",4)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a segment by itself\n    assertU(commit());\n\n    // batman and superman have the same idf in single-doc segment, but very different in the complete index.\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ce8d53d5582eaa6a0c771c9b119d480f41da59c","date":1297466174,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(\"a_t\",state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89fd70ba895695c81afb216df6886df4475e628e","date":1308801640,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d360521fe78bb127e16d45a4630582bb8e85df2","date":1309719760,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}totaltermfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='7.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eecaced7ccbed629f8cd10476146628eb442238a","date":1309731982,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}totaltermfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='7.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    Similarity similarity = new DefaultSimilarity();\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f3cee3d20b0c786e6fca20539454262e29edcab","date":1310101685,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1291e4568eb7d9463d751627596ef14baf4c1603","date":1310112572,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"eecaced7ccbed629f8cd10476146628eb442238a":["6d360521fe78bb127e16d45a4630582bb8e85df2"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","5ce8d53d5582eaa6a0c771c9b119d480f41da59c"],"15345a5c40a4fa937f1b1b8462ddd6677135378a":["68759a52d8da5c4ac149c4484a1dbc071b480bb3"],"c26f00b574427b55127e869b935845554afde1fa":["0f3cee3d20b0c786e6fca20539454262e29edcab","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"3e00f80591de714c6975f454e33e0fa5218b5902":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","771281b4c7dc712b48ba338b970b49007ca402a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0a9672b47b5b54b62cbb4f69567f186ce9d8488e":["15345a5c40a4fa937f1b1b8462ddd6677135378a"],"68759a52d8da5c4ac149c4484a1dbc071b480bb3":["1da8d55113b689b06716246649de6f62430f15c0"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["e79a6d080bdd5b2a8f56342cf571b5476de04180","5ce8d53d5582eaa6a0c771c9b119d480f41da59c"],"0f3cee3d20b0c786e6fca20539454262e29edcab":["eecaced7ccbed629f8cd10476146628eb442238a"],"89fd70ba895695c81afb216df6886df4475e628e":["5ce8d53d5582eaa6a0c771c9b119d480f41da59c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["58f6207f98d96eddff4bee41c445792c249e5b74","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"5f4e87790277826a2aea119328600dfb07761f32":["1da8d55113b689b06716246649de6f62430f15c0","15345a5c40a4fa937f1b1b8462ddd6677135378a"],"2553b00f699380c64959ccb27991289aae87be2e":["5ce8d53d5582eaa6a0c771c9b119d480f41da59c","89fd70ba895695c81afb216df6886df4475e628e"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["5ce8d53d5582eaa6a0c771c9b119d480f41da59c","eecaced7ccbed629f8cd10476146628eb442238a"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["868da859b43505d9d2a023bfeae6dd0c795f5295","771281b4c7dc712b48ba338b970b49007ca402a1"],"58f6207f98d96eddff4bee41c445792c249e5b74":["0a9672b47b5b54b62cbb4f69567f186ce9d8488e"],"771281b4c7dc712b48ba338b970b49007ca402a1":["3e00f80591de714c6975f454e33e0fa5218b5902"],"1291e4568eb7d9463d751627596ef14baf4c1603":["d083e83f225b11e5fdd900e83d26ddb385b6955c","0f3cee3d20b0c786e6fca20539454262e29edcab"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["58f6207f98d96eddff4bee41c445792c249e5b74"],"6d360521fe78bb127e16d45a4630582bb8e85df2":["89fd70ba895695c81afb216df6886df4475e628e"],"5ce8d53d5582eaa6a0c771c9b119d480f41da59c":["771281b4c7dc712b48ba338b970b49007ca402a1"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["0f3cee3d20b0c786e6fca20539454262e29edcab"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3e00f80591de714c6975f454e33e0fa5218b5902"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"eecaced7ccbed629f8cd10476146628eb442238a":["0f3cee3d20b0c786e6fca20539454262e29edcab","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":[],"15345a5c40a4fa937f1b1b8462ddd6677135378a":["0a9672b47b5b54b62cbb4f69567f186ce9d8488e","5f4e87790277826a2aea119328600dfb07761f32"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"1da8d55113b689b06716246649de6f62430f15c0":["68759a52d8da5c4ac149c4484a1dbc071b480bb3","5f4e87790277826a2aea119328600dfb07761f32"],"3e00f80591de714c6975f454e33e0fa5218b5902":["771281b4c7dc712b48ba338b970b49007ca402a1","868da859b43505d9d2a023bfeae6dd0c795f5295"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"0a9672b47b5b54b62cbb4f69567f186ce9d8488e":["58f6207f98d96eddff4bee41c445792c249e5b74"],"68759a52d8da5c4ac149c4484a1dbc071b480bb3":["15345a5c40a4fa937f1b1b8462ddd6677135378a"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"0f3cee3d20b0c786e6fca20539454262e29edcab":["c26f00b574427b55127e869b935845554afde1fa","1291e4568eb7d9463d751627596ef14baf4c1603","a258fbb26824fd104ed795e5d9033d2d040049ee"],"89fd70ba895695c81afb216df6886df4475e628e":["2553b00f699380c64959ccb27991289aae87be2e","6d360521fe78bb127e16d45a4630582bb8e85df2"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["1291e4568eb7d9463d751627596ef14baf4c1603"],"58f6207f98d96eddff4bee41c445792c249e5b74":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"771281b4c7dc712b48ba338b970b49007ca402a1":["29ef99d61cda9641b6250bf9567329a6e65f901d","e79a6d080bdd5b2a8f56342cf571b5476de04180","5ce8d53d5582eaa6a0c771c9b119d480f41da59c"],"1291e4568eb7d9463d751627596ef14baf4c1603":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3e00f80591de714c6975f454e33e0fa5218b5902","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"6d360521fe78bb127e16d45a4630582bb8e85df2":["eecaced7ccbed629f8cd10476146628eb442238a"],"5ce8d53d5582eaa6a0c771c9b119d480f41da59c":["f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac","89fd70ba895695c81afb216df6886df4475e628e","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac","1291e4568eb7d9463d751627596ef14baf4c1603","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}