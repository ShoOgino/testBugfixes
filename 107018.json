{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#incrementToken().mjava","commits":[{"id":"24a98f5fdd23e04f85819dbc63b47a12f7c44311","date":1482439157,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    //System.out.println(\"\\nS: incrToken lastNodeOut=\" + lastNodeOut + \" nextNodeOut=\" + nextNodeOut);\n\n    assert lastNodeOut <= nextNodeOut;\n      \n    if (outputBuffer.isEmpty() == false) {\n      // We still have pending outputs from a prior synonym match:\n      releaseBufferedToken();\n      //System.out.println(\"  syn: ret buffered=\" + this);\n      assert liveToken == false;\n      return true;\n    }\n\n    // Try to parse a new synonym match at the current token:\n\n    if (parse()) {\n      // A new match was found:\n      releaseBufferedToken();\n      //System.out.println(\"  syn: after parse, ret buffered=\" + this);\n      assert liveToken == false;\n      return true;\n    }\n\n    if (lookaheadNextRead == lookaheadNextWrite) {\n\n      // Fast path: parse pulled one token, but it didn't match\n      // the start for any synonym, so we now return it \"live\" w/o having\n      // cloned all of its atts:\n      if (finished) {\n        //System.out.println(\"  syn: ret END\");\n        return false;\n      }\n\n      assert liveToken;\n      liveToken = false;\n\n      // NOTE: no need to change posInc since it's relative, i.e. whatever\n      // node our output is upto will just increase by the incoming posInc.\n      // We also don't need to change posLen, but only because we cannot\n      // consume a graph, so the incoming token can never span a future\n      // synonym match.\n\n    } else {\n      // We still have buffered lookahead tokens from a previous\n      // parse attempt that required lookahead; just replay them now:\n      //System.out.println(\"  restore buffer\");\n      assert lookaheadNextRead < lookaheadNextWrite: \"read=\" + lookaheadNextRead + \" write=\" + lookaheadNextWrite;\n      BufferedInputToken token = lookahead.get(lookaheadNextRead);\n      lookaheadNextRead++;\n\n      restoreState(token.state);\n\n      lookahead.freeBefore(lookaheadNextRead);\n\n      //System.out.println(\"  after restore offset=\" + offsetAtt.startOffset() + \"-\" + offsetAtt.endOffset());\n      assert liveToken == false;\n    }\n\n    lastNodeOut += posIncrAtt.getPositionIncrement();\n    nextNodeOut = lastNodeOut + posLenAtt.getPositionLength();\n\n    //System.out.println(\"  syn: ret lookahead=\" + this);\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    //System.out.println(\"\\nS: incrToken lastNodeOut=\" + lastNodeOut + \" nextNodeOut=\" + nextNodeOut);\n\n    assert lastNodeOut <= nextNodeOut;\n      \n    if (outputBuffer.isEmpty() == false) {\n      // We still have pending outputs from a prior synonym match:\n      releaseBufferedToken();\n      //System.out.println(\"  syn: ret buffered=\" + this);\n      assert liveToken == false;\n      return true;\n    }\n\n    // Try to parse a new synonym match at the current token:\n\n    if (parse()) {\n      // A new match was found:\n      releaseBufferedToken();\n      //System.out.println(\"  syn: after parse, ret buffered=\" + this);\n      assert liveToken == false;\n      return true;\n    }\n\n    if (lookaheadNextRead == lookaheadNextWrite) {\n\n      // Fast path: parse pulled one token, but it didn't match\n      // the start for any synonym, so we now return it \"live\" w/o having\n      // cloned all of its atts:\n      if (finished) {\n        //System.out.println(\"  syn: ret END\");\n        return false;\n      }\n\n      assert liveToken;\n      liveToken = false;\n\n      // NOTE: no need to change posInc since it's relative, i.e. whatever\n      // node our output is upto will just increase by the incoming posInc.\n      // We also don't need to change posLen, but only because we cannot\n      // consume a graph, so the incoming token can never span a future\n      // synonym match.\n\n    } else {\n      // We still have buffered lookahead tokens from a previous\n      // parse attempt that required lookahead; just replay them now:\n      //System.out.println(\"  restore buffer\");\n      assert lookaheadNextRead < lookaheadNextWrite: \"read=\" + lookaheadNextRead + \" write=\" + lookaheadNextWrite;\n      BufferedInputToken token = lookahead.get(lookaheadNextRead);\n      lookaheadNextRead++;\n\n      restoreState(token.state);\n\n      lookahead.freeBefore(lookaheadNextRead);\n\n      //System.out.println(\"  after restore offset=\" + offsetAtt.startOffset() + \"-\" + offsetAtt.endOffset());\n      assert liveToken == false;\n    }\n\n    lastNodeOut += posIncrAtt.getPositionIncrement();\n    nextNodeOut = lastNodeOut + posLenAtt.getPositionLength();\n\n    //System.out.println(\"  syn: ret lookahead=\" + this);\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"24a98f5fdd23e04f85819dbc63b47a12f7c44311":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["24a98f5fdd23e04f85819dbc63b47a12f7c44311"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","24a98f5fdd23e04f85819dbc63b47a12f7c44311"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["24a98f5fdd23e04f85819dbc63b47a12f7c44311","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"24a98f5fdd23e04f85819dbc63b47a12f7c44311":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}