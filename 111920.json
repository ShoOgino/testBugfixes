{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/MergeStream#read().mjava","commits":[{"id":"f00f1c5fad501b66705121feb623f8cfbb6712f9","date":1431347838,"type":1,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/MergeStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/MergeStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    Tuple a = streamA.read();\n    Tuple b = streamB.read();\n\n    if(a.EOF && b.EOF) {\n      return a;\n    }\n\n    if(a.EOF) {\n      streamA.pushBack(a);\n      return b;\n    }\n\n    if(b.EOF) {\n      streamB.pushBack(b);\n      return a;\n    }\n\n    int c = comp.compare(a,b);\n\n    if(c < 0) {\n      streamB.pushBack(b);\n      return a;\n    } else {\n      streamA.pushBack(a);\n      return b;\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    Tuple a = streamA.read();\n    Tuple b = streamB.read();\n\n    if(a.EOF && b.EOF) {\n      return a;\n    }\n\n    if(a.EOF) {\n      streamA.pushBack(a);\n      return b;\n    }\n\n    if(b.EOF) {\n      streamB.pushBack(b);\n      return a;\n    }\n\n    int c = comp.compare(a,b);\n\n    if(c < 0) {\n      streamB.pushBack(b);\n      return a;\n    } else {\n      streamA.pushBack(a);\n      return b;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1dab63e86bdbacdfab7b33cc35bd2ebd5785bce3","date":1446934136,"type":3,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/MergeStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/MergeStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    \n    // might be able to optimize this by sorting the streams based on the next to read tuple from each.\n    // if we can ensure the sort of the streams and update it in less than linear time then there would\n    // be some performance gain. But, assuming the # of streams is kinda small then this might not be\n    // worth it\n    \n    Tuple minimum = null;\n    PushBackStream minimumStream = null;\n    for(PushBackStream stream : streams){\n      Tuple current = stream.read();\n      \n      if(current.EOF){\n        stream.pushBack(current);\n        continue;\n      }\n      \n      if(null == minimum){\n        minimum = current;\n        minimumStream = stream;\n        continue;\n      }\n      \n      if(comp.compare(current, minimum) < 0){\n        // Push back on its stream\n        minimumStream.pushBack(minimum);\n        \n        minimum = current;\n        minimumStream = stream;\n        continue;\n      }\n      else{\n        stream.pushBack(current);\n      }\n    }\n    \n    // If all EOF then min will be null, else min is the current minimum\n    if(null == minimum){\n      // return EOF, doesn't matter which cause we're done\n      return streams[0].read();\n    }\n    \n    return minimum;\n    \n//    Tuple a = streamA.read();\n//    Tuple b = streamB.read();\n//\n//    if(a.EOF && b.EOF) {\n//      return a;\n//    }\n//\n//    if(a.EOF) {\n//      streamA.pushBack(a);\n//      return b;\n//    }\n//\n//    if(b.EOF) {\n//      streamB.pushBack(b);\n//      return a;\n//    }\n//\n//    int c = comp.compare(a,b);\n//\n//    if(c < 0) {\n//      streamB.pushBack(b);\n//      return a;\n//    } else {\n//      streamA.pushBack(a);\n//      return b;\n//    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    Tuple a = streamA.read();\n    Tuple b = streamB.read();\n\n    if(a.EOF && b.EOF) {\n      return a;\n    }\n\n    if(a.EOF) {\n      streamA.pushBack(a);\n      return b;\n    }\n\n    if(b.EOF) {\n      streamB.pushBack(b);\n      return a;\n    }\n\n    int c = comp.compare(a,b);\n\n    if(c < 0) {\n      streamB.pushBack(b);\n      return a;\n    } else {\n      streamA.pushBack(a);\n      return b;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f00f1c5fad501b66705121feb623f8cfbb6712f9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1dab63e86bdbacdfab7b33cc35bd2ebd5785bce3":["f00f1c5fad501b66705121feb623f8cfbb6712f9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1dab63e86bdbacdfab7b33cc35bd2ebd5785bce3"]},"commit2Childs":{"f00f1c5fad501b66705121feb623f8cfbb6712f9":["1dab63e86bdbacdfab7b33cc35bd2ebd5785bce3"],"1dab63e86bdbacdfab7b33cc35bd2ebd5785bce3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f00f1c5fad501b66705121feb623f8cfbb6712f9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}