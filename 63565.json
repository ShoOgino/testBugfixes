{"path":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.NearestVisitor#visit(int,byte[]).mjava","commits":[{"id":"1b73cddaec09172a09da82e758d0014ab8810ffa","date":1506898255,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.NearestVisitor#visit(int,byte[]).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void visit(int docID, byte[] packedValue) {\n      // System.out.println(\"visit docID=\" + docID + \" liveDocs=\" + curLiveDocs);\n\n      if (curLiveDocs != null && curLiveDocs.get(docID) == false) {\n        return;\n      }\n\n      float[] docPoint = new float[dims];\n      for (int d = 0, offset = 0 ; d < dims ; ++d, offset += Float.BYTES) {\n        docPoint[d] = FloatPoint.decodeDimension(packedValue, offset);\n        if (docPoint[d] > max[d] || docPoint[d] < min[d]) {\n\n          // if (docPoint[d] > max[d]) {\n          //   System.out.println(\"  skipped because docPoint[\" + d + \"] (\" + docPoint[d] + \") > max[\" + d + \"] (\" + max[d] + \")\");\n          // } else {\n          //   System.out.println(\"  skipped because docPoint[\" + d + \"] (\" + docPoint[d] + \") < min[\" + d + \"] (\" + min[d] + \")\");\n          // }\n\n          return;\n        }\n      }\n        \n      double distanceSquared = euclideanDistanceSquared(origin, docPoint);\n\n      // System.out.println(\"    visit docID=\" + docID + \" distanceSquared=\" + distanceSquared + \" value: \" + Arrays.toString(docPoint));\n\n      int fullDocID = curDocBase + docID;\n\n      if (hitQueue.size() == topN) { // queue already full\n        NearestHit bottom = hitQueue.peek();\n        // System.out.println(\"      bottom distanceSquared=\" + bottom.distanceSquared);\n        if (distanceSquared < bottom.distanceSquared\n            // we don't collect docs in order here, so we must also test the tie-break case ourselves:\n            || (distanceSquared == bottom.distanceSquared && fullDocID < bottom.docID)) {\n          hitQueue.poll();\n          bottom.docID = fullDocID;\n          bottom.distanceSquared = distanceSquared;\n          hitQueue.offer(bottom);\n          // System.out.println(\"      ** keep1, now bottom=\" + bottom);\n          maybeUpdateMinMax();\n        }\n      } else {\n        NearestHit hit = new NearestHit();\n        hit.docID = fullDocID;\n        hit.distanceSquared = distanceSquared;\n        hitQueue.offer(hit);\n        // System.out.println(\"      ** keep2, new addition=\" + hit);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.NearestVisitor#visit(int,byte[]).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void visit(int docID, byte[] packedValue) {\n      // System.out.println(\"visit docID=\" + docID + \" liveDocs=\" + curLiveDocs);\n\n      if (curLiveDocs != null && curLiveDocs.get(docID) == false) {\n        return;\n      }\n\n      float[] docPoint = new float[dims];\n      for (int d = 0, offset = 0 ; d < dims ; ++d, offset += Float.BYTES) {\n        docPoint[d] = FloatPoint.decodeDimension(packedValue, offset);\n        if (docPoint[d] > max[d] || docPoint[d] < min[d]) {\n\n          // if (docPoint[d] > max[d]) {\n          //   System.out.println(\"  skipped because docPoint[\" + d + \"] (\" + docPoint[d] + \") > max[\" + d + \"] (\" + max[d] + \")\");\n          // } else {\n          //   System.out.println(\"  skipped because docPoint[\" + d + \"] (\" + docPoint[d] + \") < min[\" + d + \"] (\" + min[d] + \")\");\n          // }\n\n          return;\n        }\n      }\n        \n      double distanceSquared = euclideanDistanceSquared(origin, docPoint);\n\n      // System.out.println(\"    visit docID=\" + docID + \" distanceSquared=\" + distanceSquared + \" value: \" + Arrays.toString(docPoint));\n\n      int fullDocID = curDocBase + docID;\n\n      if (hitQueue.size() == topN) { // queue already full\n        NearestHit bottom = hitQueue.peek();\n        // System.out.println(\"      bottom distanceSquared=\" + bottom.distanceSquared);\n        if (distanceSquared < bottom.distanceSquared\n            // we don't collect docs in order here, so we must also test the tie-break case ourselves:\n            || (distanceSquared == bottom.distanceSquared && fullDocID < bottom.docID)) {\n          hitQueue.poll();\n          bottom.docID = fullDocID;\n          bottom.distanceSquared = distanceSquared;\n          hitQueue.offer(bottom);\n          // System.out.println(\"      ** keep1, now bottom=\" + bottom);\n          maybeUpdateMinMax();\n        }\n      } else {\n        NearestHit hit = new NearestHit();\n        hit.docID = fullDocID;\n        hit.distanceSquared = distanceSquared;\n        hitQueue.offer(hit);\n        // System.out.println(\"      ** keep2, new addition=\" + hit);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"097748fa4ff327a26994476115f52d1a899b549f","date":1568267320,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.NearestVisitor#visit(int,byte[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.NearestVisitor#visit(int,byte[]).mjava","sourceNew":"    @Override\n    public void visit(int docID, byte[] packedValue) {\n      // System.out.println(\"visit docID=\" + docID + \" liveDocs=\" + curLiveDocs);;\n      if (curLiveDocs != null && curLiveDocs.get(docID) == false) {\n        return;\n      }\n\n      double distanceSquared = 0.0d;\n      for (int d = 0, offset = 0 ; d < dims ; ++d, offset += Float.BYTES) {\n        double diff = (double) FloatPoint.decodeDimension(packedValue, offset) - (double) origin[d];\n        distanceSquared += diff * diff;\n        if (distanceSquared > bottomNearestDistanceSquared) {\n          return;\n        }\n      }\n\n      // System.out.println(\"    visit docID=\" + docID + \" distanceSquared=\" + distanceSquared + \" value: \" + Arrays.toString(docPoint));\n\n      int fullDocID = curDocBase + docID;\n\n      if (hitQueue.size() == topN) { // queue already full\n        if (distanceSquared == bottomNearestDistanceSquared && fullDocID > bottomNearestDistanceDoc) {\n          return;\n        }\n        NearestHit bottom = hitQueue.poll();\n        // System.out.println(\"      bottom distanceSquared=\" + bottom.distanceSquared);\n        bottom.docID = fullDocID;\n        bottom.distanceSquared = distanceSquared;\n        hitQueue.offer(bottom);\n        updateBottomNearestDistance();\n          // System.out.println(\"      ** keep1, now bottom=\" + bottom);\n      } else {\n        NearestHit hit = new NearestHit();\n        hit.docID = fullDocID;\n        hit.distanceSquared = distanceSquared;\n        hitQueue.offer(hit);\n        if (hitQueue.size() == topN) {\n          updateBottomNearestDistance();\n        }\n        // System.out.println(\"      ** keep2, new addition=\" + hit);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void visit(int docID, byte[] packedValue) {\n      // System.out.println(\"visit docID=\" + docID + \" liveDocs=\" + curLiveDocs);\n\n      if (curLiveDocs != null && curLiveDocs.get(docID) == false) {\n        return;\n      }\n\n      float[] docPoint = new float[dims];\n      for (int d = 0, offset = 0 ; d < dims ; ++d, offset += Float.BYTES) {\n        docPoint[d] = FloatPoint.decodeDimension(packedValue, offset);\n        if (docPoint[d] > max[d] || docPoint[d] < min[d]) {\n\n          // if (docPoint[d] > max[d]) {\n          //   System.out.println(\"  skipped because docPoint[\" + d + \"] (\" + docPoint[d] + \") > max[\" + d + \"] (\" + max[d] + \")\");\n          // } else {\n          //   System.out.println(\"  skipped because docPoint[\" + d + \"] (\" + docPoint[d] + \") < min[\" + d + \"] (\" + min[d] + \")\");\n          // }\n\n          return;\n        }\n      }\n        \n      double distanceSquared = euclideanDistanceSquared(origin, docPoint);\n\n      // System.out.println(\"    visit docID=\" + docID + \" distanceSquared=\" + distanceSquared + \" value: \" + Arrays.toString(docPoint));\n\n      int fullDocID = curDocBase + docID;\n\n      if (hitQueue.size() == topN) { // queue already full\n        NearestHit bottom = hitQueue.peek();\n        // System.out.println(\"      bottom distanceSquared=\" + bottom.distanceSquared);\n        if (distanceSquared < bottom.distanceSquared\n            // we don't collect docs in order here, so we must also test the tie-break case ourselves:\n            || (distanceSquared == bottom.distanceSquared && fullDocID < bottom.docID)) {\n          hitQueue.poll();\n          bottom.docID = fullDocID;\n          bottom.distanceSquared = distanceSquared;\n          hitQueue.offer(bottom);\n          // System.out.println(\"      ** keep1, now bottom=\" + bottom);\n          maybeUpdateMinMax();\n        }\n      } else {\n        NearestHit hit = new NearestHit();\n        hit.docID = fullDocID;\n        hit.distanceSquared = distanceSquared;\n        hitQueue.offer(hit);\n        // System.out.println(\"      ** keep2, new addition=\" + hit);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b73cddaec09172a09da82e758d0014ab8810ffa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1b73cddaec09172a09da82e758d0014ab8810ffa"],"097748fa4ff327a26994476115f52d1a899b549f":["1b73cddaec09172a09da82e758d0014ab8810ffa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["097748fa4ff327a26994476115f52d1a899b549f"]},"commit2Childs":{"1b73cddaec09172a09da82e758d0014ab8810ffa":["6240b74b884c5587f2a4062dd27d6c32bf228889","097748fa4ff327a26994476115f52d1a899b549f"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"097748fa4ff327a26994476115f52d1a899b549f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1b73cddaec09172a09da82e758d0014ab8810ffa","6240b74b884c5587f2a4062dd27d6c32bf228889"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}