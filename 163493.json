{"path":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#handleGetRanges(CoreAdminHandler.CallInfo,String).mjava","commits":[{"id":"a05f3f5161c62339ec5560b8f6958f3df8483618","date":1563550501,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#handleGetRanges(CoreAdminHandler.CallInfo,String).mjava","pathOld":"/dev/null","sourceNew":"  // This is called when splitByPrefix is used.\n  // The overseer called us to get recommended splits taking into\n  // account actual document distribution over the hash space.\n  private void handleGetRanges(CoreAdminHandler.CallInfo it, String coreName) throws Exception {\n\n    SolrCore parentCore = it.handler.coreContainer.getCore(coreName);\n    if (parentCore == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown core \" + coreName);\n    }\n\n    RefCounted<SolrIndexSearcher> searcherHolder = parentCore.getRealtimeSearcher();\n\n    try {\n      if (!it.handler.coreContainer.isZooKeeperAware()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Shard splitByPrefix requires SolrCloud mode.\");\n      } else {\n        String routeFieldName = \"id\";\n        String prefixField = \"id_prefix\";\n\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        DocRouter router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        DocRouter.Range currentRange = slice.getRange();\n\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n\n        Collection<RangeCount> counts = getHashHistogram(searcherHolder.get(), prefixField, router, collection);\n        Collection<DocRouter.Range> splits = getSplits(counts, currentRange);\n        String splitString = toSplitString(splits);\n\n        if (splitString == null) {\n          return;\n        }\n\n        it.rsp.add(CoreAdminParams.RANGES, splitString);\n      }\n    } finally {\n      if (searcherHolder != null) searcherHolder.decref();\n      if (parentCore != null) parentCore.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36bdabc04743acfe0e82c9cf8208b1111b2b193a","date":1565115020,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#handleGetRanges(CoreAdminHandler.CallInfo,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#handleGetRanges(CoreAdminHandler.CallInfo,String).mjava","sourceNew":"  /**\n   *   This is called when splitByPrefix is used.\n   *   The overseer called us to get recommended splits taking into\n   *   account actual document distribution over the hash space.\n   */\n  private void handleGetRanges(CoreAdminHandler.CallInfo it, String coreName) throws Exception {\n\n    SolrCore parentCore = it.handler.coreContainer.getCore(coreName);\n    if (parentCore == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown core \" + coreName);\n    }\n\n    RefCounted<SolrIndexSearcher> searcherHolder = parentCore.getRealtimeSearcher();\n\n    try {\n      if (!it.handler.coreContainer.isZooKeeperAware()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Shard splitByPrefix requires SolrCloud mode.\");\n      } else {\n        SolrIndexSearcher searcher = searcherHolder.get();\n\n        String routeFieldName = null;\n        String prefixField = \"id_prefix\";\n\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        DocRouter router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        DocRouter.Range currentRange = slice.getRange();\n\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n        if (routeFieldName == null) {\n          routeFieldName = searcher.getSchema().getUniqueKeyField().getName();\n        }\n\n        Collection<RangeCount> counts = getHashHistogram(searcher, prefixField, router, collection);\n\n        if (counts.size() == 0) {\n          // How to determine if we should look at the id field to figure out the prefix buckets?\n          // There may legitimately be no indexed terms in id_prefix if no ids have a prefix yet.\n          // For now, avoid using splitByPrefix unless you are actually using prefixes.\n          counts = getHashHistogramFromId(searcher, searcher.getSchema().getUniqueKeyField().getName(), router, collection);\n        }\n\n        Collection<DocRouter.Range> splits = getSplits(counts, currentRange);\n        String splitString = toSplitString(splits);\n\n        if (splitString == null) {\n          return;\n        }\n\n        it.rsp.add(CoreAdminParams.RANGES, splitString);\n      }\n    } finally {\n      if (searcherHolder != null) searcherHolder.decref();\n      if (parentCore != null) parentCore.close();\n    }\n  }\n\n","sourceOld":"  // This is called when splitByPrefix is used.\n  // The overseer called us to get recommended splits taking into\n  // account actual document distribution over the hash space.\n  private void handleGetRanges(CoreAdminHandler.CallInfo it, String coreName) throws Exception {\n\n    SolrCore parentCore = it.handler.coreContainer.getCore(coreName);\n    if (parentCore == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown core \" + coreName);\n    }\n\n    RefCounted<SolrIndexSearcher> searcherHolder = parentCore.getRealtimeSearcher();\n\n    try {\n      if (!it.handler.coreContainer.isZooKeeperAware()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Shard splitByPrefix requires SolrCloud mode.\");\n      } else {\n        String routeFieldName = \"id\";\n        String prefixField = \"id_prefix\";\n\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        DocRouter router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        DocRouter.Range currentRange = slice.getRange();\n\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n\n        Collection<RangeCount> counts = getHashHistogram(searcherHolder.get(), prefixField, router, collection);\n        Collection<DocRouter.Range> splits = getSplits(counts, currentRange);\n        String splitString = toSplitString(splits);\n\n        if (splitString == null) {\n          return;\n        }\n\n        it.rsp.add(CoreAdminParams.RANGES, splitString);\n      }\n    } finally {\n      if (searcherHolder != null) searcherHolder.decref();\n      if (parentCore != null) parentCore.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#handleGetRanges(CoreAdminHandler.CallInfo,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/SplitOp#handleGetRanges(CoreAdminHandler.CallInfo,String).mjava","sourceNew":"  /**\n   *   This is called when splitByPrefix is used.\n   *   The overseer called us to get recommended splits taking into\n   *   account actual document distribution over the hash space.\n   */\n  private void handleGetRanges(CoreAdminHandler.CallInfo it, String coreName) throws Exception {\n\n    SolrCore parentCore = it.handler.coreContainer.getCore(coreName);\n    if (parentCore == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown core \" + coreName);\n    }\n\n    RefCounted<SolrIndexSearcher> searcherHolder = parentCore.getRealtimeSearcher();\n\n    try {\n      if (!it.handler.coreContainer.isZooKeeperAware()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Shard splitByPrefix requires SolrCloud mode.\");\n      } else {\n        SolrIndexSearcher searcher = searcherHolder.get();\n\n        String routeFieldName = null;\n        String prefixField = \"id_prefix\";\n\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        DocRouter router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        DocRouter.Range currentRange = slice.getRange();\n\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          @SuppressWarnings({\"rawtypes\"})\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n        if (routeFieldName == null) {\n          routeFieldName = searcher.getSchema().getUniqueKeyField().getName();\n        }\n\n        Collection<RangeCount> counts = getHashHistogram(searcher, prefixField, router, collection);\n\n        if (counts.size() == 0) {\n          // How to determine if we should look at the id field to figure out the prefix buckets?\n          // There may legitimately be no indexed terms in id_prefix if no ids have a prefix yet.\n          // For now, avoid using splitByPrefix unless you are actually using prefixes.\n          counts = getHashHistogramFromId(searcher, searcher.getSchema().getUniqueKeyField().getName(), router, collection);\n        }\n\n        Collection<DocRouter.Range> splits = getSplits(counts, currentRange);\n        String splitString = toSplitString(splits);\n\n        if (splitString == null) {\n          return;\n        }\n\n        it.rsp.add(CoreAdminParams.RANGES, splitString);\n      }\n    } finally {\n      if (searcherHolder != null) searcherHolder.decref();\n      if (parentCore != null) parentCore.close();\n    }\n  }\n\n","sourceOld":"  /**\n   *   This is called when splitByPrefix is used.\n   *   The overseer called us to get recommended splits taking into\n   *   account actual document distribution over the hash space.\n   */\n  private void handleGetRanges(CoreAdminHandler.CallInfo it, String coreName) throws Exception {\n\n    SolrCore parentCore = it.handler.coreContainer.getCore(coreName);\n    if (parentCore == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown core \" + coreName);\n    }\n\n    RefCounted<SolrIndexSearcher> searcherHolder = parentCore.getRealtimeSearcher();\n\n    try {\n      if (!it.handler.coreContainer.isZooKeeperAware()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Shard splitByPrefix requires SolrCloud mode.\");\n      } else {\n        SolrIndexSearcher searcher = searcherHolder.get();\n\n        String routeFieldName = null;\n        String prefixField = \"id_prefix\";\n\n        ClusterState clusterState = it.handler.coreContainer.getZkController().getClusterState();\n        String collectionName = parentCore.getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = parentCore.getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = collection.getSlice(sliceName);\n        DocRouter router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        DocRouter.Range currentRange = slice.getRange();\n\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n        if (routeFieldName == null) {\n          routeFieldName = searcher.getSchema().getUniqueKeyField().getName();\n        }\n\n        Collection<RangeCount> counts = getHashHistogram(searcher, prefixField, router, collection);\n\n        if (counts.size() == 0) {\n          // How to determine if we should look at the id field to figure out the prefix buckets?\n          // There may legitimately be no indexed terms in id_prefix if no ids have a prefix yet.\n          // For now, avoid using splitByPrefix unless you are actually using prefixes.\n          counts = getHashHistogramFromId(searcher, searcher.getSchema().getUniqueKeyField().getName(), router, collection);\n        }\n\n        Collection<DocRouter.Range> splits = getSplits(counts, currentRange);\n        String splitString = toSplitString(splits);\n\n        if (splitString == null) {\n          return;\n        }\n\n        it.rsp.add(CoreAdminParams.RANGES, splitString);\n      }\n    } finally {\n      if (searcherHolder != null) searcherHolder.decref();\n      if (parentCore != null) parentCore.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba055e19afc289adcb5bedaf68513793a7254012":["36bdabc04743acfe0e82c9cf8208b1111b2b193a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a05f3f5161c62339ec5560b8f6958f3df8483618":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"36bdabc04743acfe0e82c9cf8208b1111b2b193a":["a05f3f5161c62339ec5560b8f6958f3df8483618"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ba055e19afc289adcb5bedaf68513793a7254012"]},"commit2Childs":{"ba055e19afc289adcb5bedaf68513793a7254012":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a05f3f5161c62339ec5560b8f6958f3df8483618"],"a05f3f5161c62339ec5560b8f6958f3df8483618":["36bdabc04743acfe0e82c9cf8208b1111b2b193a"],"36bdabc04743acfe0e82c9cf8208b1111b2b193a":["ba055e19afc289adcb5bedaf68513793a7254012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}