{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testPreventChangingSoftDeletesField().mjava","commits":[{"id":"eeba0a4d0845889a402dd225793d62f009d029c9","date":1527938093,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testPreventChangingSoftDeletesField().mjava","pathOld":"/dev/null","sourceNew":"  public void testPreventChangingSoftDeletesField() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"my_deletes\"));\n    Document v1 = new Document();\n    v1.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v1.add(new StringField(\"version\", \"1\", Field.Store.YES));\n    writer.addDocument(v1);\n    Document v2 = new Document();\n    v2.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v2.add(new StringField(\"version\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), v2, new NumericDocValuesField(\"my_deletes\", 1));\n    writer.commit();\n    writer.close();\n    for (SegmentCommitInfo si : SegmentInfos.readLatestCommit(dir)) {\n      FieldInfo softDeleteField = IndexWriter.readFieldInfos(si).fieldInfo(\"my_deletes\");\n      assertTrue(softDeleteField.isSoftDeletesField());\n    }\n\n    IllegalArgumentException illegalError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"your_deletes\"));\n    });\n    assertEquals(\"cannot configure [your_deletes] as soft-deletes; \" +\n        \"this index uses [my_deletes] as soft-deletes already\", illegalError.getMessage());\n\n    IndexWriterConfig softDeleteConfig = newIndexWriterConfig().setSoftDeletesField(\"my_deletes\")\n        .setMergePolicy(new SoftDeletesRetentionMergePolicy(\"my_deletes\", () -> new MatchAllDocsQuery(), newMergePolicy()));\n    writer = new IndexWriter(dir, softDeleteConfig);\n    Document tombstone = new Document();\n    tombstone.add(new StringField(\"id\", \"tombstone\", Field.Store.YES));\n    tombstone.add(new NumericDocValuesField(\"my_deletes\", 1));\n    writer.addDocument(tombstone);\n    writer.flush();\n    for (SegmentCommitInfo si : writer.segmentInfos) {\n      FieldInfo softDeleteField = IndexWriter.readFieldInfos(si).fieldInfo(\"my_deletes\");\n      assertTrue(softDeleteField.isSoftDeletesField());\n    }\n    writer.close();\n    // reopen writer without soft-deletes field should be prevented\n    IllegalArgumentException reopenError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig());\n    });\n    assertEquals(\"this index has [my_deletes] as soft-deletes already\" +\n        \" but soft-deletes field is not configured in IWC\", reopenError.getMessage());\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab548c8f96022b4780f7500a30b19b4f4a5feeb6","date":1527940044,"type":4,"author":"Simon Willnauer","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testPreventChangingSoftDeletesField().mjava","sourceNew":null,"sourceOld":"  public void testPreventChangingSoftDeletesField() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"my_deletes\"));\n    Document v1 = new Document();\n    v1.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v1.add(new StringField(\"version\", \"1\", Field.Store.YES));\n    writer.addDocument(v1);\n    Document v2 = new Document();\n    v2.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v2.add(new StringField(\"version\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), v2, new NumericDocValuesField(\"my_deletes\", 1));\n    writer.commit();\n    writer.close();\n    for (SegmentCommitInfo si : SegmentInfos.readLatestCommit(dir)) {\n      FieldInfo softDeleteField = IndexWriter.readFieldInfos(si).fieldInfo(\"my_deletes\");\n      assertTrue(softDeleteField.isSoftDeletesField());\n    }\n\n    IllegalArgumentException illegalError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"your_deletes\"));\n    });\n    assertEquals(\"cannot configure [your_deletes] as soft-deletes; \" +\n        \"this index uses [my_deletes] as soft-deletes already\", illegalError.getMessage());\n\n    IndexWriterConfig softDeleteConfig = newIndexWriterConfig().setSoftDeletesField(\"my_deletes\")\n        .setMergePolicy(new SoftDeletesRetentionMergePolicy(\"my_deletes\", () -> new MatchAllDocsQuery(), newMergePolicy()));\n    writer = new IndexWriter(dir, softDeleteConfig);\n    Document tombstone = new Document();\n    tombstone.add(new StringField(\"id\", \"tombstone\", Field.Store.YES));\n    tombstone.add(new NumericDocValuesField(\"my_deletes\", 1));\n    writer.addDocument(tombstone);\n    writer.flush();\n    for (SegmentCommitInfo si : writer.segmentInfos) {\n      FieldInfo softDeleteField = IndexWriter.readFieldInfos(si).fieldInfo(\"my_deletes\");\n      assertTrue(softDeleteField.isSoftDeletesField());\n    }\n    writer.close();\n    // reopen writer without soft-deletes field should be prevented\n    IllegalArgumentException reopenError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig());\n    });\n    assertEquals(\"this index has [my_deletes] as soft-deletes already\" +\n        \" but soft-deletes field is not configured in IWC\", reopenError.getMessage());\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7e4ca6dc9612ff741d8713743e2bccfae5eadac","date":1528093718,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testPreventChangingSoftDeletesField().mjava","pathOld":"/dev/null","sourceNew":"  public void testPreventChangingSoftDeletesField() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"my_deletes\"));\n    Document v1 = new Document();\n    v1.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v1.add(new StringField(\"version\", \"1\", Field.Store.YES));\n    writer.addDocument(v1);\n    Document v2 = new Document();\n    v2.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v2.add(new StringField(\"version\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), v2, new NumericDocValuesField(\"my_deletes\", 1));\n    writer.commit();\n    writer.close();\n    for (SegmentCommitInfo si : SegmentInfos.readLatestCommit(dir)) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n\n    IllegalArgumentException illegalError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"your_deletes\"));\n    });\n    assertEquals(\"cannot configure [your_deletes] as soft-deletes; \" +\n        \"this index uses [my_deletes] as soft-deletes already\", illegalError.getMessage());\n\n    IndexWriterConfig softDeleteConfig = newIndexWriterConfig().setSoftDeletesField(\"my_deletes\")\n        .setMergePolicy(new SoftDeletesRetentionMergePolicy(\"my_deletes\", () -> new MatchAllDocsQuery(), newMergePolicy()));\n    writer = new IndexWriter(dir, softDeleteConfig);\n    Document tombstone = new Document();\n    tombstone.add(new StringField(\"id\", \"tombstone\", Field.Store.YES));\n    tombstone.add(new NumericDocValuesField(\"my_deletes\", 1));\n    writer.addDocument(tombstone);\n    writer.flush();\n    for (SegmentCommitInfo si : writer.segmentInfos) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n    writer.close();\n    // reopen writer without soft-deletes field should be prevented\n    IllegalArgumentException reopenError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig());\n    });\n    assertEquals(\"this index has [my_deletes] as soft-deletes already\" +\n        \" but soft-deletes field is not configured in IWC\", reopenError.getMessage());\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["631ea3d1607299c59f33edef140ffc19a81f07a0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testPreventChangingSoftDeletesField().mjava","pathOld":"/dev/null","sourceNew":"  public void testPreventChangingSoftDeletesField() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"my_deletes\"));\n    Document v1 = new Document();\n    v1.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v1.add(new StringField(\"version\", \"1\", Field.Store.YES));\n    writer.addDocument(v1);\n    Document v2 = new Document();\n    v2.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v2.add(new StringField(\"version\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), v2, new NumericDocValuesField(\"my_deletes\", 1));\n    writer.commit();\n    writer.close();\n    for (SegmentCommitInfo si : SegmentInfos.readLatestCommit(dir)) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n\n    IllegalArgumentException illegalError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"your_deletes\"));\n    });\n    assertEquals(\"cannot configure [your_deletes] as soft-deletes; \" +\n        \"this index uses [my_deletes] as soft-deletes already\", illegalError.getMessage());\n\n    IndexWriterConfig softDeleteConfig = newIndexWriterConfig().setSoftDeletesField(\"my_deletes\")\n        .setMergePolicy(new SoftDeletesRetentionMergePolicy(\"my_deletes\", () -> new MatchAllDocsQuery(), newMergePolicy()));\n    writer = new IndexWriter(dir, softDeleteConfig);\n    Document tombstone = new Document();\n    tombstone.add(new StringField(\"id\", \"tombstone\", Field.Store.YES));\n    tombstone.add(new NumericDocValuesField(\"my_deletes\", 1));\n    writer.addDocument(tombstone);\n    writer.flush();\n    for (SegmentCommitInfo si : writer.segmentInfos) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n    writer.close();\n    // reopen writer without soft-deletes field should be prevented\n    IllegalArgumentException reopenError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig());\n    });\n    assertEquals(\"this index has [my_deletes] as soft-deletes already\" +\n        \" but soft-deletes field is not configured in IWC\", reopenError.getMessage());\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testPreventChangingSoftDeletesField().mjava","pathOld":"/dev/null","sourceNew":"  public void testPreventChangingSoftDeletesField() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"my_deletes\"));\n    Document v1 = new Document();\n    v1.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v1.add(new StringField(\"version\", \"1\", Field.Store.YES));\n    writer.addDocument(v1);\n    Document v2 = new Document();\n    v2.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v2.add(new StringField(\"version\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), v2, new NumericDocValuesField(\"my_deletes\", 1));\n    writer.commit();\n    writer.close();\n    for (SegmentCommitInfo si : SegmentInfos.readLatestCommit(dir)) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n\n    IllegalArgumentException illegalError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"your_deletes\"));\n    });\n    assertEquals(\"cannot configure [your_deletes] as soft-deletes; \" +\n        \"this index uses [my_deletes] as soft-deletes already\", illegalError.getMessage());\n\n    IndexWriterConfig softDeleteConfig = newIndexWriterConfig().setSoftDeletesField(\"my_deletes\")\n        .setMergePolicy(new SoftDeletesRetentionMergePolicy(\"my_deletes\", () -> new MatchAllDocsQuery(), newMergePolicy()));\n    writer = new IndexWriter(dir, softDeleteConfig);\n    Document tombstone = new Document();\n    tombstone.add(new StringField(\"id\", \"tombstone\", Field.Store.YES));\n    tombstone.add(new NumericDocValuesField(\"my_deletes\", 1));\n    writer.addDocument(tombstone);\n    writer.flush();\n    for (SegmentCommitInfo si : writer.segmentInfos) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n    writer.close();\n    // reopen writer without soft-deletes field should be prevented\n    IllegalArgumentException reopenError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig());\n    });\n    assertEquals(\"this index has [my_deletes] as soft-deletes already\" +\n        \" but soft-deletes field is not configured in IWC\", reopenError.getMessage());\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"631ea3d1607299c59f33edef140ffc19a81f07a0","date":1532450367,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testPreventChangingSoftDeletesField().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testPreventChangingSoftDeletesField().mjava","sourceNew":"  public void testPreventChangingSoftDeletesField() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"my_deletes\"));\n    Document v1 = new Document();\n    v1.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v1.add(new StringField(\"version\", \"1\", Field.Store.YES));\n    writer.addDocument(v1);\n    Document v2 = new Document();\n    v2.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v2.add(new StringField(\"version\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), v2, new NumericDocValuesField(\"my_deletes\", 1));\n    writer.commit();\n    writer.close();\n    for (SegmentCommitInfo si : SegmentInfos.readLatestCommit(dir)) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n\n    IllegalArgumentException illegalError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"your_deletes\"));\n    });\n    assertEquals(\"cannot configure [your_deletes] as soft-deletes; \" +\n        \"this index uses [my_deletes] as soft-deletes already\", illegalError.getMessage());\n\n    IndexWriterConfig softDeleteConfig = newIndexWriterConfig().setSoftDeletesField(\"my_deletes\")\n        .setMergePolicy(new SoftDeletesRetentionMergePolicy(\"my_deletes\", () -> new MatchAllDocsQuery(), newMergePolicy()));\n    writer = new IndexWriter(dir, softDeleteConfig);\n    Document tombstone = new Document();\n    tombstone.add(new StringField(\"id\", \"tombstone\", Field.Store.YES));\n    tombstone.add(new NumericDocValuesField(\"my_deletes\", 1));\n    writer.addDocument(tombstone);\n    writer.flush();\n    for (SegmentCommitInfo si : writer.cloneSegmentInfos()) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n    writer.close();\n    // reopen writer without soft-deletes field should be prevented\n    IllegalArgumentException reopenError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig());\n    });\n    assertEquals(\"this index has [my_deletes] as soft-deletes already\" +\n        \" but soft-deletes field is not configured in IWC\", reopenError.getMessage());\n    dir.close();\n  }\n\n","sourceOld":"  public void testPreventChangingSoftDeletesField() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"my_deletes\"));\n    Document v1 = new Document();\n    v1.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v1.add(new StringField(\"version\", \"1\", Field.Store.YES));\n    writer.addDocument(v1);\n    Document v2 = new Document();\n    v2.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    v2.add(new StringField(\"version\", \"2\", Field.Store.YES));\n    writer.softUpdateDocument(new Term(\"id\", \"1\"), v2, new NumericDocValuesField(\"my_deletes\", 1));\n    writer.commit();\n    writer.close();\n    for (SegmentCommitInfo si : SegmentInfos.readLatestCommit(dir)) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n\n    IllegalArgumentException illegalError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig().setSoftDeletesField(\"your_deletes\"));\n    });\n    assertEquals(\"cannot configure [your_deletes] as soft-deletes; \" +\n        \"this index uses [my_deletes] as soft-deletes already\", illegalError.getMessage());\n\n    IndexWriterConfig softDeleteConfig = newIndexWriterConfig().setSoftDeletesField(\"my_deletes\")\n        .setMergePolicy(new SoftDeletesRetentionMergePolicy(\"my_deletes\", () -> new MatchAllDocsQuery(), newMergePolicy()));\n    writer = new IndexWriter(dir, softDeleteConfig);\n    Document tombstone = new Document();\n    tombstone.add(new StringField(\"id\", \"tombstone\", Field.Store.YES));\n    tombstone.add(new NumericDocValuesField(\"my_deletes\", 1));\n    writer.addDocument(tombstone);\n    writer.flush();\n    for (SegmentCommitInfo si : writer.segmentInfos) {\n      FieldInfos fieldInfos = IndexWriter.readFieldInfos(si);\n      assertEquals(\"my_deletes\", fieldInfos.getSoftDeletesField());\n      assertTrue(fieldInfos.fieldInfo(\"my_deletes\").isSoftDeletesField());\n    }\n    writer.close();\n    // reopen writer without soft-deletes field should be prevented\n    IllegalArgumentException reopenError = expectThrows(IllegalArgumentException.class, () -> {\n      new IndexWriter(dir, newIndexWriterConfig());\n    });\n    assertEquals(\"this index has [my_deletes] as soft-deletes already\" +\n        \" but soft-deletes field is not configured in IWC\", reopenError.getMessage());\n    dir.close();\n  }\n\n","bugFix":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"631ea3d1607299c59f33edef140ffc19a81f07a0":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["eeba0a4d0845889a402dd225793d62f009d029c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"eeba0a4d0845889a402dd225793d62f009d029c9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f592209545c71895260367152601e9200399776d":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["631ea3d1607299c59f33edef140ffc19a81f07a0"]},"commit2Childs":{"631ea3d1607299c59f33edef140ffc19a81f07a0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac","f592209545c71895260367152601e9200399776d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b70042a8a492f7054d480ccdd2be9796510d4327","eeba0a4d0845889a402dd225793d62f009d029c9"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["631ea3d1607299c59f33edef140ffc19a81f07a0","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"eeba0a4d0845889a402dd225793d62f009d029c9":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}