{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillSideways#search(SimpleDrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      drillSidewaysCollectors[idx++] = new FacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public SimpleDrillSidewaysResult search(SimpleDrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    SimpleFacetsCollector drillDownCollector = new SimpleFacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new SimpleDrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    SimpleFacetsCollector[] drillSidewaysCollectors = new SimpleFacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      drillSidewaysCollectors[idx++] = new SimpleFacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      SimpleDrillSidewaysQuery dsq = new SimpleDrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new SimpleDrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a6c8fcce6eb5b976a26c9543c230548f7aa13e1","date":1388472624,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n\n    int idx = 0;\n    for(String dim : drillDownDims.keySet()) {\n      drillSidewaysCollectors[idx++] = new FacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40640359164f629dd440a47df2e145d084ce9645","date":1391711808,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    Query[] drillDownQueries = new Query[clauses.length-startClause];\n    for(int i=startClause;i<clauses.length;i++) {\n      drillDownQueries[i-startClause] = clauses[i].getQuery();\n    }\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    boolean useCollectorMethod = scoreSubDocsAtOnce();\n\n    Term[][] drillDownTerms = null;\n\n    if (!useCollectorMethod) {\n      // Optimistic: assume subQueries of the DDQ are either\n      // TermQuery or BQ OR of TermQuery; if this is wrong\n      // then we detect it and fallback to the mome general\n      // but slower DrillSidewaysCollector:\n      drillDownTerms = new Term[clauses.length-startClause][];\n      for(int i=startClause;i<clauses.length;i++) {\n        Query q = clauses[i].getQuery();\n\n        // DrillDownQuery always wraps each subQuery in\n        // ConstantScoreQuery:\n        assert q instanceof ConstantScoreQuery;\n\n        q = ((ConstantScoreQuery) q).getQuery();\n\n        if (q instanceof TermQuery) {\n          drillDownTerms[i-startClause] = new Term[] {((TermQuery) q).getTerm()};\n        } else if (q instanceof BooleanQuery) {\n          BooleanQuery q2 = (BooleanQuery) q;\n          BooleanClause[] clauses2 = q2.getClauses();\n          drillDownTerms[i-startClause] = new Term[clauses2.length];\n          for(int j=0;j<clauses2.length;j++) {\n            if (clauses2[j].getQuery() instanceof TermQuery) {\n              drillDownTerms[i-startClause][j] = ((TermQuery) clauses2[j].getQuery()).getTerm();\n            } else {\n              useCollectorMethod = true;\n              break;\n            }\n          }\n        } else {\n          useCollectorMethod = true;\n        }\n      }\n    }\n\n    if (useCollectorMethod) {\n      // TODO: maybe we could push the \"collector method\"\n      // down into the optimized scorer to have a tighter\n      // integration ... and so TermQuery clauses could\n      // continue to run \"optimized\"\n      collectorMethod(query, baseQuery, startClause, hitCollector, drillDownCollector, drillSidewaysCollectors);\n    } else {\n      DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownTerms);\n      searcher.search(dsq, hitCollector);\n    }\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60596f28be69b10c37a56a303c2dbea07b2ca4ba","date":1425060541,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    Query[] drillDownQueries = new Query[clauses.length-startClause];\n    for(int i=startClause;i<clauses.length;i++) {\n      drillDownQueries[i-startClause] = clauses[i].getQuery();\n    }\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a borrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    Query[] drillDownQueries = new Query[clauses.length-startClause];\n    for(int i=startClause;i<clauses.length;i++) {\n      drillDownQueries[i-startClause] = clauses[i].getQuery();\n    }\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    Query[] drillDownQueries = new Query[clauses.length-startClause];\n    for(int i=startClause;i<clauses.length;i++) {\n      drillDownQueries[i-startClause] = clauses[i].getQuery();\n    }\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a borrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    Query[] drillDownQueries = new Query[clauses.length-startClause];\n    for(int i=startClause;i<clauses.length;i++) {\n      drillDownQueries[i-startClause] = clauses[i].getQuery();\n    }\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a borrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    BooleanQuery ddq = query.getBooleanQuery();\n    BooleanClause[] clauses = ddq.getClauses();\n\n    Query baseQuery;\n    int startClause;\n    if (clauses.length == drillDownDims.size()) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n      startClause = 0;\n    } else {\n      assert clauses.length == 1+drillDownDims.size();\n      baseQuery = clauses[0].getQuery();\n      startClause = 1;\n    }\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    Query[] drillDownQueries = new Query[clauses.length-startClause];\n    for(int i=startClause;i<clauses.length;i++) {\n      drillDownQueries[i-startClause] = clauses[i].getQuery();\n    }\n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a borrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1a8012558b612b6f5ff58838c8a7fd625dac316","date":1476884867,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a borrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2305f39a86a068f1cee6fc5fbdfb760b153ac138","date":1476906991,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a borrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a borrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91eb857a56b1a3a6659c666f88e2398347fc1c5a","date":1483442809,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String, Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n\n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    DrillSidewaysQuery dsq =\n            new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries,\n                    scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors,\n            drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String, Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n\n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    DrillSidewaysQuery dsq =\n            new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries,\n                    scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors,\n            drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String,Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n    \n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n    \n    DrillSidewaysQuery dsq = new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries, scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors, drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String, Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n\n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    DrillSidewaysQuery dsq =\n            new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries,\n                    scoreSubDocsAtOnce());\n    if (hitCollector.scoreMode().needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors,\n            drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String, Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n\n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    DrillSidewaysQuery dsq =\n            new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries,\n                    scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors,\n            drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(DrillDownQuery,Collector).mjava","sourceNew":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String, Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n\n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    DrillSidewaysQuery dsq =\n            new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries,\n                    scoreSubDocsAtOnce());\n    if (hitCollector.scoreMode().needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors,\n            drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","sourceOld":"  /**\n   * Search, collecting hits with a {@link Collector}, and\n   * computing drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(DrillDownQuery query, Collector hitCollector) throws IOException {\n\n    Map<String, Integer> drillDownDims = query.getDims();\n\n    FacetsCollector drillDownCollector = new FacetsCollector();\n\n    if (drillDownDims.isEmpty()) {\n      // There are no drill-down dims, so there is no\n      // drill-sideways to compute:\n      searcher.search(query, MultiCollector.wrap(hitCollector, drillDownCollector));\n      return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, null, null), null);\n    }\n\n    Query baseQuery = query.getBaseQuery();\n    if (baseQuery == null) {\n      // TODO: we could optimize this pure-browse case by\n      // making a custom scorer instead:\n      baseQuery = new MatchAllDocsQuery();\n    }\n    Query[] drillDownQueries = query.getDrillDownQueries();\n\n    FacetsCollector[] drillSidewaysCollectors = new FacetsCollector[drillDownDims.size()];\n    for (int i = 0; i < drillSidewaysCollectors.length; i++) {\n      drillSidewaysCollectors[i] = new FacetsCollector();\n    }\n\n    DrillSidewaysQuery dsq =\n            new DrillSidewaysQuery(baseQuery, drillDownCollector, drillSidewaysCollectors, drillDownQueries,\n                    scoreSubDocsAtOnce());\n    if (hitCollector.needsScores() == false) {\n      // this is a horrible hack in order to make sure IndexSearcher will not\n      // attempt to cache the DrillSidewaysQuery\n      hitCollector = new FilterCollector(hitCollector) {\n        @Override\n        public boolean needsScores() {\n          return true;\n        }\n      };\n    }\n    searcher.search(dsq, hitCollector);\n\n    return new DrillSidewaysResult(buildFacetsResult(drillDownCollector, drillSidewaysCollectors,\n            drillDownDims.keySet().toArray(new String[drillDownDims.size()])), null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["40640359164f629dd440a47df2e145d084ce9645"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"8a6c8fcce6eb5b976a26c9543c230548f7aa13e1":["21d36d0db865f7b84026b447bec653469a6e66df"],"40640359164f629dd440a47df2e145d084ce9645":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"2305f39a86a068f1cee6fc5fbdfb760b153ac138":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","d1a8012558b612b6f5ff58838c8a7fd625dac316"],"417142ff08fda9cf0b72d5133e63097a166c6458":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","9fc47cb7b4346802411bb432f501ed0673d7119e"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","91eb857a56b1a3a6659c666f88e2398347fc1c5a"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"d1a8012558b612b6f5ff58838c8a7fd625dac316":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["40640359164f629dd440a47df2e145d084ce9645","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8a6c8fcce6eb5b976a26c9543c230548f7aa13e1"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["91eb857a56b1a3a6659c666f88e2398347fc1c5a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["417142ff08fda9cf0b72d5133e63097a166c6458"]},"commit2Childs":{"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["417142ff08fda9cf0b72d5133e63097a166c6458","f03e4bed5023ec3ef93a771b8888cae991cf448d","9fc47cb7b4346802411bb432f501ed0673d7119e"],"8a6c8fcce6eb5b976a26c9543c230548f7aa13e1":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"40640359164f629dd440a47df2e145d084ce9645":["60596f28be69b10c37a56a303c2dbea07b2ca4ba","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"2305f39a86a068f1cee6fc5fbdfb760b153ac138":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"417142ff08fda9cf0b72d5133e63097a166c6458":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2305f39a86a068f1cee6fc5fbdfb760b153ac138","d1a8012558b612b6f5ff58838c8a7fd625dac316"],"d1a8012558b612b6f5ff58838c8a7fd625dac316":["2305f39a86a068f1cee6fc5fbdfb760b153ac138"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21d36d0db865f7b84026b447bec653469a6e66df","3cc728b07df73b197e6d940d27f9b08b63918f13"],"21d36d0db865f7b84026b447bec653469a6e66df":["8a6c8fcce6eb5b976a26c9543c230548f7aa13e1"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["40640359164f629dd440a47df2e145d084ce9645"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f03e4bed5023ec3ef93a771b8888cae991cf448d","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}