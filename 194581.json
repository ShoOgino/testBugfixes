{"path":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","commits":[{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer());\n\n      if (localParams != null)\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n\n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.getQueryParserDefaultOperator(getReq().getSchema(), getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccff665065c8b73e2b143bd5d0277fdb3c8e7f0b","date":1483542662,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","sourceNew":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.getQueryParserDefaultOperator(getReq().getSchema(), getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer());\n\n      if (localParams != null)\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n\n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.getQueryParserDefaultOperator(getReq().getSchema(), getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"491c9672ec42582fe43960452dbd37f1c80fe0f0","date":1483739222,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","sourceNew":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.getQueryParserDefaultOperator(getReq().getSchema(), getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer());\n\n      if (localParams != null)\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n\n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.getQueryParserDefaultOperator(getReq().getSchema(), getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c418b5fb43bf7b591b636df532dd1ac44296469a","date":1494834249,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","sourceNew":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.parseOP(getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.getQueryParserDefaultOperator(getReq().getSchema(), getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f","date":1495081498,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","sourceNew":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.parseOP(getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.getQueryParserDefaultOperator(getReq().getSchema(), getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d057970b5f9fcaabc49d2f54c59a5d2a09da1769","date":1495200448,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","sourceNew":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.parseOP(getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.parseOP(getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ComplexPhraseQParserPlugin.ComplexPhraseQParser#parse().mjava","sourceNew":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.parseOP(getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Query parse() throws SyntaxError {\n      String qstr = getString();\n\n      String defaultField = getParam(CommonParams.DF);\n      if (defaultField == null) {\n        defaultField = getReq().getSchema().getDefaultSearchFieldName();\n      }\n\n      SolrQueryParserDelegate reverseAwareParser = new SolrQueryParserDelegate(this, defaultField);\n      \n      lparser = new ComplexPhraseQueryParser(defaultField, getReq().getSchema().getQueryAnalyzer())\n          {\n              protected Query newWildcardQuery(org.apache.lucene.index.Term t) {\n                try {\n                  org.apache.lucene.search.Query wildcardQuery = reverseAwareParser.getWildcardQuery(t.field(), t.text());\n                  setRewriteMethod(wildcardQuery);\n                  return wildcardQuery;\n                } catch (SyntaxError e) {\n                  throw new RuntimeException(e);\n                }\n              }\n\n              private Query setRewriteMethod(org.apache.lucene.search.Query query) {\n                if (query instanceof MultiTermQuery) {\n                  ((MultiTermQuery) query).setRewriteMethod(\n                      org.apache.lucene.search.MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n                }\n                return query;\n              }\n              \n              protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive,\n                  boolean endInclusive) {\n                boolean reverse = reverseAwareParser.isRangeShouldBeProtectedFromReverse(field, part1);\n                return super.newRangeQuery(field, \n                                            reverse ? reverseAwareParser.getLowerBoundForReverse() : part1, \n                                            part2,\n                                            startInclusive || reverse, \n                                            endInclusive);\n              }\n          }\n          ;\n\n      lparser.setAllowLeadingWildcard(true);\n          \n      if (localParams != null) {\n        inOrder = localParams.getBool(\"inOrder\", inOrder);\n      }\n      \n      lparser.setInOrder(inOrder);\n\n      QueryParser.Operator defaultOperator = QueryParsing.getQueryParserDefaultOperator(getReq().getSchema(), getParam(QueryParsing.OP));\n\n      if (QueryParser.Operator.AND.equals(defaultOperator))\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.AND);\n      else\n        lparser.setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator.OR);\n\n      try {\n        return lparser.parse(qstr);\n      } catch (ParseException pe) {\n        throw new SyntaxError(pe);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c418b5fb43bf7b591b636df532dd1ac44296469a":["ccff665065c8b73e2b143bd5d0277fdb3c8e7f0b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ccff665065c8b73e2b143bd5d0277fdb3c8e7f0b","d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"d057970b5f9fcaabc49d2f54c59a5d2a09da1769":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ccff665065c8b73e2b143bd5d0277fdb3c8e7f0b":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f":["ccff665065c8b73e2b143bd5d0277fdb3c8e7f0b","c418b5fb43bf7b591b636df532dd1ac44296469a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"491c9672ec42582fe43960452dbd37f1c80fe0f0":["9367dbf5b00d7764583d991c1888f4acc9c9991a","ccff665065c8b73e2b143bd5d0277fdb3c8e7f0b"]},"commit2Childs":{"c418b5fb43bf7b591b636df532dd1ac44296469a":["c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"d057970b5f9fcaabc49d2f54c59a5d2a09da1769":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"ccff665065c8b73e2b143bd5d0277fdb3c8e7f0b":["c418b5fb43bf7b591b636df532dd1ac44296469a","e9017cf144952056066919f1ebc7897ff9bd71b1","c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"c5536d1fc2015d46bbeb8163f6f8b99483c7cc1f":["d057970b5f9fcaabc49d2f54c59a5d2a09da1769"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["ccff665065c8b73e2b143bd5d0277fdb3c8e7f0b","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"491c9672ec42582fe43960452dbd37f1c80fe0f0":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817","491c9672ec42582fe43960452dbd37f1c80fe0f0"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}