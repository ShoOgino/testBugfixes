{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","commits":[{"id":"7bb7d4caf24bc521fa8ac35f463f50724b4a91d8","date":1343155480,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      int suffixIndex = -1;\n      for (String suffix : suffixes) {\n        suffixIndex = clazzName.lastIndexOf(suffix);\n        if (suffixIndex != -1) {\n          break;\n        }\n      }\n      final String name = clazzName.substring(0, suffixIndex).toLowerCase(Locale.ROOT);\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3030c092b9199f24f35ddb0800cf5c7ad016f84a","date":1343157886,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","sourceNew":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      int suffixIndex = -1;\n      for (String suffix : suffixes) {\n        suffixIndex = clazzName.lastIndexOf(suffix);\n        if (suffixIndex != -1) {\n          break;\n        }\n      }\n      final String name = clazzName.substring(0, suffixIndex).toLowerCase(Locale.ROOT);\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a1a22b1ad88b436661458df567f3fdb446392a4","date":1343224444,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9499b09dd7d06d975f31e59a9b00653a86f9cad2","date":1343325589,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","sourceNew":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    this.suffixes = suffixes;\n    reload(classloader);\n  }\n\n","sourceOld":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);\n    final LinkedHashMap<String,Class<? extends S>> services = new LinkedHashMap<String,Class<? extends S>>();\n    while (loader.hasNext()) {\n      final Class<? extends S> service = loader.next();\n      final String clazzName = service.getSimpleName();\n      String name = null;\n      for (String suffix : suffixes) {\n        if (clazzName.endsWith(suffix)) {\n          name = clazzName.substring(0, clazzName.length() - suffix.length()).toLowerCase(Locale.ROOT);\n          break;\n        }\n      }\n      if (name == null) {\n        throw new ServiceConfigurationError(\"The class name \" + service.getName() +\n          \" has wrong suffix, allowed are: \" + Arrays.toString(suffixes));\n      }\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    this.suffixes = suffixes;\n    reload(classloader);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","pathOld":"/dev/null","sourceNew":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    this.suffixes = suffixes;\n    reload(classloader);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d89a429c822ccbd96c4c675d51fdd79633a62f73","date":1363169433,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","sourceNew":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    this.suffixes = suffixes;\n    // if clazz' classloader is not a parent of the given one, we scan clazz's classloader, too:\n    final ClassLoader clazzClassloader = clazz.getClassLoader();\n    if (clazzClassloader != null && !SPIClassIterator.isParentClassLoader(clazzClassloader, classloader)) {\n      reload(clazzClassloader);\n    }\n    reload(classloader);\n  }\n\n","sourceOld":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    this.suffixes = suffixes;\n    reload(classloader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c876aba909b05165f3d290e26b5a4121214f553","date":1449340310,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","sourceNew":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    this.suffixes = suffixes;\n    // if clazz' classloader is not a parent of the given one, we scan clazz's classloader, too:\n    final ClassLoader clazzClassloader = clazz.getClassLoader();\n    if (classloader == null) {\n      classloader = clazzClassloader;\n    }\n    if (clazzClassloader != null && !SPIClassIterator.isParentClassLoader(clazzClassloader, classloader)) {\n      reload(clazzClassloader);\n    }\n    reload(classloader);\n  }\n\n","sourceOld":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    this.suffixes = suffixes;\n    // if clazz' classloader is not a parent of the given one, we scan clazz's classloader, too:\n    final ClassLoader clazzClassloader = clazz.getClassLoader();\n    if (clazzClassloader != null && !SPIClassIterator.isParentClassLoader(clazzClassloader, classloader)) {\n      reload(clazzClassloader);\n    }\n    reload(classloader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1b329156f9702cbfcdd80795c864111bcd341b","date":1561167997,"type":4,"author":"Tomoko Uchida","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AnalysisSPILoader#AnalysisSPILoader(Class[S],String[],ClassLoader).mjava","sourceNew":null,"sourceOld":"  public AnalysisSPILoader(Class<S> clazz, String[] suffixes, ClassLoader classloader) {\n    this.clazz = clazz;\n    this.suffixes = suffixes;\n    // if clazz' classloader is not a parent of the given one, we scan clazz's classloader, too:\n    final ClassLoader clazzClassloader = clazz.getClassLoader();\n    if (classloader == null) {\n      classloader = clazzClassloader;\n    }\n    if (clazzClassloader != null && !SPIClassIterator.isParentClassLoader(clazzClassloader, classloader)) {\n      reload(clazzClassloader);\n    }\n    reload(classloader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3030c092b9199f24f35ddb0800cf5c7ad016f84a":["7bb7d4caf24bc521fa8ac35f463f50724b4a91d8"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"d89a429c822ccbd96c4c675d51fdd79633a62f73":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["5a1a22b1ad88b436661458df567f3fdb446392a4"],"7bb7d4caf24bc521fa8ac35f463f50724b4a91d8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"1c876aba909b05165f3d290e26b5a4121214f553":["d89a429c822ccbd96c4c675d51fdd79633a62f73"],"7b1b329156f9702cbfcdd80795c864111bcd341b":["1c876aba909b05165f3d290e26b5a4121214f553"],"5a1a22b1ad88b436661458df567f3fdb446392a4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3030c092b9199f24f35ddb0800cf5c7ad016f84a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b1b329156f9702cbfcdd80795c864111bcd341b"]},"commit2Childs":{"3030c092b9199f24f35ddb0800cf5c7ad016f84a":["5a1a22b1ad88b436661458df567f3fdb446392a4"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"d89a429c822ccbd96c4c675d51fdd79633a62f73":["1c876aba909b05165f3d290e26b5a4121214f553"],"7bb7d4caf24bc521fa8ac35f463f50724b4a91d8":["3030c092b9199f24f35ddb0800cf5c7ad016f84a"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["aba371508186796cc6151d8223a5b4e16d02e26e","d89a429c822ccbd96c4c675d51fdd79633a62f73","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aba371508186796cc6151d8223a5b4e16d02e26e","7bb7d4caf24bc521fa8ac35f463f50724b4a91d8","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","5a1a22b1ad88b436661458df567f3fdb446392a4"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"1c876aba909b05165f3d290e26b5a4121214f553":["7b1b329156f9702cbfcdd80795c864111bcd341b"],"5a1a22b1ad88b436661458df567f3fdb446392a4":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"7b1b329156f9702cbfcdd80795c864111bcd341b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}